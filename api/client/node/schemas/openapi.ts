/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/events': {
    /**
     * List ingested events
     * @description List ingested events within a time range.
     */
    get: operations['listEvents']
    /**
     * Ingest events
     * @description Ingests an event or batch of events following the CloudEvents specification.
     */
    post: operations['ingestEvents']
  }
  '/api/v1/meters': {
    /**
     * List meters
     * @description List meters.
     */
    get: operations['listMeters']
    /**
     * ☁ Create meter
     * @description *Available in OpenMeter Cloud.*
     * *In the open-source version, meters are created in the configuration file.*
     *
     * Create a meter.
     */
    post: operations['createMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}': {
    /**
     * Get meter
     * @description Get meter by ID or slug
     */
    get: operations['getMeter']
    /**
     * ☁ Delete meter
     * @description *Available in OpenMeter Cloud.*
     *
     * Delete a meter by ID or slug.
     */
    delete: operations['deleteMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/query': {
    /**
     * Query meter
     * @description Query meter for usage.
     */
    get: operations['queryMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/subjects': {
    /**
     * List meter subjects
     * @description List subjects for a meter.
     */
    get: operations['listMeterSubjects']
  }
  '/api/v1/portal/tokens': {
    /**
     * ☁ List portal tokens
     * @description *Available in OpenMeter Cloud.*
     *
     * List consumer portal tokens.
     */
    get: operations['listPortalTokens']
    /**
     * Create portal token
     * @description Create a consumer portal token.
     */
    post: operations['createPortalToken']
  }
  '/api/v1/portal/tokens/invalidate': {
    /**
     * ☁ Invalidate portal tokens
     * @description *Available in OpenMeter Cloud.*
     *
     * Invalidates consumer portal tokens by ID or subject.
     */
    post: operations['invalidatePortalTokens']
  }
  '/api/v1/subjects': {
    /**
     * ☁ List subjects
     * @description *Available in OpenMeter Cloud.*
     *
     * List subjects.
     */
    get: operations['listSubjects']
    /**
     * ☁ Upsert subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Upserts a subject. Creates or updates subject.
     * If the subject doesn't exist, it will be created.
     * If the subject exists, it will be partially updated with the provided fields.
     */
    post: operations['upsertSubject']
  }
  '/api/v1/subjects/{subjectIdOrKey}': {
    /**
     * ☁ Get subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Get subject by ID or key.
     */
    get: operations['getSubject']
    /**
     * ☁ Delete subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Delete a subject by ID or key.
     */
    delete: operations['deleteSubject']
  }
  '/api/v1/portal/meters/{meterSlug}/query': {
    /**
     * Query portal meter
     * @description Query meter for consumer portal. This endpoint is publicly exposable to consumers.
     */
    get: operations['queryPortalMeter']
  }
  '/api/v1/entitlements': {
    /**
     * List entitlements
     * @description List entitlements.
     */
    get: operations['listEntitlements']
  }
  '/api/v1/features': {
    /**
     * List features
     * @description List features.
     */
    get: operations['listFeatures']
    /**
     * Create feature
     * @description Creates a feature.
     */
    post: operations['createFeature']
  }
  '/api/v1/features/{featureId}': {
    /**
     * Get feature
     * @description Get feature by id.
     */
    get: operations['getFeature']
    /**
     * Delete feature
     * @description Delete a feature by key.
     */
    delete: operations['deleteFeature']
  }
  '/api/v1/grants': {
    /**
     * List grants
     * @description List all grants.
     */
    get: operations['listGrants']
  }
  '/api/v1/grants/{grantId}': {
    /**
     * Delete a grant
     * @description Void (delete) a grant. A grant can only be deleted if it hasn't been used.
     */
    delete: operations['voidGrant']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements': {
    /**
     * List entitlements
     * @description List all entitlements for a subject.
     */
    get: operations['listSubjectEntitlements']
    /**
     * Create entitlement
     * @description Create an entitlement for a subject.
     */
    post: operations['createEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}': {
    /**
     * Get entitlement
     * @description Get entitlement by id.
     */
    get: operations['getEntitlement']
    /**
     * Delete entitlement
     * @description Delete an entitlement by id.
     */
    delete: operations['deleteEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/grants': {
    /**
     * List grants for an entitlement
     * @description List all grants for an entitlement.
     */
    get: operations['listEntitlementGrants']
    /**
     * Create grant
     * @description Create a grant for an entitlement.
     */
    post: operations['createGrant']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value': {
    /**
     * Get the balance of a specific entitlement.
     * @description Get the balance of a specific entitlement.
     */
    get: operations['getEntitlementValue']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history': {
    /**
     * Get the balance history of a specific entitlement.
     * @description Get the balance history of a specific entitlement.
     *
     * The windows are inclusive at their start and exclusive at their end.
     * The last window may be smaller than the window size and is inclusive at both ends.
     */
    get: operations['getEntitlementHistory']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset': {
    /**
     * Reset entitlement
     * @description Reset the entitlement usage and start a new period. Grants that can be are rolled over.
     */
    post: operations['resetEntitlementUsage']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    /**
     * @description Metadata fields for a resource.
     * These fields are automatically populated by the system for the entities we manage.
     */
    SharedMetaFields: {
      /**
       * @description Readonly unique ULID identifier.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Format: date-time
       * @description The date and time the resource was created.
       * @example 2023-01-01T00:00:00Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description The date and time the resource was last updated.
       * @example 2023-01-01T00:00:00Z
       */
      updatedAt: string
      /**
       * Format: date-time
       * @description The date and time the resource was deleted.
       * @example 2023-01-01T00:00:00Z
       */
      deletedAt: string
    }
    /**
     * @description Conflict
     * @example {
     *   "type": "about:blank",
     *   "title": "Conflict",
     *   "status": 409,
     *   "detail": "ledger (default.01HXVNDJR532E8GTBVSC2XK5D4) already exitst for subject subject-1",
     *   "instance": "urn:request:local/JMOlctsKV8-000001",
     *   "conflictingEntityId": "01HXVNDJR532E8GTBVSC2XK5D4"
     * }
     */
    ConflictProblem: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @example urn:problem-type:bad-request
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int32
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example body must be a JSON object
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance?: string
      extensions?: {
        /**
         * @description The id of the conflicting entity.
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        conflictingEntityId: string
      }
      [key: string]: unknown
    }
    /**
     * @description A Problem Details object (RFC 7807).
     * Additional properties specific to the problem type may be present.
     * @example {
     *   "type": "urn:problem-type:bad-request",
     *   "title": "Bad Request",
     *   "status": 400,
     *   "detail": "body must be a JSON object"
     * }
     */
    Problem: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @example urn:problem-type:bad-request
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int32
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example body must be a JSON object
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance?: string
      [key: string]: unknown
    }
    /**
     * @description CloudEvents Specification JSON Schema
     * @example {
     *   "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3c",
     *   "source": "service-name",
     *   "specversion": "1.0",
     *   "type": "prompt",
     *   "subject": "customer-id",
     *   "time": "2023-01-01T01:01:01.001Z",
     *   "data": {
     *     "tokens": "1234",
     *     "model": "gpt-4-turbo",
     *     "type": "input"
     *   }
     * }
     */
    Event: {
      /**
       * @description Identifies the event.
       * @example 5c10fade-1c9e-4d6c-8275-c52c36731d3c
       */
      id: string
      /**
       * Format: uri-reference
       * @description Identifies the context in which an event happened.
       * @example service-name
       */
      source: string
      /**
       * @description The version of the CloudEvents specification which the event uses.
       * @example 1.0
       */
      specversion: string
      /**
       * @description Describes the type of event related to the originating occurrence.
       * @example prompt
       */
      type: string
      /**
       * @description Content type of the data value. Must adhere to RFC 2046 format.
       * @example application/json
       * @enum {string|null}
       */
      datacontenttype?: 'application/json' | null
      /**
       * Format: uri
       * @description Identifies the schema that data adheres to.
       */
      dataschema?: string | null
      /**
       * @description Describes the subject of the event in the context of the event producer (identified by source).
       * @example customer-id
       */
      subject: string
      /**
       * Format: date-time
       * @description Timestamp of when the occurrence happened. Must adhere to RFC 3339.
       * @example 2023-01-01T01:01:01.001Z
       */
      time?: string | null
      /**
       * @description The event payload.
       * @example {
       *   "tokens": "1234",
       *   "model": "gpt-4-turbo"
       * }
       */
      data?: {
        [key: string]: unknown
      }
    }
    /**
     * @description An ingested event with optional validation error.
     * @example {
     *   "event": {
     *     "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3d",
     *     "source": "service-name",
     *     "specversion": "1.0",
     *     "type": "prompt",
     *     "subject": "customer-id",
     *     "time": "2023-01-01T01:01:01.001Z",
     *     "data": {
     *       "tokens": "1234",
     *       "model": "gpt-4-turbo"
     *     }
     *   },
     *   "validationError": "meter not found for event"
     * }
     */
    IngestedEvent: {
      event: components['schemas']['Event']
      /** @example invalid event */
      validationError?: string
    }
    /**
     * @description A feature is a feature or service offered to a customer.
     * For example: CPU-Hours, Tokens, API Calls, etc.
     */
    FeatureCreateInputs: {
      /**
       * @description The unique key of the feature to reference it from your application.
       *
       * @example gpt4_tokens
       */
      key: string
      /**
       * @description The name of the feature.
       *
       * @example AI Tokens
       */
      name: string
      /** @description Additional metadata for the feature. */
      metadata?: {
        [key: string]: string
      }
      /**
       * @description The meter that the feature is associated with and decreases grants by usage.
       * If present, the usage of the feature can be metered.
       *
       * @example tokens_total
       */
      meterSlug?: string
      /**
       * @description Optional meter group by filters. Useful if the meter scope is broader than what feature tracks.
       *
       * @example {
       *   "model": "gpt-4"
       * }
       */
      meterGroupByFilters?: {
        [key: string]: string
      }
    }
    /**
     * @description A feature is a feature or service offered to a customer.
     * For example: CPU-Hours, Tokens, API Calls, etc.
     */
    Feature: {
      /**
       * Format: date-time
       * @description If the feature is archived, it will not be used for grants or usage.
       *
       * @example 2023-01-01T00:00:00Z
       */
      archivedAt?: string
    } & components['schemas']['FeatureCreateInputs'] &
      components['schemas']['SharedMetaFields']
    EntitlementCreateSharedFields: {
      /**
       * @description The feature the subject is entitled to use. Either ID or key must be present.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId?: string
      /**
       * @description The feature the subject is entitled to use. Either ID or key must be present.
       *
       * @example my-feature
       */
      featureKey?: string
      /** @description Additional metadata for the feature. */
      metadata?: {
        [key: string]: string
      }
      usagePeriod?: components['schemas']['RecurringPeriodCreateInput']
    }
    EntitlementSharedFields: components['schemas']['SharedMetaFields'] &
      components['schemas']['EntitlementCreateSharedFields'] & {
        /**
         * @description The identifier key unique to the subject
         * @example customer-1
         */
        subjectKey: string
        usagePeriod?: components['schemas']['RecurringPeriod']
      }
    EntitlementMeteredCreateInputs: components['schemas']['EntitlementCreateSharedFields'] & {
      /**
       * @example metered
       * @enum {string}
       */
      type: 'metered'
      /**
       * @description If softLimit=true the subject can use the feature even if the entitlement is exhausted.
       *
       * @default false
       */
      isSoftLimit?: boolean
      /**
       * @description If unlimited=true the subject can use the feature an unlimited amount.
       *
       * @default false
       */
      isUnlimited?: boolean
      usagePeriod: components['schemas']['RecurringPeriodCreateInput']
      /**
       * Format: double
       * @description You can issue usage automatically after reset. This usage is not rolled over.
       */
      issueAfterReset?: number
    }
    EntitlementCreateInputs:
      | components['schemas']['EntitlementMeteredCreateInputs']
      | components['schemas']['EntitlementStaticCreateInputs']
      | components['schemas']['EntitlementBooleanCreateInputs']
    /** @description Entitles a subject to use a feature. */
    EntitlementMetered: components['schemas']['EntitlementMeteredCreateInputs'] &
      components['schemas']['EntitlementSharedFields']
    EntitlementStaticCreateInputs: components['schemas']['EntitlementCreateSharedFields'] & {
      /**
       * @example static
       * @enum {string}
       */
      type: 'static'
      /**
       * @description The JSON parsable config of the entitlement.
       *
       * @example {"key1": "value1"}
       */
      config: string
    }
    /** @description Entitles a subject to use a feature. */
    EntitlementStatic: components['schemas']['EntitlementStaticCreateInputs'] &
      components['schemas']['EntitlementSharedFields']
    EntitlementBooleanCreateInputs: components['schemas']['EntitlementCreateSharedFields'] & {
      /**
       * @example boolean
       * @enum {string}
       */
      type: 'boolean'
    }
    /** @description Entitles a subject to use a feature. */
    EntitlementBoolean: components['schemas']['EntitlementBooleanCreateInputs'] &
      components['schemas']['EntitlementSharedFields']
    Entitlement:
      | components['schemas']['EntitlementMetered']
      | components['schemas']['EntitlementStatic']
      | components['schemas']['EntitlementBoolean']
    /**
     * @description A segment of the grant burn down history.
     *
     * A given segment represents the usage of a grant in a specific period.
     */
    GrantBurnDownHistorySegment: {
      period?: components['schemas']['Period']
      /**
       * Format: double
       * @description The usage of the grant in the period.
       *
       * @example 100
       */
      usage?: number
      /**
       * Format: double
       * @description Overuse that wasn't covered by grants.
       *
       * @example 25
       */
      overage?: number
      /**
       * Format: double
       * @description The entitlement balance at the start of the period.
       *
       * @example 100
       */
      balanceAtStart?: number
      /**
       * @description The balance breakdown of each active grant at the start of the period: GrantID: Balance
       *
       * @example {
       *   "01ARZ3NDEKTSV4RRFFQ69G5FAV": 100
       * }
       */
      grantBalancesAtStart?: {
        [key: string]: number
      }
      /**
       * Format: double
       * @description The entitlement balance at the end of the period.
       *
       * @example 100
       */
      balanceAtEnd?: number
      /**
       * @description The balance breakdown of each active grant at the start of the period: GrantID: Balance
       *
       * @example {
       *   "01ARZ3NDEKTSV4RRFFQ69G5FAV": 100
       * }
       */
      grantBalancesAtEnd?: {
        [key: string]: number
      }
      /** @description Which grants were actually burnt down in the period and by what amount. */
      grantUsages?: readonly components['schemas']['GrantUsageRecord'][]
    }
    GrantUsageRecord: {
      /**
       * @description The id of the grant.
       *
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      grantId?: string
      /**
       * Format: double
       * @description The usage of the grant.
       *
       * @example 100
       */
      usage?: number
    }
    /** @description A window of balance history. */
    BalanceHistoryWindow: {
      period?: components['schemas']['Period']
      /**
       * Format: double
       * @description The total usage of the feature in the period.
       *
       * @example 100
       */
      usage?: number
      /**
       * Format: double
       * @description The entitlement balance at the start of the period.
       *
       * @example 100
       */
      balanceAtStart?: number
    }
    /** @description The windowed balance history. */
    WindowedBalanceHistory: {
      /**
       * @description The windowed balance history.
       * Only returns rows for windows where there was usage.
       */
      windowedHistory?: components['schemas']['BalanceHistoryWindow'][]
      /** @description The grant burn down history in the period. */
      burndownHistory?: components['schemas']['GrantBurnDownHistorySegment'][]
    }
    /** @description A time period */
    Period: {
      /**
       * Format: date-time
       * @description Period start time where the amount was applied. If applicable.
       *
       * @example 2023-01-01T00:00:00Z
       */
      from: string
      /**
       * Format: date-time
       * @description Period end time where the amount was applied. If applicable.
       *
       * @example 2023-01-01T00:00:00Z
       */
      to: string
    }
    /**
     * @description List of pre-defined periods that can be used for recurring & scheduling.
     *
     * DAY:      Every day
     * WEEK:     Every week
     * MONTH:    Every month
     * YEAR:     Every year
     *
     * @enum {string}
     */
    RecurringPeriodEnum: 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
    /** @description Recurring period of an entitlement. */
    RecurringPeriodCreateInput: {
      interval: components['schemas']['RecurringPeriodEnum']
      /**
       * Format: date-time
       * @description An arbitrary anchor to base the recurring period on.
       * If not provided then defaults to now truncated to the hour.
       */
      anchor?: string
    }
    /** @description Recurring period of an entitlement. */
    RecurringPeriod: {
      interval: components['schemas']['RecurringPeriodEnum']
      /**
       * Format: date-time
       * @description An arbitrary anchor to base the recurring period on.
       */
      anchor: string
    }
    /** @description Grants are used to increase balance of specific subjects. */
    EntitlementGrantCreateInput: {
      /**
       * Format: double
       * @description The amount to grant. Should be a positive number.
       *
       * @example 100
       */
      amount: number
      /**
       * @description The priority of the grant. Grants with higher priority are applied first.
       * Priority is a positive decimal numbers. With lower numbers indicating higher importance.
       * For example, a priority of 1 is more urgent than a priority of 2.
       * When there are several grants available for the same subject, the system selects the grant with the highest priority.
       * In cases where grants share the same priority level, the grant closest to its expiration will be used first.
       * In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
       *
       * @default 1
       * @example 1
       */
      priority?: number
      /**
       * Format: date-time
       * @description The effective time. Provided value will be ceiled to metering windowSize (minute).
       *
       * @example 2023-01-01T00:00:00Z
       */
      effectiveAt: string
      expiration: components['schemas']['ExpirationPeriod']
      /**
       * Format: double
       * @description The maximum amount of the grant that can be rolled over. Defaults to 0.
       *
       * - maxAmount = {original_amount} -> rollover original amount
       * - maxAmount = 0 -> no rollover
       * - maxAmount = 90 -> rollover 90 max
       *
       * If it's larger than 0 then the grant's balance will be the MAX(maxRollover, balance) + amount.
       *
       * @default 0
       * @example 100
       */
      maxRolloverAmount?: number
      /**
       * @example {
       *   "stripePaymentId": "pi_4OrAkhLvyihio9p51h9iiFnB"
       * }
       */
      metadata?: {
        [key: string]: string
      }
      recurrence?: components['schemas']['RecurringPeriod']
    }
    EntitlementGrant: components['schemas']['EntitlementGrantCreateInput'] &
      components['schemas']['SharedMetaFields'] & {
        /**
         * @description The unique entitlement ULID that the grant is associated with.
         *
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        entitlementId: string
        /**
         * Format: date-time
         * @description The next time the grant will recurr.
         *
         * @example 2023-01-01T00:00:00Z
         */
        nextRecurrence?: string
        /**
         * Format: date-time
         * @description The expiration date of the grant.
         *
         * @example 2023-01-01T00:00:00Z
         */
        expiresAt?: string
        /**
         * Format: date-time
         * @description The date and time the grant was voided (cannot be used after that).
         */
        voidedAt?: string
      }
    EntitlementValue: {
      /**
       * @description Whether the subject has access to the feature.
       * @example true
       */
      hasAccess: boolean
      /**
       * Format: double
       * @description The balance of a metered entitlement.
       * @example 100
       */
      balance?: number
      /**
       * Format: double
       * @description Total usage of the feature in the period. Includes overages.
       * @example 50
       */
      usage?: number
      /**
       * Format: double
       * @description The overage of a metered entitlement.
       * @example 0
       */
      overage?: number
      /**
       * @description The JSON parseable configuration value of a static entitlement.
       * @example {"key1": "value1"}
       */
      config?: string
    }
    /** @description Expiration period of a grant. */
    ExpirationPeriod: {
      /**
       * @description The expiration period duration like month.
       *
       * @enum {string}
       */
      duration: 'HOUR' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
      /**
       * @description The expiration period count like 12 months.
       *
       * @example 12
       */
      count: number
    }
    /**
     * @description A meter is a configuration that defines how to match and aggregate events.
     * @example {
     *   "slug": "tokens_total",
     *   "description": "AI token usage",
     *   "aggregation": "SUM",
     *   "windowSize": "MINUTE",
     *   "eventType": "prompt",
     *   "valueProperty": "$.tokens",
     *   "groupBy": {
     *     "model": "$.model",
     *     "type": "$.type"
     *   }
     * }
     */
    Meter: {
      /**
       * @description A unique identifier for the meter.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id?: string
      /**
       * @description A unique, human-readable identifier for the meter. Must consist only alphanumeric and underscore characters.
       * @example tokens_total
       */
      slug: string
      /**
       * @description A description of the meter.
       * @example AI Token Usage
       */
      description?: string | null
      aggregation: components['schemas']['MeterAggregation']
      windowSize: components['schemas']['WindowSize']
      /**
       * @description The event type to aggregate.
       * @example prompt
       */
      eventType: string
      /**
       * @description JSONPath expression to extract the value from the ingested event's data property.
       * The ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.
       * For UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.
       *
       * @example $.tokens
       */
      valueProperty?: string
      /**
       * @description Named JSONPath expressions to extract the group by values from the event data. Keys must be unique and consist only alphanumeric and underscore characters.
       * @example {
       *   "model": "$.model",
       *   "type": "$.type"
       * }
       */
      groupBy?: {
        [key: string]: string
      }
    }
    /**
     * @description The aggregation type to use for the meter.
     * @example SUM
     * @enum {string}
     */
    MeterAggregation: 'SUM' | 'COUNT' | 'UNIQUE_COUNT' | 'AVG' | 'MIN' | 'MAX'
    /**
     * @description Aggregation window size.
     * @example MINUTE
     * @enum {string}
     */
    WindowSize: 'MINUTE' | 'HOUR' | 'DAY'
    /**
     * @description The result of a meter query.
     * @example {
     *   "from": "2023-01-01T00:00:00Z",
     *   "to": "2023-01-02T00:00:00Z",
     *   "windowSize": "MINUTE",
     *   "data": [
     *     {
     *       "value": 12,
     *       "windowStart": "2023-01-01T00:00:00Z",
     *       "windowEnd": "2023-01-02T00:00:00Z",
     *       "subject": "customer-id",
     *       "groupBy": {
     *         "model": "gpt-4-turbo",
     *         "type": "prompt"
     *       }
     *     }
     *   ]
     * }
     */
    MeterQueryResult: {
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      from?: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      to?: string
      windowSize?: components['schemas']['WindowSize']
      /**
       * @example [
       *   {
       *     "value": 12,
       *     "windowStart": "2023-01-01T00:00:00Z",
       *     "windowEnd": "2023-01-02T00:00:00Z",
       *     "subject": "customer-id",
       *     "groupBy": {
       *       "model": "gpt-4-turbo",
       *       "type": "prompt"
       *     }
       *   }
       * ]
       */
      data: components['schemas']['MeterQueryRow'][]
    }
    /**
     * @description A row in the result of a meter query.
     * @example {
     *   "value": 12,
     *   "windowStart": "2023-01-01T00:00:00Z",
     *   "windowEnd": "2023-01-02T00:00:00Z",
     *   "subject": "customer-id",
     *   "groupBy": {
     *     "model": "gpt-4-turbo",
     *     "type": "prompt"
     *   }
     * }
     */
    MeterQueryRow: {
      /** @example 12 */
      value: number
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      windowStart: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      windowEnd: string
      /**
       * @description The subject of the meter value.
       * @example customer-id
       */
      subject?: string | null
      /**
       * @example {
       *   "model": "gpt-4-turbo",
       *   "type": "prompt"
       * }
       */
      groupBy?: {
        [key: string]: string
      } | null
    }
    /**
     * @description A consumer portal token.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "subject": "customer-id",
     *   "expiresAt": "2023-01-02T00:00:00Z",
     *   "expired": false,
     *   "createdAt": "2023-01-01T00:00:00Z",
     *   "token": "om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo",
     *   "allowedMeterSlugs": [
     *     "tokens_total"
     *   ]
     * }
     */
    PortalToken: {
      /** @example 01G65Z755AFWAKHE12NY0CQ9FH */
      id?: string
      /** @example customer-id */
      subject: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      expiresAt?: string
      expired?: boolean
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      createdAt?: string
      /**
       * @description The token is only returned at creation.
       * @example om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo
       */
      token?: string
      /**
       * @description Optional, if defined only the specified meters will be allowed
       * @example [
       *   "tokens_total"
       * ]
       */
      allowedMeterSlugs?: string[]
    }
    /**
     * @description A subject is a unique identifier for a user or entity.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "key": "customer-id",
     *   "displayName": "Customer Name",
     *   "metadata": {
     *     "hubspotId": "123456"
     *   },
     *   "currentPeriodStart": "2023-01-01T00:00:00Z",
     *   "currentPeriodEnd": "2023-02-01T00:00:00Z",
     *   "stripeCustomerId": "cus_JMOlctsKV8"
     * }
     */
    Subject: {
      /** @example 01G65Z755AFWAKHE12NY0CQ9FH */
      id?: string
      /** @example customer-id */
      key: string
      /** @example Customer Name */
      displayName?: string | null
      /**
       * @example {
       *   "hubspotId": "123456"
       * }
       */
      metadata?: {
        [key: string]: unknown
      } | null
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      currentPeriodStart?: string | null
      /**
       * Format: date-time
       * @example 2023-02-01T00:00:00Z
       */
      currentPeriodEnd?: string | null
      /** @example cus_JMOlctsKV8 */
      stripeCustomerId?: string | null
    }
    /**
     * @description A unique identifier.
     * @example tokens_total
     */
    IdOrSlug: string
  }
  responses: {
    /** @description Ledger Exists */
    ConflictProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['ConflictProblem']
      }
    }
    /** @description Bad Request */
    BadRequestProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Unauthorized */
    UnauthorizedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Not Found */
    NotFoundProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Not Implemented */
    NotImplementedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Unexpected error */
    UnexpectedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
  }
  parameters: {
    /** @description A unique identifier for the meter. */
    meterIdOrSlug: components['schemas']['IdOrSlug']
    /** @description A unique identifier for a subject. */
    subjectIdOrKey: string
    /** @description A unique ULID identifier for a feature. */
    featureId: string
    /** @description A unique identifier for a grant. */
    grantId: string
    /** @description A unique ULID for an entitlement. */
    entitlementId: string
    /** @description The id of the entitlement or the key of the feature. */
    entitlementIdOrFeatureKey: string
    /** @description Include deleted entries. */
    includeDeleted?: boolean
    /** @description Number of entries to return */
    queryLimit?: number
    /** @description Number of entries to skip */
    queryOffset?: number
    /**
     * @description Start date-time in RFC 3339 format.
     * Inclusive.
     */
    queryFrom?: string
    /**
     * @description End date-time in RFC 3339 format.
     * Inclusive.
     */
    queryTo?: string
    /** @description If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group. */
    queryWindowSize?: components['schemas']['WindowSize']
    /**
     * @description The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
     * If not specified, the UTC timezone will be used.
     */
    queryWindowTimeZone?: string
    /**
     * @description Filtering by multiple subjects.
     *
     * Usage: ?subject=customer-1&subject=customer-2
     */
    queryFilterSubject?: string[]
    queryFilterGroupBy?: {
      [key: string]: string
    }
    /**
     * @description If not specified a single aggregate will be returned for each subject and time window.
     * `subject` is a reserved group by value.
     */
    queryGroupBy?: string[]
  }
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /**
   * List ingested events
   * @description List ingested events within a time range.
   */
  listEvents: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        /** @description Number of events to return */
        limit?: number
      }
    }
    responses: {
      /** @description List of events for debugging. */
      200: {
        content: {
          'application/json': components['schemas']['IngestedEvent'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Ingest events
   * @description Ingests an event or batch of events following the CloudEvents specification.
   */
  ingestEvents: {
    /**
     * @description The event or batch of events to ingest.
     * The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
     * The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
     */
    requestBody: {
      content: {
        'application/cloudevents+json': components['schemas']['Event']
        'application/cloudevents-batch+json': components['schemas']['Event'][]
      }
    }
    responses: {
      /** @description Successfully ingested. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List meters
   * @description List meters.
   */
  listMeters: {
    responses: {
      /** @description List of meters. */
      200: {
        content: {
          'application/json': components['schemas']['Meter'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Create meter
   * @description *Available in OpenMeter Cloud.*
   * *In the open-source version, meters are created in the configuration file.*
   *
   * Create a meter.
   */
  createMeter: {
    /** @description The meter to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['Meter']
      }
    }
    responses: {
      /** @description Created. */
      201: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get meter
   * @description Get meter by ID or slug
   */
  getMeter: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Meter found. */
      200: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Delete meter
   * @description *Available in OpenMeter Cloud.*
   *
   * Delete a meter by ID or slug.
   */
  deleteMeter: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Meter deleted. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Query meter
   * @description Query meter for usage.
   */
  queryMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        windowSize?: components['parameters']['queryWindowSize']
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
        subject?: components['parameters']['queryFilterSubject']
        filterGroupBy?: components['parameters']['queryFilterGroupBy']
        groupBy?: components['parameters']['queryGroupBy']
      }
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Usage data. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List meter subjects
   * @description List subjects for a meter.
   */
  listMeterSubjects: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description List of subjects. */
      200: {
        content: {
          'application/json': string[]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ List portal tokens
   * @description *Available in OpenMeter Cloud.*
   *
   * List consumer portal tokens.
   */
  listPortalTokens: {
    parameters: {
      query?: {
        /** @description Number of portal tokens to return. Default is 25. */
        limit?: number
      }
    }
    responses: {
      /** @description List of portal tokens. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create portal token
   * @description Create a consumer portal token.
   */
  createPortalToken: {
    /** @description The portal token to create. */
    requestBody: {
      content: {
        /**
         * @example {
         *   "subject": "customer-id",
         *   "allowedMeterSlugs": [
         *     "tokens_total"
         *   ]
         * }
         */
        'application/json': components['schemas']['PortalToken']
      }
    }
    responses: {
      /** @description Created. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Invalidate portal tokens
   * @description *Available in OpenMeter Cloud.*
   *
   * Invalidates consumer portal tokens by ID or subject.
   */
  invalidatePortalTokens: {
    /** @description If no id or subject is specified, all tokens will be invalidated. */
    requestBody: {
      content: {
        'application/json': {
          /** @description Invalidate a portal token by ID. */
          id?: string
          /** @description Invalidate all portal tokens for a subject. */
          subject?: string
        }
      }
    }
    responses: {
      /** @description Portal tokens invalidated. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ List subjects
   * @description *Available in OpenMeter Cloud.*
   *
   * List subjects.
   */
  listSubjects: {
    responses: {
      /** @description List of subjects. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Upsert subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Upserts a subject. Creates or updates subject.
   * If the subject doesn't exist, it will be created.
   * If the subject exists, it will be partially updated with the provided fields.
   */
  upsertSubject: {
    /** @description The subject to upsert. */
    requestBody: {
      content: {
        'application/json': components['schemas']['Subject'][]
      }
    }
    responses: {
      /** @description Subject upserted. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Get subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Get subject by ID or key.
   */
  getSubject: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description Subject found. */
      200: {
        content: {
          'application/json': components['schemas']['Subject']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Delete subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Delete a subject by ID or key.
   */
  deleteSubject: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description Subject deleted. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Query portal meter
   * @description Query meter for consumer portal. This endpoint is publicly exposable to consumers.
   */
  queryPortalMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        windowSize?: components['parameters']['queryWindowSize']
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
        filterGroupBy?: components['parameters']['queryFilterGroupBy']
        groupBy?: components['parameters']['queryGroupBy']
      }
      path: {
        /** @description A unique identifier for the meter. */
        meterSlug: string
      }
    }
    responses: {
      /** @description Usage data. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List entitlements
   * @description List entitlements.
   */
  listEntitlements: {
    parameters: {
      query?: {
        limit?: components['parameters']['queryLimit']
        offset?: components['parameters']['queryOffset']
        /** @description Order by field */
        orderBy?: 'createdAt' | 'updatedAt'
      }
    }
    responses: {
      /** @description List of entitlements. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List features
   * @description List features.
   */
  listFeatures: {
    parameters: {
      query?: {
        limit?: components['parameters']['queryLimit']
        offset?: components['parameters']['queryOffset']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt' | 'updatedAt'
        /** @description Include archived features. */
        includeArchived?: boolean
      }
    }
    responses: {
      /** @description List of features. */
      200: {
        content: {
          'application/json': components['schemas']['Feature'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create feature
   * @description Creates a feature.
   */
  createFeature: {
    /** @description The feature to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['FeatureCreateInputs']
      }
    }
    responses: {
      /** @description Feature created. */
      201: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get feature
   * @description Get feature by id.
   */
  getFeature: {
    parameters: {
      path: {
        featureId: components['parameters']['featureId']
      }
    }
    responses: {
      /** @description Feature found. */
      200: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Delete feature
   * @description Delete a feature by key.
   */
  deleteFeature: {
    parameters: {
      path: {
        featureId: components['parameters']['featureId']
      }
    }
    responses: {
      /** @description Feature deleted. */
      204: {
        content: never
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List grants
   * @description List all grants.
   */
  listGrants: {
    parameters: {
      query?: {
        limit?: components['parameters']['queryLimit']
        offset?: components['parameters']['queryOffset']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt' | 'updatedAt'
        includeDeleted?: components['parameters']['includeDeleted']
      }
    }
    responses: {
      /** @description List of grants. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementGrant'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Delete a grant
   * @description Void (delete) a grant. A grant can only be deleted if it hasn't been used.
   */
  voidGrant: {
    parameters: {
      path: {
        grantId: components['parameters']['grantId']
      }
    }
    responses: {
      /** @description Grant has been voided. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      409: components['responses']['ConflictProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List entitlements
   * @description List all entitlements for a subject.
   */
  listSubjectEntitlements: {
    parameters: {
      query?: {
        includeDeleted?: components['parameters']['includeDeleted']
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description List of entitlements. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create entitlement
   * @description Create an entitlement for a subject.
   */
  createEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    /** @description The entitlement to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementCreateInputs']
      }
    }
    responses: {
      /** @description Entitlement created. */
      201: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      409: components['responses']['ConflictProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get entitlement
   * @description Get entitlement by id.
   */
  getEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description Entitlement found. */
      200: {
        content: {
          'application/json': {
            type: 'json'
          } & Omit<components['schemas']['Entitlement'], 'type'> & {
              /**
               * Format: date-time
               * @description The last time usage was reset.
               * @example 2023-01-01T00:00:00Z
               */
              lastReset?: string
            }
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Delete entitlement
   * @description Delete an entitlement by id.
   */
  deleteEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description Entitlement deleted. */
      204: {
        content: never
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List grants for an entitlement
   * @description List all grants for an entitlement.
   */
  listEntitlementGrants: {
    parameters: {
      query?: {
        includeDeleted?: components['parameters']['includeDeleted']
        /** @description Order by field */
        orderBy?: 'id' | 'createdAt' | 'updatedAt'
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description List of grants. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementGrant'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create grant
   * @description Create a grant for an entitlement.
   */
  createGrant: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    /** @description The grant to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementGrantCreateInput']
      }
    }
    responses: {
      /** @description Grant created. */
      201: {
        content: {
          'application/json': components['schemas']['EntitlementGrant']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get the balance of a specific entitlement.
   * @description Get the balance of a specific entitlement.
   */
  getEntitlementValue: {
    parameters: {
      query?: {
        /** @description Point of time to check value: date-time in RFC 3339 format. Defaults to now. */
        time?: string
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementIdOrFeatureKey: components['parameters']['entitlementIdOrFeatureKey']
      }
    }
    responses: {
      /** @description The entitlement value. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementValue']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get the balance history of a specific entitlement.
   * @description Get the balance history of a specific entitlement.
   *
   * The windows are inclusive at their start and exclusive at their end.
   * The last window may be smaller than the window size and is inclusive at both ends.
   */
  getEntitlementHistory: {
    parameters: {
      query: {
        /**
         * @description Start of time range to query entitlement: date-time in RFC 3339 format.
         * Gets truncated to the granularity of the underlying meter.
         */
        from: string
        /**
         * @description End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.
         * If not now then gets truncated to the granularity of the underlying meter.
         */
        to?: string
        /** @description Size of the time window to group the history by. Cannot be shorter than meter granularity. */
        windowSize: 'MINUTE' | 'HOUR' | 'DAY'
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
      }
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    responses: {
      /** @description Entitlement balance history. If windowsize is specified then the history is grouped by the window size. */
      200: {
        content: {
          'application/json': components['schemas']['WindowedBalanceHistory']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Reset entitlement
   * @description Reset the entitlement usage and start a new period. Grants that can be are rolled over.
   */
  resetEntitlementUsage: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
        entitlementId: components['parameters']['entitlementId']
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * Format: date-time
           * @description The time at which the reset takes effect, defaults to now.
           * The reset cannot be in the future.
           * The provided value is truncated to the granularity of the underlying meter.
           *
           * @example 2023-01-01T00:00:00Z
           */
          effectiveAt?: string
        }
      }
    }
    responses: {
      /** @description Entitlement reset. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
}
