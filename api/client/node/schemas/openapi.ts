/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] }

export interface paths {
  '/api/v1/apps': {
    /** @description List apps. */
    get: operations['listApps']
  }
  '/api/v1/apps/{id}': {
    /** @description Get the app. */
    get: operations['getApp']
    /** @description Uninstall an app. */
    delete: operations['uninstallApp']
  }
  '/api/v1/apps/{id}/stripe/webhook': {
    /** @description Stripe webhook. */
    post: operations['appStripeWebhook']
  }
  '/api/v1/billing/customer': {
    /**
     * List customer overrides
     * @description List customer overrides
     */
    get: operations['billingListCustomerOverrides']
  }
  '/api/v1/billing/customer/{customerId}': {
    /**
     * Get a customer override
     * @description Get a customer override by id.
     */
    get: operations['billingGetCustomerOverrideById']
    /**
     * Create/update a customer override
     * @description Create/update a new customer override.
     */
    post: operations['billingUpsertCustomerOverride']
    /**
     * Delete a customer override
     * @description Delete a customer override by id.
     */
    delete: operations['billingDeleteCustomerOverride']
  }
  '/api/v1/billing/invoices': {
    /**
     * List invoices
     * @description List invoices
     */
    get: operations['billingListInvoices']
  }
  '/api/v1/billing/invoices/{customerId}': {
    /**
     * List invoices
     * @description List invoices for a specific customer
     */
    get: operations['billingListInvoicesByCustomer']
    /**
     * Create an invoice
     * @description Create a new invoice from the pending line items.
     *
     * This should be only called if for some reason we need to invoice a customer outside of the normal billing cycle.
     *
     * When creating an invoice, the pending line items will be marked as invoiced and the invoice will be created with the total amount of the pending items.
     *
     * New pending line items will be created for the period between now() and the next billing cycle's begining date for any metered item.
     *
     * The call can return multiple invoices if the pending line items are in different currencies.
     */
    post: operations['billingCreateInvoice']
  }
  '/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}': {
    /**
     * Get an invoice
     * @description Get an invoice by ID.
     */
    get: operations['billingGetInvoiceByCustomerInvoiceId']
    /**
     * Delete an invoice
     * @description Delete an invoice
     *
     * Only invoices that are in the draft (or earlier) status can be deleted.
     */
    delete: operations['billingDeleteInvoiceByCustomerInvoiceId']
  }
  '/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/advance': {
    /**
     * Advance the invoice's state to the next status
     * @description Advance the invoice's state to the next status.
     *
     * The call doesn't "approve the invoice", it only advances the invoice to the next status if the transition would be automatic.
     *
     * The action can be called when the invoice's statusDetails' actions field contain the "advance" action.
     */
    post: operations['billingInvoiceAdvance']
  }
  '/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/approve': {
    /**
     * Send the invoice to the customer
     * @description Approve an invoice and start executing the payment workflow.
     *
     * This call instantly sends the invoice to the customer using the configured billing profile app.
     *
     * This call is valid in two invoice statuses:
     * - `draft`: the invoice will be sent to the customer, the invluce state becomes issued
     * - `manual_approval_needed`: the invoice will be sent to the customer, the invoice state becomes issued
     */
    post: operations['billingApproveInvoice']
  }
  '/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/lines/{lineId}': {
    /**
     * Update an invoice line
     * @description Update an invoice line
     */
    put: operations['billingUpdateInvoiceLine']
    /**
     * Delete an invoice line
     * @description Delete an invoice line
     */
    delete: operations['billingDeleteInvoiceLine']
  }
  '/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/retry': {
    /**
     * Retry advancing the invoice after a failed attempt.
     * @description Retry advancing the invoice after a failed attempt.
     *
     * The action can be called when the invoice's statusDetails' actions field contain the "retry" action.
     */
    post: operations['billingInvoiceRetry']
  }
  '/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/tax/recalculate': {
    /**
     * Recalculate an invoice's tax amounts
     * @description Recalculate an invoice's tax amounts (using the app set in the customer's billing profile)
     *
     * Note: charges might apply, depending on the tax provider.
     */
    post: operations['billingRecalculateInvoiceTax']
  }
  '/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/void': {
    /**
     * Void an invoice
     * @description Void an invoice
     *
     * Only invoices that have been alread issued can be voided.
     *
     * Voiding an invoice will mark it as voided, the user can specify how to handle the voided line items.
     */
    post: operations['billingVoidInvoice']
  }
  '/api/v1/billing/invoices/{customerId}/lines': {
    /**
     * Create line items
     * @description Create a new pending line item (charge).
     *
     * This call is used to create a new pending line item for the customer without explicitly
     * assigning it to an invoice.
     *
     * The line item will be either allocated to an existing invoice in gathering state or a new invoice is
     * created for the line item.
     *
     * A new invoice will be created if:
     * - there is no invoice in gathering state
     * - the currency of the line item doesn't match the currency of any invoices in gathering state
     */
    post: operations['billingCreateLineByCustomer']
  }
  '/api/v1/billing/profile': {
    /** @description List all billing profiles */
    get: operations['billingListProfiles']
    /**
     * Create a new billing profile
     * @description Create a new billing profile
     *
     * Billing profiles are representations of a customer's billing information. Customer overrides
     * can be applied to a billing profile to customize the billing behavior for a specific customer.
     */
    post: operations['billingCreateProfile']
  }
  '/api/v1/billing/profile/{id}': {
    /**
     * Get a billing profile by ID
     * @description Get a billing profile by ID
     */
    get: operations['billingGetProfile']
    /**
     * Update a billing profile
     * @description Update a billing profile
     */
    put: operations['billingUpdateProfile']
    /**
     * Archive a billing profile
     * @description Archive a billing profile
     */
    delete: operations['billingArchiveProfile']
  }
  '/api/v1/customers': {
    /** @description List customers. */
    get: operations['listCustomers']
    /** @description Create a new customer. */
    post: operations['createCustomer']
  }
  '/api/v1/customers/{id}': {
    /** @description Get a customer by ID. */
    get: operations['getCustomer']
    /** @description Update a customer by ID. */
    put: operations['updateCustomer']
    /** @description Delete a customer by ID. */
    delete: operations['deleteCustomer']
  }
  '/api/v1/debug/metrics': {
    /**
     * Get event metrics
     * @description Returns debug metrics (in OpenMetrics format) like the number of ingested events since mindnight UTC.
     *
     * The OpenMetrics Counter(s) reset every day at midnight UTC.
     */
    get: operations['getDebugMetrics']
  }
  '/api/v1/entitlements': {
    /**
     * List all entitlements
     * @description List all entitlements for all the subjects and features. This endpoint is intended for administrative purposes only.
     * To fetch the entitlements of a specific subject please use the /api/v1/subjects/{subjectKeyOrID}/entitlements endpoint.
     * If page is provided that takes precedence and the paginated response is returned.
     */
    get: operations['listEntitlements']
  }
  '/api/v1/entitlements/{entitlementId}': {
    /** @description Get entitlement by id. */
    get: operations['getEntitlementById']
  }
  '/api/v1/events': {
    /**
     * List ingested events
     * @description List ingested events within a time range.
     *
     * If the from query param is not provided it defaults to last 72 hours.
     */
    get: operations['listEvents']
    /** @description Ingests an event or batch of events following the CloudEvents specification. */
    post: operations['ingestEvents']
  }
  '/api/v1/features': {
    /** @description List features. */
    get: operations['listFeatures']
    /**
     * @description Features are either metered or static. A feature is metered if meterSlug is provided at creation.
     * For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter's groupBy fields.
     * Only meters with SUM and COUNT aggregation are supported for features.
     * Features cannot be updated later, only archived.
     */
    post: operations['createFeature']
  }
  '/api/v1/features/{featureId}': {
    /** @description Get a feature by ID. */
    get: operations['getFeature']
    /**
     * @description Archive a feature by ID.
     *
     * Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements.
     * This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis.
     */
    delete: operations['deleteFeature']
  }
  '/api/v1/grants': {
    /**
     * @description List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only.
     * To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.
     * If page is provided that takes precedence and the paginated response is returned.
     */
    get: operations['listGrants']
  }
  '/api/v1/grants/{grantId}': {
    /**
     * @description Voiding a grant means it is no longer valid, it doesn't take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.
     * For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected.
     */
    delete: operations['voidGrant']
  }
  '/api/v1/integration/stripe/checkout/sessions': {
    /** @description Create checkout session. */
    post: operations['createStripeCheckoutSession']
  }
  '/api/v1/marketplace/listings': {
    /** @description List available apps of the app marketplace. */
    get: operations['listMarketplaceListings']
  }
  '/api/v1/marketplace/listings/{type}': {
    /** @description Get a marketplace listing by type. */
    get: operations['getMarketplaceListing']
  }
  '/api/v1/marketplace/listings/{type}/install/apikey': {
    /** @description Install an marketplace via API Key. */
    post: operations['marketplaceAppAPIKeyInstall']
  }
  '/api/v1/marketplace/listings/{type}/install/oauth2': {
    /**
     * @description Install an app via OAuth.
     * Returns a URL to start the OAuth 2.0 flow.
     */
    get: operations['marketplaceOAuth2InstallGetURL']
  }
  '/api/v1/marketplace/listings/{type}/install/oauth2/authorize': {
    /**
     * @description Authorize OAuth2 code.
     * Verifies the OAuth code and exchanges it for a token and refresh token
     */
    get: operations['marketplaceOAuth2InstallAuthorize']
  }
  '/api/v1/meters': {
    /** @description List meters. */
    get: operations['listMeters']
    /** @description Create a meter. */
    post: operations['createMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}': {
    /** @description Get a meter by ID or slug. */
    get: operations['getMeter']
    /** @description Delete a meter. */
    delete: operations['deleteMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/query': {
    /** @description Query meter for usage. Query meter for usage. */
    get: operations['queryMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/subjects': {
    /** @description List subjects for a meter. */
    get: operations['listMeterSubjects']
  }
  '/api/v1/notification/channels': {
    /**
     * List notification channels
     * @description List all notification channels.
     */
    get: operations['listNotificationChannels']
    /**
     * Create a notification channel
     * @description Create a new notification channel.
     */
    post: operations['createNotificationChannel']
  }
  '/api/v1/notification/channels/{channelId}': {
    /**
     * Get notification channel
     * @description Get a notification channel by id.
     */
    get: operations['getNotificationChannel']
    /**
     * Update a notification channel
     * @description Update notification channel.
     */
    put: operations['updateNotificationChannel']
    /**
     * Delete a notification channel
     * @description Soft delete notification channel by id.
     *
     * Once a notification channel is deleted it cannot be undeleted.
     */
    delete: operations['deleteNotificationChannel']
  }
  '/api/v1/notification/events': {
    /**
     * List notification events
     * @description List all notification events.
     */
    get: operations['listNotificationEvents']
  }
  '/api/v1/notification/events/{eventId}': {
    /**
     * Get notification event
     * @description Get a notification event by id.
     */
    get: operations['getNotificationEvent']
  }
  '/api/v1/notification/rules': {
    /**
     * List notification rules
     * @description List all notification rules.
     */
    get: operations['listNotificationRules']
    /**
     * Create a notification rule
     * @description Create a new notification rule.
     */
    post: operations['createNotificationRule']
  }
  '/api/v1/notification/rules/{ruleId}': {
    /**
     * Get notification rule
     * @description Get a notification rule by id.
     */
    get: operations['getNotificationRule']
    /**
     * Update a notification rule
     * @description Update notification rule.
     */
    put: operations['updateNotificationRule']
    /**
     * Delete a notification rule
     * @description Soft delete notification rule by id.
     *
     * Once a notification rule is deleted it cannot be undeleted.
     */
    delete: operations['deleteNotificationRule']
  }
  '/api/v1/notification/rules/{ruleId}/test': {
    /** @description Test a notification rule by sending a test event with random data. */
    post: operations['testNotificationRule']
  }
  '/api/v1/notification/webhook/svix': {
    /**
     * Receive Svix operational events
     * @description Callback endpoint used by Svix to notify about operational events.
     */
    post: operations['receiveSvixOperationalEvent']
  }
  '/api/v1/plans': {
    /**
     * List plans
     * @description List all plans.
     */
    get: operations['listPlans']
    /**
     * Create a plan
     * @description Create a new plan.
     */
    post: operations['createPlan']
  }
  '/api/v1/plans/{planIdOrKey}/next': {
    /**
     * New draft plan
     * @description Create a new draft version from plan.
     * It returns error if there is already a plan in draft or planId does not reference the latest published version.
     */
    post: operations['nextPlan']
  }
  '/api/v1/plans/{planId}': {
    /**
     * Get plan
     * @description Get a plan by id or key. The latest published version is returned if latter is used.
     */
    get: operations['getPlan']
    /**
     * Update a plan
     * @description Update plan by id.
     */
    put: operations['updatePlan']
    /**
     * Delete plan
     * @description Soft delete plan by plan.id.
     *
     * Once a plan is deleted it cannot be undeleted.
     */
    delete: operations['deletePlan']
  }
  '/api/v1/plans/{planId}/archive': {
    /**
     * Archive plan version
     * @description Archive a plan version.
     */
    post: operations['archivePlan']
  }
  '/api/v1/plans/{planId}/phases': {
    /**
     * List phases in plan
     * @description List all phases in plan.
     */
    get: operations['listPlanPhases']
    /**
     * Create new phase in plan
     * @description Create new phase in plan.
     */
    post: operations['createPlanPhase']
  }
  '/api/v1/plans/{planId}/phases/{planPhaseKey}': {
    /**
     * Get phase for plan
     * @description Get phase in plan.
     */
    get: operations['getPlanPhase']
    /**
     * Update phase in plan
     * @description Update phase in plan.
     */
    put: operations['updatePlanPhase']
    /**
     * Delete phase for plan
     * @description Delete phase in plan.
     *
     * Once a phase is deleted it cannot be undeleted.
     */
    delete: operations['deletePlanPhase']
  }
  '/api/v1/plans/{planId}/publish': {
    /**
     * Publish plan
     * @description Publish a plan version.
     */
    post: operations['publishPlan']
  }
  '/api/v1/portal/meters/{meterSlug}/query': {
    /** @description Query meter for consumer portal. This endpoint is publicly exposable to consumers. Query meter for consumer portal. This endpoint is publicly exposable to consumers. */
    get: operations['queryPortalMeter']
  }
  '/api/v1/portal/tokens': {
    /** @description List tokens. */
    get: operations['listPortalTokens']
    /** @description Create a consumer portal token. */
    post: operations['createPortalToken']
  }
  '/api/v1/portal/tokens/invalidate': {
    /** @description Invalidates consumer portal tokens by ID or subject. */
    post: operations['invalidatePortalTokens']
  }
  '/api/v1/subjects': {
    /** @description List subjects. */
    get: operations['listSubjects']
    /**
     * @description Upserts a subject. Creates or updates subject.
     *
     * If the subject doesn't exist, it will be created.
     * If the subject exists, it will be partially updated with the provided fields.
     */
    post: operations['upsertSubject']
  }
  '/api/v1/subjects/{subjectIdOrKey}': {
    /** @description Get subject by ID or key. */
    get: operations['getSubject']
    /** @description Delete subject by ID or key. */
    delete: operations['deleteSubject']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements': {
    /** @description List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead. */
    get: operations['listSubjectEntitlements']
    /**
     * Create an entitlement
     * @description OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).
     *
     * - Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
     * - Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
     * - Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.
     *
     * A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.
     *
     * Once an entitlement is created you cannot modify it, only delete it.
     */
    post: operations['createEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants': {
    /** @description List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey. */
    get: operations['listEntitlementGrants']
    /**
     * @description Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.
     *
     * A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.
     *
     * Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.
     *
     * Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).
     *
     * Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
     *
     * Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.
     */
    post: operations['createGrant']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override': {
    /**
     * @description Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided subject-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.
     *
     * This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime.
     */
    put: operations['overrideEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value': {
    /**
     * @description This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
     *
     * For convenience reasons, /value works with both entitlementId and featureKey.
     */
    get: operations['getEntitlementValue']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}': {
    /** @description Get entitlement by id. For checking entitlement access, use the /value endpoint instead. */
    get: operations['getEntitlement']
    /**
     * @description Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
     * As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.
     */
    delete: operations['deleteEntitlement']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history': {
    /**
     * @description Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.
     *
     * BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.
     *
     * WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.
     */
    get: operations['getEntitlementHistory']
  }
  '/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset': {
    /**
     * @description Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.
     *
     * Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.
     */
    post: operations['resetEntitlementUsage']
  }
  '/api/v1/subscriptions': {
    post: operations['Subscriptions_create']
  }
  '/api/v1/subscriptions/{subscriptionId}': {
    get: operations['getSubscription']
    /**
     * @description Batch processing commands for manipulating running subscriptions.
     * The key format is `/phases/{phaseKey}` or `/phases/{phaseKey}/items/{itemKey}`.
     *
     * Add operations insert a new member based on the creation input without altering the existing members.
     *
     * Remove operations remove the member from the collection / document.
     *
     * The extend operation extends the specific phase if possible, while delaying all subsequent phases by the same amount.
     */
    patch: operations['editSubscription']
  }
  '/api/v1/subscriptions/{subscriptionId}/cancel': {
    /** @description Cancels the subscription. */
    post: operations['cancelSubscription']
  }
  '/api/v1/subscriptions/{subscriptionId}/migrate': {
    /** @description Migrates the subscripiton to the procided version of the plan. */
    post: operations['migrateSubscription']
  }
  '/api/v1/subscriptions/{subscriptionId}/unschedule-cancelation': {
    /** @description Cancels the scheduled cancelation. */
    post: operations['unscheduleCancelation']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    /** @description Address */
    Address: {
      country?: components['schemas']['CountryCode']
      postalCode?: string
      state?: string
      city?: string
      line1?: string
      line2?: string
      phoneNumber?: string
    }
    /**
     * @description Set of key-value pairs managed by the system. Cannot be modified by user.
     * @example {
     *   "externalId": "019142cc-a016-796a-8113-1a942fecd26d"
     * }
     */
    Annotations: {
      [key: string]: unknown
    }
    /**
     * @description App.
     * One of: stripe
     */
    App:
      | components['schemas']['StripeApp']
      | components['schemas']['SandboxApp']
    /**
     * @description Abstract base model for installed apps.
     *
     * Represent an app installed to the organization.
     * This is an actual instance, with its own configuration and credentials.
     */
    AppBase: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description The marketplace listing that this installed app is based on. */
      listing: components['schemas']['MarketplaceListing']
      /** @description Status of the app connection. */
      status: components['schemas']['AppStatus']
    }
    /**
     * @description App capability.
     *
     * Capabilities only exist in config so they don't extend the Resource model.
     * @example {
     *   "type": "collectPayments",
     *   "key": "stripe_collect_payment",
     *   "name": "Collect Payments",
     *   "description": "Stripe payments collects outstanding revenue with Stripe customer's default payment method."
     * }
     */
    AppCapability: {
      /** @description The capability type. */
      type: components['schemas']['AppCapabilityType']
      /** @description Key */
      key: string
      /** @description The capability name. */
      name: string
      /** @description The capability description. */
      description: string
    }
    /**
     * @description App capability type.
     * @enum {string}
     */
    AppCapabilityType:
      | 'reportUsage'
      | 'reportEvents'
      | 'calculateTax'
      | 'invoiceCustomers'
      | 'collectPayments'
    /** @description A page of results. */
    AppList: {
      /** @description The page number. */
      page: number
      /** @description The number of items in the page. */
      pageSize: number
      /** @description The total number of items. */
      totalCount: number
      /** @description The items in the page. */
      items: components['schemas']['App'][]
    }
    /**
     * @description App reference
     *
     * Can be used as a short reference to an app if the full app object is not needed.
     */
    AppReference: {
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
    }
    /**
     * @description App installed status.
     * @enum {string}
     */
    AppStatus: 'ready' | 'unauthorized'
    /**
     * @description Type of the app.
     * @enum {string}
     */
    AppType: 'stripe' | 'sandbox'
    /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
    BadRequestProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /** @description The balance history window. */
    BalanceHistoryWindow: {
      period: components['schemas']['Period']
      /**
       * Format: double
       * @description The total usage of the feature in the period.
       * @example 100
       */
      usage: number
      /**
       * Format: double
       * @description The entitlement balance at the start of the period.
       * @example 100
       */
      balanceAtStart: number
    }
    /** @description Response for creating a pending charge */
    BillingCreateLineResult: {
      /** The created line items */
      lines: components['schemas']['BillingInvoiceLine'][]
    }
    /** @description CreateLinesRequest is the request for creating manual line items. */
    BillingCreateLinesRequest: {
      /** The line to create */
      lines: components['schemas']['BillingInvoiceLineCreateItem'][]
    }
    /** @description CreditNoteOriginalInvoiceRef is used to reference the original invoice that a credit note is based on. */
    BillingCreditNoteOriginalInvoiceRef: WithRequired<
      {
        /** @enum {string} */
        type: 'credit_node_original_invoice'
        /**
         * IssueAt reflects the time the document was issued.
         * Format: date-time
         * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
         * @example "2023-01-01T01:01:01.001Z"
         */
        issuedAt?: string
        /** (Serial) Number of the referenced document. */
        number?: components['schemas']['BillingInvoiceNumber']
        /**
         * Link to the source document.
         * Format: uri
         */
        url: string
      } & components['schemas']['BillingGenericDocumentRef'],
      'type' | 'url'
    >
    /** @description Customer specific workflow overrides. */
    BillingCustomerOverride: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      workflow: components['schemas']['BillingCustomerWorkflowOverride']
      /**
       * @description The billing profile this override is associated with.
       *
       * If not provided, the default billing profile is chosen if available.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      billingProfile?: string
    }
    /**
     * @description Order by options for customers.
     * @enum {string}
     */
    BillingCustomerOverrideOrderBy: 'id'
    /** @description Customer specific workflow overrides. */
    BillingCustomerWorkflowOverride: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** The collection settings for this workflow */
      collection?: components['schemas']['BillingWorkflowCollectionSettings']
      /** The invoicing settings for this workflow */
      invoicing?: components['schemas']['BillingWorkflowInvoicingSettings']
      /** The payment settings for this workflow */
      payment?: components['schemas']['BillingWorkflowPaymentSettings']
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      taxApp: components['schemas']['App']
      invoicingApp: components['schemas']['App']
      paymentApp: components['schemas']['App']
    }
    /** @description Customer specific workflow overrides. */
    BillingCustomerWorkflowOverrideCreate: {
      /** The collection settings for this workflow */
      collection?: components['schemas']['BillingWorkflowCollectionSettings']
      /** The invoicing settings for this workflow */
      invoicing?: components['schemas']['BillingWorkflowInvoicingSettings']
      /** The payment settings for this workflow */
      payment?: components['schemas']['BillingWorkflowPaymentSettings']
    }
    /** @description DocumentRef is used to describe a reference to an existing document (invoice). */
    BillingDocumentRef: components['schemas']['BillingCreditNoteOriginalInvoiceRef']
    /**
     * @description DocumentRefType defines the type of document that is being referenced.
     * @enum {string}
     */
    BillingDocumentRefType: 'credit_node_original_invoice'
    /** @description DueDate contains an amount that should be paid by the given date. */
    BillingDueDate: {
      /**
       * When the payment is due.
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      dueAt: string
      /** Other details to take into account for the due date. */
      notes?: string
      /** How much needs to be paid by the date. */
      amount: components['schemas']['Numeric']
      /** Percentage of the total that should be paid by the date. */
      percent?: components['schemas']['Percentage']
      /** If different from the parent document's base currency. */
      currency?: components['schemas']['CurrencyCode']
    }
    /** @description BillingFlatFeeLine represents a line item that is sold to the customer as a manually added fee. */
    BillingFlatFeeLine: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      status: components['schemas']['BillingLineStatus']
      /** Discounts applied to this line. */
      discounts?: components['schemas']['BillingLineDiscount'][]
      /** Charges applied to this line. */
      charges?: components['schemas']['BillingLineCharge'][]
      /** The invoice this item belongs to. */
      invoice?: components['schemas']['BillingInvoiceReference']
      /** The currency of this line */
      currency: components['schemas']['CurrencyCode']
      /** Map of taxes to be applied and used in the invoice totals. */
      taxes?: components['schemas']['BillingTaxItem'][]
      /** Tax config specify the tax configuration for this line. */
      taxConfig?: components['schemas']['TaxConfig'] | null
      /** Total sum of the line, including discounts and charges. */
      total: components['schemas']['Numeric']
      /** Period of the line item applies to for revenue recognition pruposes. */
      period: components['schemas']['BillingPeriod']
      /**
       * The time this line item should be invoiced.
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      invoiceAt: string
      /** @enum {string} */
      type: 'flat_fee'
      /** Price of the item being sold. */
      amount: components['schemas']['Numeric']
      /**
       * Payment term of the line.
       * @default in_advance
       */
      paymentTerm?: components['schemas']['PricePaymentTerm']
      /** Quantity of the item being sold. */
      quantity: components['schemas']['Numeric']
    }
    /** @description BillingFlatFeeLine represents a line item that is sold to the customer as a manually added fee. */
    BillingFlatFeeLineCreateItem: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /** Discounts applied to this line. */
      discounts?: components['schemas']['BillingLineDiscount'][]
      /** Charges applied to this line. */
      charges?: components['schemas']['BillingLineCharge'][]
      /** The invoice this item belongs to. */
      invoice?: components['schemas']['BillingInvoiceReference']
      /** The currency of this line */
      currency: components['schemas']['CurrencyCode']
      /** Tax config specify the tax configuration for this line. */
      taxConfig?: components['schemas']['TaxConfig'] | null
      /** Period of the line item applies to for revenue recognition pruposes. */
      period: components['schemas']['BillingPeriod']
      /**
       * The time this line item should be invoiced.
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      invoiceAt: string
      /** @enum {string} */
      type: 'flat_fee'
      /** Price of the item being sold. */
      amount: components['schemas']['Numeric']
      /**
       * Payment term of the line.
       * @default in_advance
       */
      paymentTerm?: components['schemas']['PricePaymentTerm']
      /** Quantity of the item being sold. */
      quantity: components['schemas']['Numeric']
    }
    /** @description BillingFlatFeeLine represents a line item that is sold to the customer as a manually added fee. */
    BillingFlatFeeLineCreateOrUpdate: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /** Discounts applied to this line. */
      discounts?: components['schemas']['BillingLineDiscount'][]
      /** Charges applied to this line. */
      charges?: components['schemas']['BillingLineCharge'][]
      /** The invoice this item belongs to. */
      invoice?: components['schemas']['BillingInvoiceReference']
      /** The currency of this line */
      currency: components['schemas']['CurrencyCode']
      /** Tax config specify the tax configuration for this line. */
      taxConfig?: components['schemas']['TaxConfig'] | null
      /** Period of the line item applies to for revenue recognition pruposes. */
      period: components['schemas']['BillingPeriod']
      /**
       * The time this line item should be invoiced.
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      invoiceAt: string
      /** @enum {string} */
      type: 'flat_fee'
      /** Price of the item being sold. */
      amount: components['schemas']['Numeric']
      /**
       * Payment term of the line.
       * @default in_advance
       */
      paymentTerm?: components['schemas']['PricePaymentTerm']
      /** Quantity of the item being sold. */
      quantity: components['schemas']['Numeric']
    }
    /**
     * DocumentRef is used to describe an existing document or a specific part of it's contents.
     * @description Omitted fields:
     * period: Tax period in which the referred document had an effect required by some tax regimes and formats.
     * stamps: Seals of approval from other organisations that may need to be listed.
     * ext: 	Extensions for additional codes that may be required.
     */
    BillingGenericDocumentRef: {
      /** Type of the document referenced. */
      type: components['schemas']['BillingDocumentRefType']
      /** Human readable description on why this reference is here or needs to be used. */
      reason?: string
      /** Additional details about the document. */
      description?: string
    }
    /** @description Invoice represents an invoice in the system. */
    BillingInvoice: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       *
       * For updates the updatedAt field is used to detect conflicts.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      type: components['schemas']['BillingInvoiceType']
      /** The taxable entity supplying the goods or services. */
      supplier: components['schemas']['BillingParty']
      /** Legal entity receiving the goods or services. */
      customer: components['schemas']['BillingParty']
      /**
       * (Serial) Number of the invoice
       * @description Number specifies the human readable key used to reference this Invoice.
       *
       * The number only gets populated after the invoice had been issued.
       *
       * Please note that the number is (depending on the upstream settings) either unique for the
       * whole organization or unique for the customer, or in multi (stripe) account setups unique for the
       * account.
       */
      number?: components['schemas']['BillingInvoiceNumber']
      /** Currency for all invoice totals. */
      currency: components['schemas']['CurrencyCode']
      /** Key information regarding previous invoices and potentially details as to why they were corrected. */
      preceding?: components['schemas']['BillingDocumentRef'][]
      /** Summary of all the invoice totals, including taxes (calculated). */
      totals: components['schemas']['BillingInvoiceTotals']
      /** The status of the invoice. */
      status: components['schemas']['BillingInvoiceStatus']
      /** The details of the current invoice status */
      statusDetails: components['schemas']['BillingInvoiceStatusDetails']
      /**
       * The time the invoice was issued.
       * Format: date-time
       * @description The time the invoice was issued.
       *
       * Depending on the status of the invoice this can mean multiple things:
       * - draft, gathering: The time the invoice will be issued based on the workflow settings.
       * - issued: The time the invoice was issued.
       * @example "2023-01-01T01:01:01.001Z"
       */
      issuedAt?: string
      /**
       * The time until the invoice is in draft status.
       * Format: date-time
       * @description The time until the invoice is in draft status.
       *
       * On draft invoice creation it is calculated from the workflow settings.
       *
       * If manual approval is required, the draftUntil time is set.
       * @example "2023-01-01T01:01:01.001Z"
       */
      draftUntil?: string
      /**
       * Due time of the fulfillment of the invoice.
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      dueAt?: string
      /** The period the invoice covers. If the invoice has no line items, it's not set. */
      period?: components['schemas']['BillingPeriod']
      /**
       * The time the invoice was voided.
       * Format: date-time
       * @description The time the invoice was voided.
       *
       * If the invoice was voided, this field will be set to the time the invoice was voided.
       * @example "2023-01-01T01:01:01.001Z"
       */
      voidedAt?: string
      /**
       * The workflow settings associated with this invoice
       * @description The workflow associated with the invoice.
       *
       * It is always a snapshot of the workflow settings at the time of invoice creation. The
       * field is optional as it should be explicitly requested with expand options.
       */
      workflow?: components['schemas']['BillingInvoiceWorkflowSettings']
      /** List of invoice lines representing each of the items sold to the customer. */
      lines?: components['schemas']['BillingInvoiceLine'][]
      /** Discounts or allowances applied to the complete invoice. */
      discounts?: components['schemas']['BillingInvoiceDiscount'][]
      /** Information on when, how, and to whom the invoice should be paid. */
      payment?: components['schemas']['BillingInvoicePayment']
      /** Validation issues reported by the invoice workflow. */
      validationIssues?: components['schemas']['BillingValidationIssue'][]
    }
    /**
     * @description BillingInvoiceAction represents the actions that can be performed on an invoice.
     * @enum {string}
     */
    BillingInvoiceAction: 'advance' | 'approve' | 'delete' | 'retry' | 'void'
    /**
     * @description BillingInvoiceCreateInput is the input for creating an invoice.
     *
     * Invoice creation is always based on already pending line items created by the billingCreateLineByCustomer
     * operation. Empty invoices are not allowed.
     */
    BillingInvoiceCreateInput: {
      /**
       * @description The pending line items to include in the invoice, if not provided:
       * - all line items that have invoice_at < asOf will be included
       * - all usage based line items will be included up to asOf, new usage-based line items will be staged for the rest
       * of the billing cycle
       */
      IncludePendingLines?: string[]
      /**
       * Format: date-time
       * @description The time as of which the invoice is created.
       *
       * If not provided, the current time is used.
       * @example "2023-01-01T01:01:01.001Z"
       */
      AsOf?: string
    }
    /** @description Discount represents an allowance applied to the complete document independent from the individual lines. */
    BillingInvoiceDiscount: {
      /** Base represents the value used as a base for percent calculations instead of the invoice's sum of lines. */
      base?: components['schemas']['Numeric']
      /** Percentage to apply to the base or invoice's sum. */
      percent?: components['schemas']['Percentage']
      /** Amount to apply (calculated if percent present). */
      amount: components['schemas']['Numeric']
      /** Text description as to why the discount was applied */
      reason?: string
    }
    /**
     * @description InvoiceExpand specifies the parts of the invoice to expand in the list output.
     * @enum {string}
     */
    BillingInvoiceExpand:
      | '*'
      | 'lines'
      | 'preceding'
      | 'workflow'
      | 'workflow.apps'
    /**
     * @description InvoiceExtendedStatus describes the extended status of an invoice.
     *
     * This is used to provide more detailed information about the status of the invoice. Useful for
     * troubelshooting invoice workflow issues.
     * @enum {string}
     */
    BillingInvoiceExtendedStatus:
      | 'gathering'
      | 'draft'
      | 'issuing'
      | 'issued'
      | 'draft_created'
      | 'draft_manual_approval_needed'
      | 'draft_validating'
      | 'draft_invalid'
      | 'draft_syncing'
      | 'draft_sync_failed'
      | 'draft_waiting_auto_approval'
      | 'draft_ready_to_issue'
      | 'issuing_syncing'
      | 'issuing_sync_failed'
    /** @description BillingInvoiceLine represents a line item that is sold to the customer based on a specific (unit) price. */
    BillingInvoiceLine:
      | components['schemas']['BillingUsageBasedLine']
      | components['schemas']['BillingFlatFeeLine']
    /** @description BillingInvoiceLine represents a line item that is sold to the customer based on a specific (unit) price. */
    BillingInvoiceLineCreateItem:
      | components['schemas']['BillingUsageBasedLineCreateItem']
      | components['schemas']['BillingFlatFeeLineCreateItem']
    /** @description BillingInvoiceLine represents a line item that is sold to the customer based on a specific (unit) price. */
    BillingInvoiceLineCreateOrUpdate:
      | components['schemas']['BillingUsageBasedLineCreateOrUpdate']
      | components['schemas']['BillingFlatFeeLineCreateOrUpdate']
    /**
     * @description InvoiceNumber is a unique identifier for the invoice, generated by the
     * invoicing app.
     *
     * The uniqueness depends on a lot of factors:
     * - app setting (unique per app or unique per customer)
     * - multiple app scenarios (multiple apps generating invoices with the same prefix)
     * @example INV-2024-01-01-01
     */
    BillingInvoiceNumber: string
    /**
     * @description InvoiceOrderBy specifies the ordering options for invoice listing.
     * @enum {string}
     */
    BillingInvoiceOrderBy:
      | 'customer.name'
      | 'issuedAt'
      | 'status'
      | 'createdAt'
      | 'updatedAt'
    /** @description Payment contains details as to how the invoice should be paid. */
    BillingInvoicePayment: {
      terms?: components['schemas']['BillingPaymentTerms']
    }
    /** @description Reference to an invoice. */
    BillingInvoiceReference: {
      /**
       * The ID of the invoice.
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /** The number of the invoice. */
      number?: components['schemas']['BillingInvoiceNumber']
    }
    /**
     * @description InvoiceStatus describes the status of an invoice.
     * @enum {string}
     */
    BillingInvoiceStatus: 'gathering' | 'draft' | 'issuing' | 'issued'
    /**
     * @description InvoiceStatusDetails represents the details of the invoice status.
     *
     * API users are encouraged to rely on the immutable/failed/avaliableActions fields to determine
     * the next steps of the invoice instead of the extendedStatus field.
     */
    BillingInvoiceStatusDetails: {
      /** Is the invoice editable? */
      immutable: boolean
      /** Is the invoice in a failed state? */
      failed: boolean
      /** Extended status information for the invoice. */
      extendedStatus: components['schemas']['BillingInvoiceExtendedStatus']
      /** The actions that can be performed on the invoice. */
      availableActions: components['schemas']['BillingInvoiceAction'][]
    }
    /** @description Totals contains the summaries of all calculations for the invoice. */
    BillingInvoiceTotals: {
      /** Sum of all line item sums */
      sum: components['schemas']['Numeric']
      /** Sum of all document level discounts */
      discount?: components['schemas']['Numeric']
      /** Sum of all document level charges */
      charge?: components['schemas']['Numeric']
      /** If prices include tax, this is the total tax included in the price. */
      taxIncluded?: components['schemas']['Numeric']
      /** Sum of all line sums minus the discounts, plus the charges, without tax. */
      total: components['schemas']['Numeric']
      /** Total amount of tax to apply to the invoice. */
      tax?: components['schemas']['Numeric']
      /** Grand total after all taxes have been applied. */
      totalWithTax: components['schemas']['Numeric']
      /** Rounding amount to apply to the invoice in case the total and payable amounts don't quite match. */
      rounding?: components['schemas']['Numeric']
      /** Total amount to be paid after applying taxes and outlays. */
      payable: components['schemas']['Numeric']
      /** Total amount already paid in advance. */
      advance?: components['schemas']['Numeric']
      /** How much actually needs to be paid now. */
      due?: components['schemas']['Numeric']
    }
    /**
     * @description InvoiceType represents the type of invoice.
     *
     * The type of invoice determines the purpose of the invoice and how it should be handled.
     * @enum {string}
     */
    BillingInvoiceType: 'standard' | 'credit_note'
    /**
     * @description InvoiceWorkflowSettings represents the workflow settings used by the invoice.
     *
     * This is a clone of the billing profile's workflow settings at the time of invoice creation
     * with customer overrides considered.
     */
    BillingInvoiceWorkflowSettings: {
      /** The apps that will be used to orchestrate the invoice's workflow. */
      apps?: components['schemas']['BillingProfileAppsOrReference']
      /**
       * The billing profile on which the workflow was based on.
       * @description sourceBillingProfileID is the billing profile on which the workflow was based on.
       *
       * The profile is snapshotted on invoice creation, after which it can be altered independently
       * of the profile itself.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      sourceBillingProfileID: string
      /** The workflow details used by this invoice. */
      workflow: components['schemas']['BillingWorkflowSettings']
      /** Timezone of the invoice's date fields. */
      timezone: string
    }
    /** @description LineCharge represents an amount added to the line, and will be applied before taxes. */
    BillingLineCharge: {
      /**
       * Percent
       * @description Percentage if fixed amount not applied
       */
      percent?: components['schemas']['Percentage']
      /**
       * Amount
       * @description Fixed discount amount to apply (calculated if percent present).
       */
      amount: components['schemas']['Numeric']
      /** Reason code. */
      code?: string
      /** Text description as to why the discount was applied. */
      reason?: string
    }
    /** @description LineDiscount represents an amount deducted from the line, and will be applied before taxes. */
    BillingLineDiscount: {
      /**
       * Percent
       * @description Percentage if fixed amount not applied
       */
      percent?: components['schemas']['Percentage']
      /**
       * Amount
       * @description Fixed discount amount to apply (calculated if percent present).
       */
      amount: components['schemas']['Numeric']
      /** Reason code. */
      code?: string
      /** Text description as to why the discount was applied. */
      reason?: string
    }
    /**
     * @description Line status specifies the status of the line.
     * @enum {string}
     */
    BillingLineStatus: 'valid' | 'deleted' | 'split'
    /** @description Party represents a person or business entity. */
    BillingParty: {
      /**
       * ID of the party.
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id?: string
      /** Legal name or representation of the organization. */
      name?: string
      /** The entity's legal ID code used for tax purposes. They may have other numbers, but we're only interested in those valid for tax purposes. */
      taxId?: components['schemas']['BillingTaxIdentity']
      /** Regular post addresses for where information should be sent if needed. */
      addresses?: components['schemas']['Address'][]
    }
    /** @description Party represents a person or business entity. */
    BillingPartyCreate: {
      /** Legal name or representation of the organization. */
      name?: string
      /** The entity's legal ID code used for tax purposes. They may have other numbers, but we're only interested in those valid for tax purposes. */
      taxId?: components['schemas']['BillingTaxIdentity']
      /** Regular post addresses for where information should be sent if needed. */
      addresses?: components['schemas']['Address'][]
    }
    /** @description PaymentTermDueDate defines the terms for payment on a specific date. */
    BillingPaymentTermDueDate: {
      /**
       * Type of terms to be applied.
       * @enum {string}
       */
      type: 'due_date'
      /** Text detail of the chosen payment terms. */
      detail?: string
      /** Description of the conditions for payment. */
      notes?: string
      /** When the payment is due. */
      dueAt: components['schemas']['BillingDueDate'][]
    }
    /** @description PaymentTermInstant defines the terms for payment on receipt of invoice. */
    BillingPaymentTermInstant: {
      /**
       * Type of terms to be applied.
       * @enum {string}
       */
      type: 'instant'
      /** Text detail of the chosen payment terms. */
      detail?: string
      /** Description of the conditions for payment. */
      notes?: string
    }
    /** @description PaymentTerms defines the terms for payment. */
    BillingPaymentTerms:
      | components['schemas']['BillingPaymentTermInstant']
      | components['schemas']['BillingPaymentTermDueDate']
    /**
     * @description Period represents a time range.
     *
     * Billing always treats periods as start being inclusive and end being exclusive.
     */
    BillingPeriod: {
      /**
       * Start of the period.
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      start: string
      /**
       * End of the period.
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      end: string
    }
    /** @description Profile represents a billing profile */
    BillingProfile: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Last update time of the resource
       * Format: date-time
       * @description When the resource was last updated.
       *
       * For updates this field must be set to the last update time to detect conflicts.
       * @example "2023-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /** The name and contact information for the supplier this billing profile represents */
      supplier: components['schemas']['BillingParty']
      /** The billing workflow settings for this profile */
      workflow: components['schemas']['BillingWorkflow']
      /** The applications used by this billing profile */
      apps: components['schemas']['BillingProfileAppsOrReference']
      /** Is this the default profile? */
      default: boolean
    }
    /** @description ProfileAppsReference represents the references (id, type) to the apps used by a billing profile */
    BillingProfileAppReferences: {
      /** The tax app used for this workflow */
      tax: components['schemas']['AppReference']
      /** The invoicing app used for this workflow */
      invoicing: components['schemas']['AppReference']
      /** The payment app used for this workflow */
      payment: components['schemas']['AppReference']
    }
    /** @description ProfileApps represents the applications used by a billing profile */
    BillingProfileApps: {
      tax: components['schemas']['App']
      invoicing: components['schemas']['App']
      payment: components['schemas']['App']
    }
    /**
     * @description ProfileAppsOrReference represents the union of ProfileApps and ProfileAppReferences
     * for a billing profile.
     */
    BillingProfileAppsOrReference:
      | components['schemas']['BillingProfileApps']
      | components['schemas']['BillingProfileAppReferences']
    /** @description ProfileCreateAppsInput represents the input for creating a billing profile's apps */
    BillingProfileCreateAppsInput: {
      /** The tax app used for this workflow */
      tax: components['schemas']['BillingWorkflowAppIdOrType']
      /** The invoicing app used for this workflow */
      invoicing: components['schemas']['BillingWorkflowAppIdOrType']
      /** The payment app used for this workflow */
      payment: components['schemas']['BillingWorkflowAppIdOrType']
    }
    /** @description ProfileCreateInput represents the input for creating a billing profile */
    BillingProfileCreateInput: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /** The name and contact information for the supplier this billing profile represents */
      supplier: components['schemas']['BillingPartyCreate']
      /** The billing workflow settings for this profile */
      workflow: components['schemas']['BillingWorkflow']
      /** Is this the default profile? */
      default: boolean
      apps: components['schemas']['BillingProfileCreateAppsInput']
    }
    /** @description Profile represents a billing profile */
    BillingProfileCreateOrUpdate: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Last update time of the resource
       * Format: date-time
       * @description When the resource was last updated.
       *
       * For updates this field must be set to the last update time to detect conflicts.
       * @example "2023-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /** The name and contact information for the supplier this billing profile represents */
      supplier: components['schemas']['BillingParty']
      /** The billing workflow settings for this profile */
      workflow: components['schemas']['BillingWorkflow']
      /** Is this the default profile? */
      default: boolean
    }
    /**
     * @description ProfileExpand details what profile fields to expand
     * @enum {string}
     */
    BillingProfileExpand: 'apps' | '*'
    /**
     * @description ProfileOrderBy specifies the ordering options for profiles
     * @enum {string}
     */
    BillingProfileOrderBy: 'createdAt' | 'updatedAt' | 'default' | 'name'
    /**
     * @description TaxBehavior details how the tax item is applied to the base amount.
     *
     * Inclusive means the tax is included in the base amount.
     * Exclusive means the tax is added to the base amount.
     * @enum {string}
     */
    BillingTaxBehavior: 'inclusive' | 'exclusive'
    BillingTaxIdentificationCode: string
    /** @description Identity stores the details required to identify an entity for tax purposes in a specific country. */
    BillingTaxIdentity: {
      /** Normalized tax code shown on the original identity document. */
      code?: components['schemas']['BillingTaxIdentificationCode']
    }
    /** @description TaxConfig stores the configuration for a tax line relative to an invoice line. */
    BillingTaxItem: {
      /** Tax provider configuration. */
      config?: components['schemas']['TaxConfig']
      /**
       * Percent defines the percentage set manually or determined from the rate
       * key (calculated if rate present). A nil percent implies that this tax combo
       * is **exempt** from tax.
       */
      percent?: components['schemas']['Percentage']
      /** Some countries require an additional surcharge (calculated if rate present). */
      surcharge?: components['schemas']['Numeric']
      /** Is the tax item inclusive or exclusive of the base amount. */
      behavior?: components['schemas']['BillingTaxBehavior']
    }
    /** @description UsageBasedLine represents a line item that is sold to the customer based on usage. */
    BillingUsageBasedLine: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      status: components['schemas']['BillingLineStatus']
      /** Discounts applied to this line. */
      discounts?: components['schemas']['BillingLineDiscount'][]
      /** Charges applied to this line. */
      charges?: components['schemas']['BillingLineCharge'][]
      /** The invoice this item belongs to. */
      invoice?: components['schemas']['BillingInvoiceReference']
      /** The currency of this line */
      currency: components['schemas']['CurrencyCode']
      /** Map of taxes to be applied and used in the invoice totals. */
      taxes?: components['schemas']['BillingTaxItem'][]
      /** Tax config specify the tax configuration for this line. */
      taxConfig?: components['schemas']['TaxConfig'] | null
      /** Total sum of the line, including discounts and charges. */
      total: components['schemas']['Numeric']
      /** Period of the line item applies to for revenue recognition pruposes. */
      period: components['schemas']['BillingPeriod']
      /**
       * The time this line item should be invoiced.
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      invoiceAt: string
      /** @enum {string} */
      type: 'usage_based'
      price: components['schemas']['RateCardUsageBasedPrice']
      /**
       * The feature that the usage is based on.
       * @description A key is a unique string that is used to identify a resource.
       */
      featureKey: string
      /** Quantity of the item being sold. */
      quantity?: components['schemas']['Numeric']
    }
    /** @description UsageBasedLine represents a line item that is sold to the customer based on usage. */
    BillingUsageBasedLineCreateItem: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /** Discounts applied to this line. */
      discounts?: components['schemas']['BillingLineDiscount'][]
      /** Charges applied to this line. */
      charges?: components['schemas']['BillingLineCharge'][]
      /** The invoice this item belongs to. */
      invoice?: components['schemas']['BillingInvoiceReference']
      /** The currency of this line */
      currency: components['schemas']['CurrencyCode']
      /** Tax config specify the tax configuration for this line. */
      taxConfig?: components['schemas']['TaxConfig'] | null
      /** Period of the line item applies to for revenue recognition pruposes. */
      period: components['schemas']['BillingPeriod']
      /**
       * The time this line item should be invoiced.
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      invoiceAt: string
      /** @enum {string} */
      type: 'usage_based'
      price: components['schemas']['RateCardUsageBasedPrice']
      /**
       * The feature that the usage is based on.
       * @description A key is a unique string that is used to identify a resource.
       */
      featureKey: string
    }
    /** @description UsageBasedLine represents a line item that is sold to the customer based on usage. */
    BillingUsageBasedLineCreateOrUpdate: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /** Discounts applied to this line. */
      discounts?: components['schemas']['BillingLineDiscount'][]
      /** Charges applied to this line. */
      charges?: components['schemas']['BillingLineCharge'][]
      /** The invoice this item belongs to. */
      invoice?: components['schemas']['BillingInvoiceReference']
      /** The currency of this line */
      currency: components['schemas']['CurrencyCode']
      /** Tax config specify the tax configuration for this line. */
      taxConfig?: components['schemas']['TaxConfig'] | null
      /** Period of the line item applies to for revenue recognition pruposes. */
      period: components['schemas']['BillingPeriod']
      /**
       * The time this line item should be invoiced.
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      invoiceAt: string
      /** @enum {string} */
      type: 'usage_based'
      price: components['schemas']['RateCardUsageBasedPrice']
      /**
       * The feature that the usage is based on.
       * @description A key is a unique string that is used to identify a resource.
       */
      featureKey: string
    }
    /**
     * @description ValidationIssue captures any validation issues related to the invoice.
     *
     * Issues with severity "critical" will prevent the invoice from being issued.
     */
    BillingValidationIssue: {
      /** The severity of the issue. */
      severity: components['schemas']['BillingValidationIssueSeverity']
      /** The field that the issue is related to, if available in JSON path format. */
      field?: string
      /** Machine indentifiable code for the issue, if available. */
      code?: string
      /** Component reporting the issue. */
      component: string
      /** A human-readable description of the issue. */
      message: string
      /** Metadata */
      metadata?: components['schemas']['Metadata']
    }
    /**
     * @description ValidationIssueSeverity describes the severity of a validation issue.
     *
     * Issues with severity "critical" will prevent the invoice from being issued.
     * @enum {string}
     */
    BillingValidationIssueSeverity: 'critical' | 'warning'
    /** @description InvoiceVoidAction describes how to handle the voided line items. */
    BillingVoidInvoiceAction: {
      /** How much of the total line items to be voided? (e.g. 100% means all charges are voided) */
      percentage: components['schemas']['Percentage']
      /** How to handle the voided line items, default: pending */
      action: components['schemas']['BillingVoidInvoiceLineAction']
    }
    /** @description Request to void an invoice */
    BillingVoidInvoiceInput: {
      /**
       * The action to take on the voided lines.
       * @description The action to take on the voided line items.
       */
      action: components['schemas']['BillingVoidInvoiceAction']
      /**
       * The reason for voiding the invoice
       * @description The reason for voiding the invoice.
       */
      reason: string
      /**
       * @description Per line item overrides for the action.
       *
       * If not specified, the `action` will be applied to all line items.
       */
      overrides:
        | components['schemas']['BillingVoidInvoiceLineOverride'][]
        | null
    }
    /**
     * @description VoidInvoiceLineAction describes how to handle the voidied line item in the invoice.
     * @enum {string}
     */
    BillingVoidInvoiceLineAction: 'discard' | 'pending' | 'pending_next_cycle'
    /** @description VoidInvoiceLineOverride describes how to handle a specific line item in the invoice when voiding. */
    BillingVoidInvoiceLineOverride: {
      /**
       * The line item ID to override
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      lineId: string
      /** The action to take on the line item */
      action: components['schemas']['BillingVoidInvoiceAction']
    }
    /** @description Workflow represents a billing workflow */
    BillingWorkflow: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** The collection settings for this workflow */
      collection?: components['schemas']['BillingWorkflowCollectionSettings']
      /** The invoicing settings for this workflow */
      invoicing?: components['schemas']['BillingWorkflowInvoicingSettings']
      /** The payment settings for this workflow */
      payment?: components['schemas']['BillingWorkflowPaymentSettings']
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
    }
    /**
     * @description AppIdOrType can be used to reference an app during creation only.
     *
     * This can be either an AppType or the ULID of an app.
     */
    BillingWorkflowAppIdOrType: string
    /**
     * Collection alignment
     * @description CollectionAlignment specifies when the pending line items should be collected into
     * an invoice.
     * @enum {string}
     */
    BillingWorkflowCollectionAlignment: 'subscription'
    /**
     * Collection method
     * @description CollectionMethod specifies how the invoice should be collected (automatic vs manual)
     * @enum {string}
     */
    BillingWorkflowCollectionMethod: 'charge_automatically' | 'send_invoice'
    /** @description Workflow collection specifies how to collect the pending line items for an invoice */
    BillingWorkflowCollectionSettings: {
      /**
       * @description When to collect the pending line items into an invoice.
       * @default subscription
       */
      alignment?: components['schemas']['BillingWorkflowCollectionAlignment']
      /**
       * Format: ISO8601
       * @description The interval for collecting the pending line items into an invoice.
       * @default PT1H
       * @example P1D
       */
      interval?: string
    }
    /**
     * Workflow invoice settings
     * @description WorkflowInvoice represents the invoice settings for a billing workflow
     */
    BillingWorkflowInvoicingSettings: {
      /**
       * @description Whether to automatically issue the invoice after the draftPeriod has passed.
       * @default true
       */
      autoAdvance?: boolean
      /**
       * Format: ISO8601
       * @description The period for the invoice to be kept in draft status for manual reviews.
       * @default P1D
       * @example P1D
       */
      draftPeriod?: string
      /**
       * Format: ISO8601
       * @description The period after which the invoice is due.
       * @default P7D
       * @example P1D
       */
      dueAfter?: string
    }
    /**
     * Workflow payment settings
     * @description WorkflowPaymentSettings represents the payment settings for a billing workflow
     */
    BillingWorkflowPaymentSettings: {
      /** @default charge_automatically */
      collectionMethod?: components['schemas']['BillingWorkflowCollectionMethod']
    }
    /** @description WorkflowSettings represents the settings for a billing workflow. */
    BillingWorkflowSettings: {
      /** The collection settings for this workflow */
      collection?: components['schemas']['BillingWorkflowCollectionSettings']
      /** The invoicing settings for this workflow */
      invoicing?: components['schemas']['BillingWorkflowInvoicingSettings']
      /** The payment settings for this workflow */
      payment?: components['schemas']['BillingWorkflowPaymentSettings']
    }
    /** @description Stripe CheckoutSession.custom_text */
    CheckoutSessionCustomTextAfterSubmitParams: {
      afterSubmit?: {
        message?: string
      }
      shippingAddress?: {
        message?: string
      }
      submit?: {
        message?: string
      }
      termsOfServiceAcceptance?: {
        message?: string
      }
    }
    /**
     * @description Stripe CheckoutSession.ui_mode
     * @enum {string}
     */
    CheckoutSessionUIMode: 'embedded' | 'hosted'
    /** @description Response from the client app (OpenMeter backend) to start the OAuth2 flow. */
    ClientAppStartResponse: {
      /** @description The URL to start the OAuth2 authorization code grant flow. */
      url: string
    }
    /** @description The request could not be completed due to a conflict with the current state of the target resource. */
    ConflictProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.
     * Custom two-letter country codes are also supported for convenience.
     * @example US
     */
    CountryCode: string
    /** @description Create Stripe checkout session request. */
    CreateStripeCheckoutSessionRequest: {
      /**
       * @description If not provided, the default Stripe app is used if any.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      appId?: string
      /**
       * @description Provide a customer ID to use an existing OpenMeter customer.
       * or provide a customer object to create a new customer.
       */
      customer:
        | components['schemas']['CustomerId']
        | components['schemas']['Customer']
      /**
       * @description Stripe customer ID.
       * If not provided OpenMeter creates a new Stripe customer or
       * uses the OpenMeter customer's default Stripe customer ID.
       */
      stripeCustomerId?: string
      /** @description Options passed to Stripe when creating the checkout session. */
      options: components['schemas']['CreateStripeCheckoutSessionRequestOptions']
    }
    /** @description Create Stripe checkout session options */
    CreateStripeCheckoutSessionRequestOptions: {
      currency?: components['schemas']['CurrencyCode']
      cancelURL?: string
      clientReferenceID?: string
      customText?: components['schemas']['CheckoutSessionCustomTextAfterSubmitParams']
      metadata?: {
        [key: string]: string
      }
      returnURL?: string
      successURL?: string
      uiMode?: components['schemas']['CheckoutSessionUIMode']
      paymentMethodTypes?: string[]
    }
    /** @description Create Stripe Checkout Session response. */
    CreateStripeCheckoutSessionResult: {
      /**
       * @description The OpenMeter customer ID.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      customerId: string
      /** @description The Stripe customer ID. */
      stripeCustomerId: string
      /** @description The checkout session ID. */
      sessionId: string
      /** @description The checkout session setup intent ID. */
      setupIntentId: string
      /** @description URL to show the checkout session. */
      url: string
      /**
       * @description Mode
       * Always `setup` for now.
       */
      mode: components['schemas']['StripeCheckoutSessionMode']
      /** @description Cancel URL. */
      cancelURL?: string
      /** @description Success URL. */
      successURL?: string
      /** @description Return URL. */
      returnURL?: string
    }
    /** @description Create subscription request body. */
    CreateSubscriptionRequestBody: {
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      customerId: string
      plan: {
        /** @description A key is a unique string that is used to identify a resource. */
        key: string
        version: number
      }
      currency: components['schemas']['CurrencyCode']
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      activeFrom: string
      /**
       * @description Batch processing commands for customizing the susbcription.
       * The key format is `/phases/{phaseKey}/items/{itemKey}`.
       *
       * Add operations insert a new member based on the creation input without altering the existing members.
       *
       * Remove operations remove the member from the document.
       */
      customizations: (
        | components['schemas']['SubscriptionEditAddItem']
        | components['schemas']['SubscriptionEditRemoveItem']
      )[]
    }
    /**
     * @description Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.
     * Custom three-letter currency codes are also supported for convenience.
     * @example USD
     */
    CurrencyCode: string
    /**
     * @description A customer object.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "name": "ACME Inc.",
     *   "usageAttribution": {
     *     "subjectKeys": [
     *       "my_subject_key"
     *     ]
     *   },
     *   "external": {
     *     "stripeCustomerId": "cus_xxxxxxxxxxxxxx"
     *   },
     *   "createdAt": "2024-01-01T01:01:01.001Z",
     *   "updatedAt": "2024-01-01T01:01:01.001Z"
     * }
     */
    Customer: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Timezone
       * @description Timezone of the customer.
       */
      timezone?: string
      /**
       * Usage Attribution
       * @description Mapping to attribute metered usage to the customer
       */
      usageAttribution: components['schemas']['CustomerUsageAttribution']
      /**
       * Primary Email
       * @description The primary email address of the customer.
       */
      primaryEmail?: string
      /**
       * Currency
       * @description Currency of the customer.
       * Used for billing, tax and invoicing.
       */
      currency?: components['schemas']['CurrencyCode']
      /**
       * Billing Address
       * @description The billing address of the customer.
       * Used for tax and invoicing.
       */
      billingAddress?: components['schemas']['Address']
      /**
       * External Mappings
       * @description External mappings for the customer.
       */
      external?: components['schemas']['CustomerExternalMapping']
    }
    /** @description External mappings for the customer. */
    CustomerExternalMapping: {
      /**
       * Stripe Customer
       * @description The Stripe customer ID.
       * Mapping to a Stripe Customer object.
       * Required to use Stripe as an invocing provider.
       */
      stripeCustomerId?: string
    }
    /** @description Create Stripe checkout session customer ID. */
    CustomerId: {
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
    }
    /** @description A page of results. */
    CustomerList: {
      /** @description The page number. */
      page: number
      /** @description The number of items in the page. */
      pageSize: number
      /** @description The total number of items. */
      totalCount: number
      /** @description The items in the page. */
      items: components['schemas']['Customer'][]
    }
    /**
     * @description Order by options for customers.
     * @enum {string}
     */
    CustomerOrderBy: 'id' | 'name' | 'createdAt'
    /** @description Paginated response */
    CustomerOverridePaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['BillingCustomerOverride'][]
    }
    /**
     * @description Mapping to attribute metered usage to the customer.
     * One customer can have multiple subjects,
     * but one subject can only belong to one customer.
     */
    CustomerUsageAttribution: {
      /**
       * SubjectKeys
       * @description The subjects that are attributed to the customer.
       */
      subjectKeys: string[]
    }
    /**
     * @description A discount on a price.
     * One of: percentage, amount, or usage.
     */
    Discount: components['schemas']['DiscountPercentage']
    /** @description Percentage discount. */
    DiscountPercentage: {
      /**
       * Type
       * @description The type of the discount.
       * @enum {string}
       */
      type: 'percentage'
      /**
       * Percentage
       * @description The percentage of the discount.
       */
      percentage: number
      /**
       * Discounted RateCards
       * @description The rate cards that the discount applies to.
       * When not specified, the discount applies to all rate cards.
       */
      rateCards?: string[]
    }
    /** @description Percentage discount. */
    DiscountPercentageUpdateItem: {
      /**
       * Percentage
       * @description The percentage of the discount.
       */
      percentage: number
      /**
       * Discounted RateCards
       * @description The rate cards that the discount applies to.
       * When not specified, the discount applies to all rate cards.
       */
      rateCards?: string[]
    }
    /**
     * @description A discount on a price.
     * One of: percentage, amount, or usage.
     */
    DiscountUpdateItem: components['schemas']['DiscountPercentageUpdateItem']
    /**
     * @description Entitlement templates are used to define the entitlements of a plan.
     * Features are omitted from the entitlement template, as they are defined in the rate card.
     */
    Entitlement:
      | components['schemas']['EntitlementMetered']
      | components['schemas']['EntitlementStatic']
      | components['schemas']['EntitlementBoolean']
    /** @description Shared fields of the entitlement templates. */
    EntitlementBaseTemplate: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /**
       * @description Readonly unique ULID identifier.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Type
       * @description The type of the entitlement.
       */
      type: components['schemas']['EntitlementType']
      /**
       * @description The identifier key unique to the subject
       * @example customer-1
       */
      subjectKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example example-feature-key
       */
      featureKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId: string
      /** @description The current usage period. */
      currentUsagePeriod?: components['schemas']['Period']
      /** @description The defined usage period of the entitlement */
      usagePeriod?: components['schemas']['RecurringPeriod']
    }
    /** @description Entitlement template of a boolean entitlement. */
    EntitlementBoolean: WithRequired<
      {
        /** @enum {string} */
        type: 'boolean'
        /**
         * Creation Time
         * Format: date-time
         * @description Timestamp of when the resource was created.
         * @example "2024-01-01T01:01:01.001Z"
         */
        createdAt: string
        /**
         * Last Update Time
         * Format: date-time
         * @description Timestamp of when the resource was last updated.
         * @example "2024-01-01T01:01:01.001Z"
         */
        updatedAt: string
        /**
         * Deletion Time
         * Format: date-time
         * @description Timestamp of when the resource was permanently deleted.
         * @example "2024-01-01T01:01:01.001Z"
         */
        deletedAt?: string
        /** @description Additional metadata for the feature. */
        metadata?: components['schemas']['Metadata']
        /**
         * @description Readonly unique ULID identifier.
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        id: string
        /**
         * @description The identifier key unique to the subject
         * @example customer-1
         */
        subjectKey: string
        /**
         * @description The feature the subject is entitled to use.
         * @example example-feature-key
         */
        featureKey: string
        /**
         * @description The feature the subject is entitled to use.
         * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
         */
        featureId: string
        /** @description The current usage period. */
        currentUsagePeriod?: components['schemas']['Period']
        /** @description The defined usage period of the entitlement */
        usagePeriod?: components['schemas']['RecurringPeriod']
      } & components['schemas']['EntitlementBaseTemplate'],
      | 'type'
      | 'createdAt'
      | 'updatedAt'
      | 'id'
      | 'subjectKey'
      | 'featureKey'
      | 'featureId'
    >
    /** @description Create inputs for boolean entitlement */
    EntitlementBooleanCreateInputs: {
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example example-feature-key
       */
      featureKey?: string
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /** @description The usage period associated with the entitlement. */
      usagePeriod?: components['schemas']['RecurringPeriodCreateInput']
      /** @enum {string} */
      type: 'boolean'
    }
    /** @description Create inputs for entitlement */
    EntitlementCreateInputs:
      | components['schemas']['EntitlementMeteredCreateInputs']
      | components['schemas']['EntitlementStaticCreateInputs']
      | components['schemas']['EntitlementBooleanCreateInputs']
    /** @description The grant. */
    EntitlementGrant: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Format: double
       * @description The amount to grant. Should be a positive number.
       * @example 100
       */
      amount: number
      /**
       * Format: uint8
       * @description The priority of the grant. Grants with higher priority are applied first.
       * Priority is a positive decimal numbers. With lower numbers indicating higher importance.
       * For example, a priority of 1 is more urgent than a priority of 2.
       * When there are several grants available for the same subject, the system selects the grant with the highest priority.
       * In cases where grants share the same priority level, the grant closest to its expiration will be used first.
       * In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
       * @example 1
       */
      priority?: number
      /**
       * Format: date-time
       * @description Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
       * @example "2023-01-01T01:01:01.001Z"
       */
      effectiveAt: string
      /** @description The grant expiration definition */
      expiration: components['schemas']['ExpirationPeriod']
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       * Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       * @default 0
       * @example 100
       */
      maxRolloverAmount?: number
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       * Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       * @default 0
       * @example 100
       */
      minRolloverAmount?: number
      /**
       * @description The grant metadata.
       * @example {
       *   "stripePaymentId": "pi_4OrAkhLvyihio9p51h9iiFnB"
       * }
       */
      metadata?: components['schemas']['Metadata']
      /**
       * @description Readonly unique ULID identifier.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * @description The unique entitlement ULID that the grant is associated with.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      entitlementId: string
      /**
       * Format: date-time
       * @description The next time the grant will recurr.
       * @example "2023-01-01T01:01:01.001Z"
       */
      nextRecurrence?: string
      /**
       * Format: date-time
       * @description The time the grant expires.
       * @example "2023-01-01T01:01:01.001Z"
       */
      expiresAt?: string
      /**
       * Format: date-time
       * @description The time the grant was voided.
       * @example "2023-01-01T01:01:01.001Z"
       */
      voidedAt?: string
      /** @description The recurrence period of the grant. */
      recurrence?: components['schemas']['RecurringPeriod']
    }
    /** @description The grant creation input. */
    EntitlementGrantCreateInput: {
      /**
       * Format: double
       * @description The amount to grant. Should be a positive number.
       * @example 100
       */
      amount: number
      /**
       * Format: uint8
       * @description The priority of the grant. Grants with higher priority are applied first.
       * Priority is a positive decimal numbers. With lower numbers indicating higher importance.
       * For example, a priority of 1 is more urgent than a priority of 2.
       * When there are several grants available for the same subject, the system selects the grant with the highest priority.
       * In cases where grants share the same priority level, the grant closest to its expiration will be used first.
       * In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
       * @example 1
       */
      priority?: number
      /**
       * Format: date-time
       * @description Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
       * @example "2023-01-01T01:01:01.001Z"
       */
      effectiveAt: string
      /** @description The grant expiration definition */
      expiration: components['schemas']['ExpirationPeriod']
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       * Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       * @default 0
       * @example 100
       */
      maxRolloverAmount?: number
      /**
       * Format: double
       * @description Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
       * Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
       * @default 0
       * @example 100
       */
      minRolloverAmount?: number
      /**
       * @description The grant metadata.
       * @example {
       *   "stripePaymentId": "pi_4OrAkhLvyihio9p51h9iiFnB"
       * }
       */
      metadata?: components['schemas']['Metadata']
      /** @description The subject of the grant. */
      recurrence?: components['schemas']['RecurringPeriodCreateInput']
    }
    /**
     * @description Metered entitlements are useful for many different use cases, from setting up usage based access to implementing complex credit systems.
     * Access is determined based on feature usage using a balance calculation (the "usage allowance" provided by the issued grants is "burnt down" by the usage).
     */
    EntitlementMetered: {
      /** @enum {string} */
      type: 'metered'
      /**
       * Soft limit
       * @description If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
       * @default false
       */
      isSoftLimit?: boolean
      /**
       * @deprecated
       * @description Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
       * @default false
       */
      isUnlimited?: boolean
      /**
       * Initial grant amount
       * Format: double
       * @description You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
       * If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
       * That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
       * Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
       */
      issueAfterReset?: number
      /**
       * Issue grant after reset priority
       * Format: uint8
       * @description Defines the grant priority for the default grant.
       * @default 1
       */
      issueAfterResetPriority?: number
      /**
       * Preserve overage at reset
       * @description If true, the overage is preserved at reset. If false, the usage is reset to 0.
       * @default false
       */
      preserveOverageAtReset?: boolean
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /**
       * @description Readonly unique ULID identifier.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * @description The identifier key unique to the subject
       * @example customer-1
       */
      subjectKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example example-feature-key
       */
      featureKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId: string
      /**
       * Format: date-time
       * @description The time the last reset happened.
       * @example "2023-01-01T01:01:01.001Z"
       */
      lastReset: string
      /** @description The current usage period. */
      currentUsagePeriod: components['schemas']['Period']
      /**
       * Format: date-time
       * @description The time from which usage is measured. If not specified on creation, defaults to entitlement creation time.
       * @example "2023-01-01T01:01:01.001Z"
       */
      measureUsageFrom: string
      /** @description THe usage period of the entitlement. */
      usagePeriod: components['schemas']['RecurringPeriod']
    }
    /** @description Create inpurs for metered entitlement */
    EntitlementMeteredCreateInputs: {
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example example-feature-key
       */
      featureKey?: string
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /** @enum {string} */
      type: 'metered'
      /**
       * Soft limit
       * @description If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
       * @default false
       */
      isSoftLimit?: boolean
      /**
       * @deprecated
       * @description Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
       * @default false
       */
      isUnlimited?: boolean
      /** @description The usage period associated with the entitlement. */
      usagePeriod: components['schemas']['RecurringPeriodCreateInput']
      /** @description Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time. */
      measureUsageFrom?: components['schemas']['MeasureUsageFrom']
      /**
       * Initial grant amount
       * Format: double
       * @description You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
       * If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
       * That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
       * Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
       */
      issueAfterReset?: number
      /**
       * Issue grant after reset priority
       * Format: uint8
       * @description Defines the grant priority for the default grant.
       * @default 1
       */
      issueAfterResetPriority?: number
      /**
       * Preserve overage at reset
       * @description If true, the overage is preserved at reset. If false, the usage is reset to 0.
       * @default false
       */
      preserveOverageAtReset?: boolean
    }
    /**
     * @description Order by options for entitlements.
     * @enum {string}
     */
    EntitlementOrderBy: 'createdAt' | 'updatedAt'
    /** @description Paginated response */
    EntitlementPaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['Entitlement'][]
    }
    /** @description A static entitlement. */
    EntitlementStatic: {
      /** @enum {string} */
      type: 'static'
      /**
       * Format: json
       * @description The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
       * @example { "integrations": ["github"] }
       */
      config: string
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /**
       * @description Readonly unique ULID identifier.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * @description The identifier key unique to the subject
       * @example customer-1
       */
      subjectKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example example-feature-key
       */
      featureKey: string
      /**
       * @description The feature the subject is entitled to use.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId: string
      /** @description The current usage period. */
      currentUsagePeriod?: components['schemas']['Period']
      /** @description The defined usage period of the entitlement */
      usagePeriod?: components['schemas']['RecurringPeriod']
    }
    /** @description Create inputs for static entitlement */
    EntitlementStaticCreateInputs: {
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example example-feature-key
       */
      featureKey?: string
      /**
       * @description The feature the subject is entitled to use.
       * Either featureKey or featureId is required.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      featureId?: string
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /** @description The usage period associated with the entitlement. */
      usagePeriod?: components['schemas']['RecurringPeriodCreateInput']
      /** @enum {string} */
      type: 'static'
      /**
       * Format: json
       * @description The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
       * @example { "integrations": ["github"] }
       */
      config: string
    }
    /**
     * @description Type of the entitlement.
     * @enum {string}
     */
    EntitlementType: 'metered' | 'boolean' | 'static'
    /** @description Entitlements are the core of OpenMeter access management. They define access to features for subjects. Entitlements can be metered, boolean, or static. */
    EntitlementValue: {
      /**
       * @description Whether the subject has access to the feature. Shared accross all entitlement types.
       * @example true
       */
      hasAccess: boolean
      /**
       * Format: double
       * @description Only available for metered entitlements. Metered entitlements are built around a balance calculation where feature usage is deducted from the issued grants. Balance represents the remaining balance of the entitlement, it's value never turns negative.
       * @example 100
       */
      balance?: number
      /**
       * Format: double
       * @description Only available for metered entitlements. Returns the total feature usage in the current period.
       * @example 50
       */
      usage?: number
      /**
       * Format: double
       * @description Only available for metered entitlements. Overage represents the usage that wasn't covered by grants, e.g. if the subject had a total feature usage of 100 in the period but they were only granted 80, there would be 20 overage.
       * @example 0
       */
      overage?: number
      /**
       * @description Only available for static entitlements. The JSON parsable config of the entitlement.
       * @example { key: "value" }
       */
      config?: string
    }
    /**
     * @description CloudEvents Specification JSON Schema
     * @example {
     *   "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3c",
     *   "source": "service-name",
     *   "specversion": "1.0",
     *   "type": "prompt",
     *   "subject": "customer-id",
     *   "time": "2023-01-01T01:01:01.001Z"
     * }
     */
    Event: {
      /**
       * @description Identifies the event.
       * @example 5c10fade-1c9e-4d6c-8275-c52c36731d3c
       */
      id: string
      /**
       * Format: uri-reference
       * @description Identifies the context in which an event happened.
       * @example service-name
       */
      source: string
      /**
       * @description The version of the CloudEvents specification which the event uses.
       * @default 1.0
       * @example 1.0
       */
      specversion: string
      /**
       * @description Contains a value describing the type of event related to the originating occurrence.
       * @example com.example.someevent
       */
      type: string
      /**
       * @description Content type of the data value. Must adhere to RFC 2046 format.
       * @example application/json
       */
      datacontenttype?: string | null
      /**
       * Format: uri
       * @description Identifies the schema that data adheres to.
       */
      dataschema?: string | null
      /**
       * @description Describes the subject of the event in the context of the event producer (identified by source).
       * @example customer-id
       */
      subject: string
      /**
       * Format: date-time
       * @description Timestamp of when the occurrence happened. Must adhere to RFC 3339.
       * @example "2023-01-01T01:01:01.001Z"
       */
      time?: string | null
      /** @description The event payload. */
      data?: Record<string, never> | string | null
    }
    /**
     * @description The expiration duration enum
     * @enum {string}
     */
    ExpirationDuration: 'HOUR' | 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
    /** @description The grant expiration definition */
    ExpirationPeriod: {
      /** @description The unit of time for the expiration period. */
      duration: components['schemas']['ExpirationDuration']
      /**
       * @description The number of time units in the expiration period.
       * @example 12
       */
      count: number
    }
    /**
     * @description Represents a feature that can be enabled or disabled for a plan.
     * Used both for product catalog and entitlements.
     */
    Feature: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Archival Time
       * Format: date-time
       * @description Timestamp of when the resource was archived.
       * @example "2023-01-01T01:01:01.001Z"
       */
      archivedAt?: string
      /**
       * The unique key of the feature
       * @description A key is a unique string that is used to identify a resource.
       */
      key: string
      /** The human-readable name of the feature */
      name: string
      /**
       * Optional metadata
       * @example {
       *   "key": "value"
       * }
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Meter slug
       * @description A key is a unique string that is used to identify a resource.
       * @example tokens_total
       */
      meterSlug?: string
      /**
       * Meter group by filters
       * @description Optional meter group by filters.
       * Useful if the meter scope is broader than what feature tracks.
       * Example scenario would be a meter tracking all token use with groupBy fields for the model,
       * then the feature could filter for model=gpt-4.
       * @example {
       *   "model": "gpt-4",
       *   "type": "input"
       * }
       */
      meterGroupByFilters?: {
        [key: string]: string
      }
      /**
       * @description Readonly unique ULID identifier.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
    }
    /**
     * @description Represents a feature that can be enabled or disabled for a plan.
     * Used both for product catalog and entitlements.
     */
    FeatureCreateInputs: {
      /**
       * The unique key of the feature
       * @description A key is a unique string that is used to identify a resource.
       */
      key: string
      /** The human-readable name of the feature */
      name: string
      /**
       * Optional metadata
       * @example {
       *   "key": "value"
       * }
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Meter slug
       * @description A key is a unique string that is used to identify a resource.
       * @example tokens_total
       */
      meterSlug?: string
      /**
       * Meter group by filters
       * @description Optional meter group by filters.
       * Useful if the meter scope is broader than what feature tracks.
       * Example scenario would be a meter tracking all token use with groupBy fields for the model,
       * then the feature could filter for model=gpt-4.
       * @example {
       *   "model": "gpt-4",
       *   "type": "input"
       * }
       */
      meterGroupByFilters?: {
        [key: string]: string
      }
    }
    /** @description Limited representation of a feature resource which includes only its unique identifiers (id, key). */
    FeatureMeta: {
      /**
       * Feature Unique Identifier
       * @description Unique identifier of a feature.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Feature Key
       * @description The key is an immutable unique identifier of the feature used throughout the API,
       * for example when interacting with a subject's entitlements.
       * @example gpt4_tokens
       */
      key: string
    }
    /**
     * @description Order by options for features.
     * @enum {string}
     */
    FeatureOrderBy: 'id' | 'createdAt' | 'updatedAt'
    /** @description Paginated response */
    FeaturePaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['Feature'][]
    }
    /** @description Flat price. */
    FlatPrice: {
      /** @enum {string} */
      type: 'flat'
      /** @description The amount of the flat price. */
      amount: components['schemas']['Numeric']
    }
    /** @description Flat price with payment term. */
    FlatPriceWithPaymentTerm: {
      /** @enum {string} */
      type: 'flat'
      /** @description The amount of the flat price. */
      amount: components['schemas']['Numeric']
      /**
       * @description The payment term of the flat price.
       * Defaults to in advance.
       * @default in_advance
       */
      paymentTerm?: components['schemas']['PricePaymentTerm']
    }
    /** @description The server understood the request but refuses to authorize it. */
    ForbiddenProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /** @description The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server it needed to access in order to complete the request. */
    GatewayTimeoutProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description A segment of the grant burn down history.
     *
     * A given segment represents the usage of a grant between events that changed either the grant burn down priority order or the usag period.
     */
    GrantBurnDownHistorySegment: {
      /** @description The period of the segment. */
      period: components['schemas']['Period']
      /**
       * Format: double
       * @description The total usage of the grant in the period.
       * @example 100
       */
      usage: number
      /**
       * Format: double
       * @description Overuse that wasn't covered by grants.
       * @example 100
       */
      overage: number
      /**
       * Format: double
       * @description entitlement balance at the start of the period.
       * @example 100
       */
      balanceAtStart: number
      /**
       * @description The balance breakdown of each active grant at the start of the period: GrantID: Balance
       * @example {
       *   "01G65Z755AFWAKHE12NY0CQ9FH": 100
       * }
       */
      grantBalancesAtStart: {
        [key: string]: number
      }
      /**
       * Format: double
       * @description The entitlement balance at the end of the period.
       * @example 100
       */
      balanceAtEnd: number
      /**
       * @description The balance breakdown of each active grant at the end of the period: GrantID: Balance
       * @example {
       *   "01G65Z755AFWAKHE12NY0CQ9FH": 100
       * }
       */
      grantBalancesAtEnd: {
        [key: string]: number
      }
      /** @description Which grants were actually burnt down in the period and by what amount. */
      grantUsages: readonly components['schemas']['GrantUsageRecord'][]
    }
    /**
     * @description Order by options for grants.
     * @enum {string}
     */
    GrantOrderBy: 'id' | 'createdAt' | 'updatedAt'
    /** @description Paginated response */
    GrantPaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['EntitlementGrant'][]
    }
    /** @description Usage Record */
    GrantUsageRecord: {
      /**
       * @description The id of the grant
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      grantId: string
      /**
       * Format: double
       * @description The usage in the period
       * @example 100
       */
      usage: number
    }
    /**
     * @description An ingested event with optional validation error.
     * @example {
     *   "event": {
     *     "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3c",
     *     "source": "service-name",
     *     "specversion": "1.0",
     *     "type": "prompt",
     *     "subject": "customer-id",
     *     "time": "2023-01-01T01:01:01.001Z"
     *   },
     *   "ingestedAt": "2023-01-01T01:01:01.001Z",
     *   "storedAt": "2023-01-01T01:01:02.001Z"
     * }
     */
    IngestedEvent: {
      event: components['schemas']['Event']
      /** @description The validation error if the event failed validation. */
      validationError?: string
      /**
       * Format: date-time
       * @description The date and time the event was ingested.
       * @example "2023-01-01T01:01:01.001Z"
       */
      ingestedAt: string
      /**
       * Format: date-time
       * @description The date and time the event was stored.
       * @example "2023-01-01T01:01:01.001Z"
       */
      storedAt: string
    }
    /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
    InternalServerErrorProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /** @description Paginated response */
    InvoicePaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['BillingInvoice'][]
    }
    ListEntitlementsResult:
      | components['schemas']['Entitlement'][]
      | components['schemas']['EntitlementPaginatedResponse']
    ListFeaturesResult:
      | components['schemas']['Feature'][]
      | components['schemas']['FeaturePaginatedResponse']
    /**
     * @description A marketplace listing.
     * Represent an available app in the app marketplace that can be installed to the organization.
     *
     * Marketplace apps only exist in config so they don't extend the Resource model.
     * @example {
     *   "type": "stripe",
     *   "name": "Stripe",
     *   "description": "Stripe interation allows you to collect payments with Stripe.",
     *   "iconUrl": "/images/stripe.png",
     *   "capabilities": [
     *     {
     *       "type": "calculateTax",
     *       "key": "stripe_calculate_tax",
     *       "name": "Calculate Tax",
     *       "description": "Stripe Tax calculates tax portion of the invoices."
     *     },
     *     {
     *       "type": "invoiceCustomers",
     *       "key": "stripe_invoice_customers",
     *       "name": "Invoice Customers",
     *       "description": "Stripe invoices customers with due amount."
     *     },
     *     {
     *       "type": "collectPayments",
     *       "key": "stripe_collect_payments",
     *       "name": "Collect Payments",
     *       "description": "Stripe payments collects outstanding revenue with Stripe customer's default payment method."
     *     }
     *   ]
     * }
     */
    MarketplaceListing: {
      /** @description The app's type */
      type: components['schemas']['AppType']
      /** @description The app's name. */
      name: string
      /** @description The app's description. */
      description: string
      /** @description The app's icon URL. */
      iconUrl: string
      /** @description The app's capabilities. */
      capabilities: components['schemas']['AppCapability'][]
    }
    /** @description A page of results. */
    MarketplaceListingList: {
      /** @description The page number. */
      page: number
      /** @description The number of items in the page. */
      pageSize: number
      /** @description The total number of items. */
      totalCount: number
      /** @description The items in the page. */
      items: components['schemas']['MarketplaceListing'][]
    }
    /** @description Measure usage from */
    MeasureUsageFrom:
      | components['schemas']['MeasureUsageFromPreset']
      | components['schemas']['MeasureUsageFromTime']
    /**
     * @description Start of measurement options
     * @enum {string}
     */
    MeasureUsageFromPreset: 'CURRENT_PERIOD_START' | 'NOW'
    /**
     * Format: date-time
     * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
     * @example "2023-01-01T01:01:01.001Z"
     */
    MeasureUsageFromTime: string
    /**
     * @description Set of key-value pairs.
     * Metadata can be used to store additional information about a resource.
     * @example {
     *   "externalId": "019142cc-a016-796a-8113-1a942fecd26d"
     * }
     */
    Metadata: {
      [key: string]: string
    }
    /**
     * @description A meter is a configuration that defines how to match and aggregate events.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "slug": "tokens_total",
     *   "description": "AI Token Usage",
     *   "aggregation": "SUM",
     *   "windowSize": "MINUTE",
     *   "eventType": "prompt",
     *   "valueProperty": "$.tokens",
     *   "groupBy": {
     *     "model": "$.model",
     *     "type": "$.type"
     *   }
     * }
     */
    Meter: {
      /**
       * @description A unique identifier for the meter.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * @description A unique, human-readable identifier for the meter.
       * Must consist only alphanumeric and underscore characters.
       * @example tokens_total
       */
      slug: string
      /**
       * @description A description of the meter.
       * @example AI Token Usage
       */
      description?: string
      /** @example SUM */
      aggregation: components['schemas']['MeterAggregation']
      /** @example MINUTE */
      windowSize: components['schemas']['WindowSize']
      /**
       * @description The event type to aggregate.
       * @example prompt
       */
      eventType: string
      /**
       * @description JSONPath expression to extract the value from the ingested event's data property.
       *
       * The ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.
       *
       * For UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.
       * @example $.tokens
       */
      valueProperty?: string
      /**
       * @description Named JSONPath expressions to extract the group by values from the event data.
       *
       * Keys must be unique and consist only alphanumeric and underscore characters.
       *
       * TODO: add key format enforcement
       * @example {
       *   "type": "$.type"
       * }
       */
      groupBy?: {
        [key: string]: string
      }
    }
    /**
     * @description The aggregation type to use for the meter.
     * @enum {string}
     */
    MeterAggregation: 'SUM' | 'COUNT' | 'UNIQUE_COUNT' | 'AVG' | 'MIN' | 'MAX'
    /**
     * @description A meter is a configuration that defines how to match and aggregate events.
     * @example {
     *   "slug": "tokens_total",
     *   "description": "AI Token Usage",
     *   "aggregation": "SUM",
     *   "windowSize": "MINUTE",
     *   "eventType": "prompt",
     *   "valueProperty": "$.tokens",
     *   "groupBy": {
     *     "model": "$.model",
     *     "type": "$.type"
     *   }
     * }
     */
    MeterCreate: {
      /**
       * @description A unique, human-readable identifier for the meter.
       * Must consist only alphanumeric and underscore characters.
       * @example tokens_total
       */
      slug: string
      /**
       * @description A description of the meter.
       * @example AI Token Usage
       */
      description?: string
      /** @example SUM */
      aggregation: components['schemas']['MeterAggregation']
      /** @example MINUTE */
      windowSize: components['schemas']['WindowSize']
      /**
       * @description The event type to aggregate.
       * @example prompt
       */
      eventType: string
      /**
       * @description JSONPath expression to extract the value from the ingested event's data property.
       *
       * The ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.
       *
       * For UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.
       * @example $.tokens
       */
      valueProperty?: string
      /**
       * @description Named JSONPath expressions to extract the group by values from the event data.
       *
       * Keys must be unique and consist only alphanumeric and underscore characters.
       *
       * TODO: add key format enforcement
       * @example {
       *   "type": "$.type"
       * }
       */
      groupBy?: {
        [key: string]: string
      }
    }
    /**
     * @description The result of a meter query.
     * @example {
     *   "from": "2023-01-01T00:00:00.000Z",
     *   "to": "2023-01-02T00:00:00.000Z",
     *   "windowSize": "DAY",
     *   "data": [
     *     {
     *       "value": 12,
     *       "windowStart": "2023-01-01T00:00:00.000Z",
     *       "windowEnd": "2023-01-02T00:00:00.000Z",
     *       "subject": "customer-1",
     *       "groupBy": {
     *         "model": "gpt-4-turbo",
     *         "type": "prompt"
     *       }
     *     }
     *   ]
     * }
     */
    MeterQueryResult: {
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      from?: string
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      to?: string
      windowSize?: components['schemas']['WindowSize']
      data: components['schemas']['MeterQueryRow'][]
    }
    /**
     * @description A row in the result of a meter query.
     * @example {
     *   "value": 12,
     *   "windowStart": "2023-01-01T00:00:00.000Z",
     *   "windowEnd": "2023-01-02T00:00:00.000Z",
     *   "subject": "customer-1",
     *   "groupBy": {
     *     "model": "gpt-4-turbo",
     *     "type": "prompt"
     *   }
     * }
     */
    MeterQueryRow: {
      value: number
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      windowStart: string
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      windowEnd: string
      subject?: string
      groupBy?: {
        [key: string]: string
      }
    }
    /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
    NotFoundProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /** @description The server does not support the functionality required to fulfill the request. */
    NotImplementedProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /** @description Notification channel. */
    NotificationChannel: components['schemas']['NotificationChannelWebhook']
    /** @description Union type for requests creating new notification channel with certain type. */
    NotificationChannelCreateRequest: components['schemas']['NotificationChannelWebhookCreateRequest']
    /** @description Metadata only fields of a notification channel. */
    NotificationChannelMeta: {
      /**
       * Channel Unique Identifier
       * @description Identifies the notification channel.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Channel Type
       * @description Notification channel type.
       */
      type: components['schemas']['NotificationChannelType']
    }
    /**
     * @description Order by options for notification channels.
     * @enum {string}
     */
    NotificationChannelOrderBy: 'id' | 'type' | 'createdAt' | 'updatedAt'
    /** @description Paginated response */
    NotificationChannelPaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['NotificationChannel'][]
    }
    /**
     * @description Type of the notification channel.
     * @enum {string}
     */
    NotificationChannelType: 'WEBHOOK'
    /** @description Notification channel with webhook type. */
    NotificationChannelWebhook: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Channel Unique Identifier
       * @description Identifies the notification channel.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Channel Type
       * @description Notification channel type.
       * @enum {string}
       */
      type: 'WEBHOOK'
      /**
       * Channel Name
       * @description User friendly name of the channel.
       * @example customer-webhook
       */
      name: string
      /**
       * Channel Disabled
       * @description Whether the channel is disabled or not.
       * @default false
       * @example true
       */
      disabled?: boolean
      /**
       * Webhook URL
       * @description Webhook URL where the notification is sent.
       * @example https://example.com/webhook
       */
      url: string
      /**
       * Custom HTTP Headers
       * @description Custom HTTP headers sent as part of the webhook request.
       */
      customHeaders?: {
        [key: string]: string
      }
      /**
       * Signing Secret
       * @description Signing secret used for webhook request validation on the receiving end.
       *
       * Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
       * @example whsec_S6g2HLnTwd9AhHwUIMFggVS9OfoPafN8
       */
      signingSecret?: string
    }
    /** @description Request with input parameters for creating new notification channel with webhook type. */
    NotificationChannelWebhookCreateRequest: {
      /**
       * Channel Type
       * @description Notification channel type.
       * @enum {string}
       */
      type: 'WEBHOOK'
      /**
       * Channel Name
       * @description User friendly name of the channel.
       * @example customer-webhook
       */
      name: string
      /**
       * Channel Disabled
       * @description Whether the channel is disabled or not.
       * @default false
       * @example true
       */
      disabled?: boolean
      /**
       * Webhook URL
       * @description Webhook URL where the notification is sent.
       * @example https://example.com/webhook
       */
      url: string
      /**
       * Custom HTTP Headers
       * @description Custom HTTP headers sent as part of the webhook request.
       */
      customHeaders?: {
        [key: string]: string
      }
      /**
       * Signing Secret
       * @description Signing secret used for webhook request validation on the receiving end.
       *
       * Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
       * @example whsec_S6g2HLnTwd9AhHwUIMFggVS9OfoPafN8
       */
      signingSecret?: string
    }
    /** @description Type of the notification event. */
    NotificationEvent: {
      /**
       * Event Identifier
       * @description A unique identifier of the notification event.
       * @example 01J2KNP1YTXQRXHTDJ4KPR7PZ0
       */
      id: string
      /**
       * Event Type
       * @description Type of the notification event.
       */
      type: components['schemas']['NotificationEventType']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp when the notification event was created in RFC 3339 format.
       * @example "2023-01-01T01:01:01.001Z"
       */
      createdAt: string
      rule: components['schemas']['NotificationRule']
      /**
       * Delivery Status
       * @description The delivery status of the notification event.
       */
      deliveryStatus: readonly components['schemas']['NotificationEventDeliveryStatus'][]
      payload: components['schemas']['NotificationEventPayload']
      /**
       * Annotations
       * @description Set of key-value pairs managed by the system. Cannot be modified by user.
       */
      annotations?: components['schemas']['Annotations']
    }
    /** @description Payload for notification event with `entitlements.balance.threshold` type. */
    NotificationEventBalanceThresholdPayload: {
      /**
       * Notification Event Identifier
       * @description A unique identifier for the notification event the payload belongs to.
       * @example 01J2KNP1YTXQRXHTDJ4KPR7PZ0
       */
      id: string
      /**
       * Notification Event Type
       * @description Type of the notification event.
       * @enum {string}
       */
      type: 'entitlements.balance.threshold'
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp when the notification event was created in RFC 3339 format.
       * @example "2023-01-01T01:01:01.001Z"
       */
      timestamp: string
      /**
       * Payload Data
       * @description The data of the payload.
       */
      data: components['schemas']['NotificationEventBalanceThresholdPayloadData']
    }
    /** @description Data of the payload for notification event with `entitlements.balance.threshold` type. */
    NotificationEventBalanceThresholdPayloadData: {
      /** Entitlement */
      entitlement: components['schemas']['EntitlementMetered']
      /** Feature */
      feature: components['schemas']['Feature']
      /** Subject */
      subject: components['schemas']['Subject']
      /** Entitlement Value */
      value: components['schemas']['EntitlementValue']
      /** Threshold */
      threshold: components['schemas']['NotificationRuleBalanceThresholdValue']
    }
    /** @description The delivery status of the notification event. */
    NotificationEventDeliveryStatus: {
      /**
       * @description Delivery state of the notification event to the channel.
       * @example SUCCESS
       */
      state: components['schemas']['NotificationEventDeliveryStatusState']
      /**
       * State Reason
       * @description The reason of the last deliverry state update.
       * @example Failed to dispatch event due to provider error.
       */
      reason: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the status was last updated in RFC 3339 format.
       * @example "2023-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Notification Channel
       * @description Notification channel the delivery sattus associated with.
       */
      channel: components['schemas']['NotificationChannelMeta']
    }
    /**
     * Delivery State
     * @description The delivery state of the notification event to the channel.
     * @enum {string}
     */
    NotificationEventDeliveryStatusState:
      | 'SUCCESS'
      | 'FAILED'
      | 'SENDING'
      | 'PENDING'
    /**
     * @description Order by options for notification channels.
     * @enum {string}
     */
    NotificationEventOrderBy: 'id' | 'createdAt'
    /** @description Paginated response */
    NotificationEventPaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['NotificationEvent'][]
    }
    /** @description The delivery status of the notification event. */
    NotificationEventPayload: components['schemas']['NotificationEventBalanceThresholdPayload']
    /**
     * @description Type of the notification event.
     * @enum {string}
     */
    NotificationEventType: 'entitlements.balance.threshold'
    /** @description Notification Rule. */
    NotificationRule: components['schemas']['NotificationRuleBalanceThreshold']
    /** @description Notification rule with entitlements.balance.threshold type. */
    NotificationRuleBalanceThreshold: {
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Rule Unique Identifier
       * @description Identifies the notification rule.
       * @example 01ARZ3NDEKTSV4RRFFQ69G5FAV
       */
      id: string
      /**
       * Rule Type
       * @description Notification rule type.
       * @enum {string}
       */
      type: 'entitlements.balance.threshold'
      /**
       * Rule Name
       * @description The user friendly name of the notification rule.
       * @example Balance threshold reached
       */
      name: string
      /**
       * Rule Disabled
       * @description Whether the rule is disabled or not.
       * @default false
       * @example true
       */
      disabled?: boolean
      /**
       * Channels assigned to Rule
       * @description List of notification channels the rule applies to.
       */
      channels: components['schemas']['NotificationChannelMeta'][]
      /**
       * Entitlement Balance Thresholds
       * @description List of thresholds the rule suppose to be triggered.
       */
      thresholds: components['schemas']['NotificationRuleBalanceThresholdValue'][]
      /**
       * Features
       * @description Optional field containing list of features the rule applies to.
       */
      features?: components['schemas']['FeatureMeta'][]
    }
    /** @description Request with input parameters for creating new notification rule with entitlements.balance.threashold type. */
    NotificationRuleBalanceThresholdCreateRequest: {
      /**
       * Rule Type
       * @description Notification rule type.
       * @enum {string}
       */
      type: 'entitlements.balance.threshold'
      /**
       * Rule Name
       * @description The user friendly name of the notification rule.
       * @example Balance threshold reached
       */
      name: string
      /**
       * Rule Disabled
       * @description Whether the rule is disabled or not.
       * @default false
       * @example true
       */
      disabled?: boolean
      /**
       * Entitlement Balance Thresholds
       * @description List of thresholds the rule suppose to be triggered.
       */
      thresholds: components['schemas']['NotificationRuleBalanceThresholdValue'][]
      /**
       * Channels
       * @description List of notification channels the rule is applied to.
       */
      channels: string[]
      /**
       * Features
       * @description Optional field for defining the scope of notification by feature. It may contain features by id or key.
       */
      features?: string[]
    }
    /** @description Threshold value with multiple supported types. */
    NotificationRuleBalanceThresholdValue: {
      /**
       * Threshold Value
       * Format: double
       * @description Value of the threshold.
       * @example 100
       */
      value: number
      /**
       * @description Type of the threshold.
       * @example NUMBER
       */
      type: components['schemas']['NotificationRuleBalanceThresholdValueType']
    }
    /**
     * Notification balance threshold type
     * @description Type of the rule in the balance threshold specification.
     * @enum {string}
     */
    NotificationRuleBalanceThresholdValueType: 'PERCENT' | 'NUMBER'
    /** @description Union type for requests creating new notification rule with certain type. */
    NotificationRuleCreateRequest: components['schemas']['NotificationRuleBalanceThresholdCreateRequest']
    /**
     * @description Order by options for notification channels.
     * @enum {string}
     */
    NotificationRuleOrderBy: 'id' | 'type' | 'createdAt' | 'updatedAt'
    /** @description Paginated response */
    NotificationRulePaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['NotificationRule'][]
    }
    /** @description Numeric represents an arbitrary precision number. */
    Numeric: string
    /**
     * @description OAuth2 authorization code grant error types.
     * @enum {string}
     */
    OAuth2AuthorizationCodeGrantErrorType:
      | 'invalid_request'
      | 'unauthorized_client'
      | 'access_denied'
      | 'unsupported_response_type'
      | 'invalid_scope'
      | 'server_error'
      | 'temporarily_unavailable'
    /** @description Numeric representation of a percentage */
    Percentage: string
    /** @description A period with a start and end time. */
    Period: {
      /**
       * Format: date-time
       * @description Period start time.
       * @example "2023-01-01T01:01:01.001Z"
       */
      from: string
      /**
       * Format: date-time
       * @description Period end time.
       * @example "2023-02-01T01:01:01.001Z"
       */
      to: string
    }
    /**
     * @description Order by options for plan phases.
     * @enum {string}
     */
    PhasesOrderBy: 'key' | 'start_after'
    /** @description Plans provide a template for subscriptions. */
    Plan: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Key
       * @description A semi-unique identifier for the resource.
       */
      key: string
      /**
       * Version
       * @description Version of the plan. Incremented when the plan is updated.
       * @default 1
       */
      version: number
      /**
       * Currency
       * @description The currency code of the plan.
       * @default USD
       */
      currency: components['schemas']['CurrencyCode']
      /**
       * Effective start date
       * Format: date-time
       * @description The date and time when the plan becomes effective. When not specified, the plan is a draft.
       * @example "2023-01-01T01:01:01.001Z"
       */
      effectiveFrom?: string
      /**
       * Effective end date
       * Format: date-time
       * @description The date and time when the plan is no longer effective. When not specified, the plan is effective indefinitely.
       * @example "2023-01-01T01:01:01.001Z"
       */
      effectiveTo?: string
      /**
       * Status
       * @description The status of the plan.
       * Computed based on the effective start and end dates:
       * - draft = no effectiveFrom
       * - active = effectiveFrom <= now < effectiveTo
       * - archived / inactive = effectiveTo <= now
       * - scheduled = now < effectiveFrom < effectiveTo
       */
      status: components['schemas']['PlanStatus']
      /**
       * Plan phases
       * @description The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
       * A phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.
       */
      phases: components['schemas']['PlanPhase'][]
    }
    /** @description Resource create operation model. */
    PlanCreate: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Key
       * @description A semi-unique identifier for the resource.
       */
      key: string
      /**
       * Currency
       * @description The currency code of the plan.
       * @default USD
       */
      currency: components['schemas']['CurrencyCode']
      /**
       * Plan phases
       * @description The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
       * A phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.
       */
      phases: components['schemas']['PlanPhase'][]
    }
    /**
     * @description Order by options for plans.
     * @enum {string}
     */
    PlanOrderBy: 'id' | 'key' | 'version' | 'create_at' | 'updated_at'
    /** @description Paginated response */
    PlanPaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['Plan'][]
    }
    /** @description The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses. */
    PlanPhase: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description Unique key among the plan phases. Used to reference the phase in the subscription & plan. */
      key: string
      /**
       * Rate cards
       * @description The rate cards of the plan.
       */
      rateCards: components['schemas']['RateCard'][]
      /**
       * Start after
       * Format: duration
       * @description The time after which the plan starts compared to subscription start
       * @example P1Y1D
       */
      startAfter: string | null
      /**
       * Discounts
       * @description The discounts on the plan.
       */
      discounts?: components['schemas']['Discount'][]
    }
    /** @description Resource create operation model. */
    PlanPhaseCreate: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /** @description Unique key among the plan phases. Used to reference the phase in the subscription & plan. */
      key: string
      /**
       * Rate cards
       * @description The rate cards of the plan.
       */
      rateCards: components['schemas']['RateCard'][]
      /**
       * Start after
       * Format: duration
       * @description The time after which the plan starts compared to subscription start
       * @example P1Y1D
       */
      startAfter: string | null
      /**
       * Discounts
       * @description The discounts on the plan.
       */
      discounts?: components['schemas']['Discount'][]
    }
    /** @description Paginated response */
    PlanPhasePaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['PlanPhase'][]
    }
    /** @description Resource create or update operation model. */
    PlanPhaseUpdate: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name?: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Rate cards
       * @description The rate cards of the plan.
       */
      rateCards?: components['schemas']['RateCard'][]
      /**
       * Start after
       * Format: duration
       * @description The time after which the plan starts compared to subscription start
       * @example P1Y1D
       */
      startAfter?: string | null
      /**
       * Discounts
       * @description The discounts on the plan.
       */
      discounts?: components['schemas']['Discount'][]
    }
    /** @description References an exact plan. */
    PlanReference: {
      /** @description The plan key. */
      key: string
      /** @description The plan version. */
      version: number
    }
    /**
     * @description The status of a plan.
     * @enum {string}
     */
    PlanStatus: 'draft' | 'active' | 'archived' | 'scheduled'
    /** @description Resource create or update operation model. */
    PlanUpdate: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name?: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Plan phases
       * @description The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
       * A phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.
       */
      phases?: components['schemas']['PlanPhase'][]
    }
    /**
     * @description A consumer portal token.
     *
     * Validator doesn't obey required for readOnly properties
     * See: https://github.com/stoplightio/spectral/issues/1274
     */
    PortalToken: {
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id?: string
      /** @example customer-1 */
      subject: string
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      expiresAt?: string
      expired?: boolean
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T01:01:01.001Z"
       */
      createdAt?: string
      /**
       * @description The token is only returned at creation.
       * @example om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo
       */
      token?: string
      /**
       * @description Optional, if defined only the specified meters will be allowed.
       * @example [
       *   "tokens_total"
       * ]
       */
      allowedMeterSlugs?: string[]
    }
    /** @description One or more conditions given in the request header fields evaluated to false when tested on the server. */
    PreconditionFailedProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description The payment term of a flat price.
     * One of: in_advance or in_arrears.
     * @enum {string}
     */
    PricePaymentTerm: 'in_advance' | 'in_arrears'
    /**
     * @description A price tier.
     * At least one price component is required in each tier.
     */
    PriceTier: {
      /**
       * Up to quantity
       * Format: double
       * @description Up to and including to this quantity will be contained in the tier.
       * If null, the tier is open-ended.
       */
      upToAmount: number | null
      /**
       * Flat price component
       * @description The flat price component of the tier.
       */
      flatPrice: components['schemas']['FlatPrice'] | null
      /**
       * Unit price component
       * @description The unit price component of the tier.
       */
      unitPrice: components['schemas']['UnitPrice'] | null
    }
    /** @description Paginated response */
    ProfilePaginatedResponse: {
      /**
       * @description The items in the current page.
       * @example 500
       */
      totalCount: number
      /**
       * @description The items in the current page.
       * @example 1
       */
      page: number
      /**
       * @description The items in the current page.
       * @example 100
       */
      pageSize: number
      /** @description The items in the current page. */
      items: components['schemas']['BillingProfile'][]
    }
    /** @description A rate card defines the pricing and entitlement of a feature or service. */
    RateCard:
      | components['schemas']['RateCardFlatFee']
      | components['schemas']['RateCardUsageBased']
    /** @description Entitlement template of a boolean entitlement. */
    RateCardBooleanEntitlement: {
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /** @enum {string} */
      type: 'boolean'
    }
    /**
     * @description Entitlement templates are used to define the entitlements of a plan.
     * Features are omitted from the entitlement template, as they are defined in the rate card.
     */
    RateCardEntitlement:
      | components['schemas']['RateCardMeteredEntitlement']
      | components['schemas']['RateCardStaticEntitlement']
      | components['schemas']['RateCardBooleanEntitlement']
    /** @description A flat fee rate card defines a one-time purchase or a recurring fee. */
    RateCardFlatFee: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Key
       * @description A semi-unique identifier for the resource.
       */
      key: string
      /**
       * RateCard type
       * @description The type of the RateCard.
       * @enum {string}
       */
      type: 'flat_fee'
      /**
       * Feature key
       * @description The feature the customer is entitled to use.
       */
      featureKey?: string
      entitlementTemplate?: components['schemas']['RateCardEntitlement']
      /**
       * Tax config
       * @description The tax config of the rate card.
       * When undefined, the tax config of the feature or the default tax config of the plan is used.
       */
      taxConfig?: components['schemas']['TaxConfig']
      /**
       * Billing cadence
       * Format: duration
       * @description The billing cadence of the rate card.
       * When null it means it is a one time fee.
       */
      billingCadence: string | null
      /**
       * Price
       * @description The price of the rate card.
       * When null, the feature or service is free.
       * @example {}
       */
      price: components['schemas']['FlatPriceWithPaymentTerm'] | null
    }
    /** @description A flat fee rate card defines a one-time purchase or a recurring fee. */
    RateCardFlatFeeUpdateItem: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * RateCard type
       * @description The type of the RateCard.
       * @enum {string}
       */
      type: 'flat_fee'
      /**
       * Feature key
       * @description The feature the customer is entitled to use.
       */
      featureKey?: string
      entitlementTemplate?: components['schemas']['RateCardEntitlement']
      /**
       * Tax config
       * @description The tax config of the rate card.
       * When undefined, the tax config of the feature or the default tax config of the plan is used.
       */
      taxConfig?: components['schemas']['TaxConfig']
      /**
       * Billing cadence
       * Format: duration
       * @description The billing cadence of the rate card.
       * When null it means it is a one time fee.
       */
      billingCadence: string | null
      /**
       * Price
       * @description The price of the rate card.
       * When null, the feature or service is free.
       * @example {}
       */
      price: components['schemas']['FlatPriceWithPaymentTerm'] | null
    }
    /** @description The entitlement template with a metered entitlement. */
    RateCardMeteredEntitlement: {
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /** @enum {string} */
      type: 'metered'
      /**
       * Soft limit
       * @description If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
       * @default false
       */
      isSoftLimit?: boolean
      /**
       * Initial grant amount
       * Format: double
       * @description You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
       * If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
       * That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
       * Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
       */
      issueAfterReset?: number
      /**
       * Issue grant after reset priority
       * Format: uint8
       * @description Defines the grant priority for the default grant.
       * @default 1
       */
      issueAfterResetPriority?: number
      /**
       * Preserve overage at reset
       * @description If true, the overage is preserved at reset. If false, the usage is reset to 0.
       * @default false
       */
      preserveOverageAtReset?: boolean
      /**
       * Usage Period
       * Format: duration
       * @description The interval of the metered entitlement.
       * Defaults to the billing cadence of the rate card.
       */
      usagePeriod?: string
    }
    /** @description Entitlement template of a static entitlement. */
    RateCardStaticEntitlement: {
      /** @description Additional metadata for the feature. */
      metadata?: components['schemas']['Metadata']
      /** @enum {string} */
      type: 'static'
      /**
       * Format: json
       * @description The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
       * @example { "integrations": ["github"] }
       */
      config: string
    }
    /** @description A rate card defines the pricing and entitlement of a feature or service. */
    RateCardUpdateItem:
      | components['schemas']['RateCardFlatFeeUpdateItem']
      | components['schemas']['RateCardUsageBasedUpdateItem']
    /** @description A usage-based rate card defines a price based on usage. */
    RateCardUsageBased: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * Key
       * @description A semi-unique identifier for the resource.
       */
      key: string
      /**
       * RateCard type
       * @description The type of the RateCard.
       * @enum {string}
       */
      type: 'usage_based'
      /**
       * Feature key
       * @description The feature the customer is entitled to use.
       */
      featureKey?: string
      entitlementTemplate?: components['schemas']['RateCardEntitlement']
      /**
       * Tax config
       * @description The tax config of the rate card.
       * When undefined, the tax config of the feature or the default tax config of the plan is used.
       */
      taxConfig?: components['schemas']['TaxConfig']
      /**
       * Billing cadence
       * Format: duration
       * @description The billing cadence of the rate card.
       */
      billingCadence: string
      price:
        | ({
            type: 'RateCardUsageBased'
          } & Omit<components['schemas']['RateCardUsageBasedPrice'], 'type'>)
        | null
    }
    /** @description The price of the usage based rate card. */
    RateCardUsageBasedPrice:
      | components['schemas']['FlatPriceWithPaymentTerm']
      | components['schemas']['UnitPriceWithCommitments']
      | components['schemas']['TieredPriceWithCommitments']
    /** @description A usage-based rate card defines a price based on usage. */
    RateCardUsageBasedUpdateItem: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * RateCard type
       * @description The type of the RateCard.
       * @enum {string}
       */
      type: 'usage_based'
      /**
       * Feature key
       * @description The feature the customer is entitled to use.
       */
      featureKey?: string
      entitlementTemplate?: components['schemas']['RateCardEntitlement']
      /**
       * Tax config
       * @description The tax config of the rate card.
       * When undefined, the tax config of the feature or the default tax config of the plan is used.
       */
      taxConfig?: components['schemas']['TaxConfig']
      /**
       * Billing cadence
       * Format: duration
       * @description The billing cadence of the rate card.
       */
      billingCadence: string
      price:
        | ({
            type: 'RateCardUsageBasedUpdateItem'
          } & Omit<components['schemas']['RateCardUsageBasedPrice'], 'type'>)
        | null
    }
    /**
     * @description Recurring period with an interval and an anchor.
     * @example {
     *   "interval": "DAY",
     *   "anchor": "2023-01-01T01:01:01.001Z"
     * }
     */
    RecurringPeriod: {
      /**
       * Interval
       * @description The unit of time for the interval.
       */
      interval: components['schemas']['RecurringPeriodInterval']
      /**
       * Anchor time
       * Format: date-time
       * @description A date-time anchor to base the recurring period on.
       * @example "2023-01-01T01:01:01.001Z"
       */
      anchor: string
    }
    /**
     * @description Recurring period with an interval and an anchor.
     * @example {
     *   "interval": "DAY",
     *   "anchor": "2023-01-01T01:01:01.001Z"
     * }
     */
    RecurringPeriodCreateInput: {
      /**
       * Interval
       * @description The unit of time for the interval.
       */
      interval: components['schemas']['RecurringPeriodInterval']
      /**
       * Anchor time
       * Format: date-time
       * @description A date-time anchor to base the recurring period on.
       * @example "2023-01-01T01:01:01.001Z"
       */
      anchor?: string
    }
    /**
     * @description The unit of time for the interval.
     * One of: `day`, `week`, `month`, or `year`.
     * @enum {string}
     */
    RecurringPeriodInterval: 'DAY' | 'WEEK' | 'MONTH' | 'YEAR'
    /**
     * @description The direction of the phase shift when a phase is removed.
     * @enum {string}
     */
    RemovePhaseShifting: 'Next' | 'Prev'
    /** @description Reset parameters */
    ResetEntitlementUsageInput: {
      /**
       * Format: date-time
       * @description The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.
       * @example "2023-01-01T01:01:01.001Z"
       */
      effectiveAt?: string
      /**
       * @description Determines whether the usage period anchor is retained or reset to the effectiveAt time.
       * - If true, the usage period anchor is retained.
       * - If false, the usage period anchor is reset to the effectiveAt time.
       */
      retainAnchor?: boolean
      /**
       * @description Determines whether the overage is preserved or forgiven, overriding the entitlement's default behavior.
       * - If true, the overage is preserved.
       * - If false, the overage is forgiven.
       */
      preserveOverage?: boolean
    }
    /**
     * @description Sandbox app can be used for testing OpenMeter features.
     *
     * The app is not creating anything in external systems, thus it is safe to use for
     * verifying OpenMeter features.
     */
    SandboxApp: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description The marketplace listing that this installed app is based on. */
      listing: components['schemas']['MarketplaceListing']
      /** @description Status of the app connection. */
      status: components['schemas']['AppStatus']
      /**
       * @description The app's type is Sandbox.
       * @enum {string}
       */
      type: 'sandbox'
    }
    /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
    ServiceUnavailableProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description The order direction.
     * @enum {string}
     */
    SortOrder: 'ASC' | 'DESC'
    /**
     * @description A installed Stripe app object.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "type": "stripe",
     *   "name": "Stripe",
     *   "status": "ready",
     *   "listing": {
     *     "type": "stripe",
     *     "name": "Stripe",
     *     "description": "Stripe interation allows you to collect payments with Stripe.",
     *     "iconUrl": "/images/stripe.png",
     *     "capabilities": [
     *       {
     *         "type": "calculateTax",
     *         "key": "stripe_calculate_tax",
     *         "name": "Calculate Tax",
     *         "description": "Stripe Tax calculates tax portion of the invoices."
     *       },
     *       {
     *         "type": "invoiceCustomers",
     *         "key": "stripe_invoice_customers",
     *         "name": "Invoice Customers",
     *         "description": "Stripe invoices customers with due amount."
     *       },
     *       {
     *         "type": "collectPayments",
     *         "key": "stripe_collect_payments",
     *         "name": "Collect Payments",
     *         "description": "Stripe payments collects outstanding revenue with Stripe customer's default payment method."
     *       }
     *     ]
     *   },
     *   "createdAt": "2024-01-01T01:01:01.001Z",
     *   "updatedAt": "2024-01-01T01:01:01.001Z",
     *   "stripeAccountId": "acct_123456789",
     *   "livemode": true
     * }
     */
    StripeApp: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description The marketplace listing that this installed app is based on. */
      listing: components['schemas']['MarketplaceListing']
      /** @description Status of the app connection. */
      status: components['schemas']['AppStatus']
      /**
       * @description The app's type is Stripe.
       * @enum {string}
       */
      type: 'stripe'
      /** @description The Stripe account ID. */
      stripeAccountId: string
      /** @description Livemode, true if the app is in production mode. */
      livemode: boolean
    }
    /**
     * @description Stripe CheckoutSession.mode
     * @enum {string}
     */
    StripeCheckoutSessionMode: 'setup'
    /**
     * @description Stripe payment intent status.
     * @enum {string}
     */
    StripePaymentIntentStatus:
      | 'canceled'
      | 'processing'
      | 'requires_action'
      | 'requires_confirmation'
      | 'requires_payment_method'
      | 'succeeded'
    /** @description Stripe setup intent. */
    StripeSetupIntent: {
      /** @description The setup intent id. */
      id: string
      /** @description The setup intent status. */
      status: components['schemas']['StripePaymentIntentStatus']
      /** @description The setup intent payment method. */
      payment_method?: string
      /** @description The setup intent payment method types. */
      payment_method_types?: string[]
      /** @description The setup intent customer. */
      customer: string
      /** @description The setup intent metadata. */
      metadata: {
        [key: string]: string
      }
    }
    /** @description The tax config for Stripe. */
    StripeTaxConfig: {
      /**
       * Tax code
       * @description Product tax code.
       *
       * See: https://docs.stripe.com/tax/tax-codes
       * @example txcd_10000000
       */
      code: string
    }
    /** @description Stripe webhook event. */
    StripeWebhookEvent: {
      /** @description The event ID. */
      id: string
      /** @description The event type. */
      type: string
      /** @description Live mode. */
      livemode: boolean
      /**
       * Format: int32
       * @description The event created timestamp.
       */
      created: number
      /** @description The event data. */
      data: {
        object: components['schemas']['StripeSetupIntent']
      }
    }
    /** @description Stripe webhook response. */
    StripeWebhookResponse: {
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      namespaceId: string
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      appId: string
      /**
       * @description ULID (Universally Unique Lexicographically Sortable Identifier).
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      customerId?: string
    }
    /**
     * @description A subject is a unique identifier for a user or entity.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "key": "customer-id",
     *   "displayName": "Customer Name",
     *   "metadata": {
     *     "hubspotId": "123456"
     *   },
     *   "currentPeriodStart": "2023-01-01T00:00:00.000Z",
     *   "currentPeriodEnd": "2023-02-01T00:00:00.000Z",
     *   "stripeCustomerId": "cus_JMOlctsKV8"
     * }
     */
    Subject: {
      /**
       * @description A unique identifier for the subject.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * @description A unique, human-readable identifier for the subject.
       * @example customer-id
       */
      key: string
      /**
       * @description A human-readable display name for the subject.
       * @example Customer Name
       */
      displayName?: string | null
      /** @example {} */
      metadata?: {
        [key: string]: unknown
      } | null
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T00:00:00.000Z"
       */
      currentPeriodStart?: string
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-02-01T00:00:00.000Z"
       */
      currentPeriodEnd?: string
      /** @example cus_JMOlctsKV8 */
      stripeCustomerId?: string | null
    }
    /**
     * @description A subject is a unique identifier for a user or entity.
     * @example {
     *   "key": "customer-id",
     *   "displayName": "Customer Name",
     *   "metadata": {
     *     "hubspotId": "123456"
     *   },
     *   "currentPeriodStart": "2023-01-01T00:00:00.000Z",
     *   "currentPeriodEnd": "2023-02-01T00:00:00.000Z",
     *   "stripeCustomerId": "cus_JMOlctsKV8"
     * }
     */
    SubjectUpsert: {
      /**
       * @description A unique, human-readable identifier for the subject.
       * @example customer-id
       */
      key: string
      /**
       * @description A human-readable display name for the subject.
       * @example Customer Name
       */
      displayName?: string | null
      /** @example {} */
      metadata?: {
        [key: string]: unknown
      } | null
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-01-01T00:00:00.000Z"
       */
      currentPeriodStart?: string
      /**
       * Format: date-time
       * @description [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
       * @example "2023-02-01T00:00:00.000Z"
       */
      currentPeriodEnd?: string
      /** @example cus_JMOlctsKV8 */
      stripeCustomerId?: string | null
    }
    /** @description Subscription is an exact subscription instance. */
    Subscription: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * @description The customer ID of the subscription.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      customerId: string
      /** @description The base plan of the subscription. */
      plan: components['schemas']['PlanReference']
      /**
       * Currency
       * @description The currency code of the subscription.
       * Will be revised once we add multi currency support.
       * @default USD
       */
      currency: components['schemas']['CurrencyCode']
      /**
       * Format: date-time
       * @description If the subscription is canceled or otherwise have to end activeTo denotes the end date.
       * @example "2023-01-01T01:01:01.001Z"
       */
      activeTo?: string
    }
    /** @description Subscription item add operation. */
    SubscriptionEditAdd: {
      /** @enum {string} */
      op: 'add'
      path: string
      value: components['schemas']['SubscriptionPhaseCreate']
    }
    /** @description Subscription item add operation. */
    SubscriptionEditAddItem: {
      /** @enum {string} */
      op: 'add'
      path: string
      value: components['schemas']['RateCard']
    }
    /** @description Subscription item add operation. */
    SubscriptionEditAddUpdateItem: {
      /** @enum {string} */
      op: 'add'
      path: string
      value: components['schemas']['RateCardUpdateItem']
    }
    /** @description Subscription phase extend operation. */
    SubscriptionEditExtend: {
      /** @enum {string} */
      op: 'extend'
      path: string
      value: {
        /** Format: duration */
        extendBy: string
      }
    }
    /** @description Subscription phase remove operation. */
    SubscriptionEditRemoveItem: {
      /** @enum {string} */
      op: 'remove'
      path: string
    }
    /** @description Subscription phase remove operation. */
    SubscriptionEditRemoveUpdateItem: {
      /** @enum {string} */
      op: 'remove'
      path: string
    }
    /** @description Subscription item remove operation with a value. */
    SubscriptionEditRemoveWithValue: {
      /** @enum {string} */
      op: 'remove'
      path: string
      value: {
        shift: components['schemas']['RemovePhaseShifting']
      }
    }
    /** @description Expanded subscription */
    SubscriptionExpanded: {
      /**
       * ID
       * @description A unique identifier for the resource.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id: string
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * @description The customer ID of the subscription.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      customerId: string
      /** @description The base plan of the subscription. */
      plan: components['schemas']['PlanReference']
      /**
       * Currency
       * @description The currency code of the subscription.
       * Will be revised once we add multi currency support.
       * @default USD
       */
      currency: components['schemas']['CurrencyCode']
      /**
       * Format: date-time
       * @description If the subscription is canceled or otherwise have to end activeTo denotes the end date.
       * @example "2023-01-01T01:01:01.001Z"
       */
      activeTo?: string
      phases: components['schemas']['SubscriptionPhaseExpanded'][]
    }
    /** @description The actual contents of the Subscription, what the user gets, what they pay, etc... */
    SubscriptionItem: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /**
       * @description The identifier of the RateCard.
       * SubscriptionItem/RateCard can be identified, it has a reference:
       *
       * 1. If a Feature is associated with the SubscriptionItem, it is identified by the Feature
       * 1.1 It can be an ID reference, for an exact version of the Feature (Features can change across versions)
       * 1.2 It can be a Key reference, which always refers to the latest (active or inactive) version of a Feature
       *
       * 2. If a Feature is not associated with the SubscriptionItem, it is referenced by the Price
       *
       * We say “referenced by the Price” regardless of how a price itself is referenced, it colloquially makes sense to say “paying the same price for the same thing”. In practice this should be derived from what's printed on the invoice line-item.
       */
      key: string
      /**
       * Billing cadence
       * Format: duration
       * @description The billing cadence of the rate card.
       * When null, the rate card is a one-time purchase.
       */
      billingCandence: string | null
      /**
       * Price
       * @description The price of the rate card.
       * When null, the feature or service is free.
       * @example {}
       */
      price:
        | (components['schemas']['FlatPriceWithPaymentTerm'] | null)
        | (components['schemas']['UnitPriceWithCommitments'] | null)
        | (components['schemas']['TieredPriceWithCommitments'] | null)
      /** @description Describes what access is gained via the SubscriptionItem */
      included?: {
        /** @description The feature the customer is entitled to use. */
        feature: components['schemas']['Feature']
        entitlement?: components['schemas']['Entitlement']
      }
      /**
       * Tax config
       * @description The tax config of the Subscription Item.
       * When undefined, the tax config of the feature or the default tax config of the plan is used.
       */
      taxConfig?: components['schemas']['TaxConfig']
    }
    /** @description Subscription phase create input. */
    SubscriptionPhaseCreate: {
      /**
       * Start after
       * Format: duration
       * @description Interval after the subscription starts to transition to the phase.
       * When null, the phase starts immediately after the subscription starts.
       * @example P1Y1D
       */
      startAfter: string | null
      /**
       * Duration
       * Format: duration
       * @description The intended duration of the new phase.
       * @example P1M
       */
      duration: string
      /**
       * Discounts
       * @description The discounts on the plan.
       */
      discounts?: components['schemas']['DiscountUpdateItem'][]
    }
    /** @description Expanded subscription phase */
    SubscriptionPhaseExpanded: {
      /**
       * Display name
       * @description Human-readable name for the resource. Between 1 and 256 characters.
       */
      name: string
      /**
       * Description
       * @description Optional description of the resource. Maximum 1024 characters.
       */
      description?: string
      /**
       * Metadata
       * @description Additional metadata for the resource.
       */
      metadata?: components['schemas']['Metadata']
      /**
       * Creation Time
       * Format: date-time
       * @description Timestamp of when the resource was created.
       * @example "2024-01-01T01:01:01.001Z"
       */
      createdAt: string
      /**
       * Last Update Time
       * Format: date-time
       * @description Timestamp of when the resource was last updated.
       * @example "2024-01-01T01:01:01.001Z"
       */
      updatedAt: string
      /**
       * Deletion Time
       * Format: date-time
       * @description Timestamp of when the resource was permanently deleted.
       * @example "2024-01-01T01:01:01.001Z"
       */
      deletedAt?: string
      /** @description A locally unique identifier for the resource. */
      key: string
      /**
       * Duration
       * Format: duration
       * @description The intended duration of the new phase.
       * @example P1M
       */
      duration: string
      /**
       * Discounts
       * @description The discounts on the plan.
       */
      discounts?: components['schemas']['Discount'][]
      /**
       * Format: date-time
       * @description The time from which the phase is active.
       * @example "2023-01-01T01:01:01.001Z"
       */
      activeFrom: string
      items: components['schemas']['SubscriptionItem'][]
    }
    /** @description Operational webhook reqeuest sent by Svix. */
    SvixOperationalWebhookRequest: {
      /**
       * Operational Webhook Type
       * @description The type of the Svix operational webhook request.
       * @enum {string}
       */
      type:
        | 'endpoint.created'
        | 'endpoint.deleted'
        | 'endpoint.disabled'
        | 'endpoint.updated'
        | 'message.attempt.exhausted'
        | 'message.attempt.failing'
        | 'message.attempt.recovered'
      /**
       * Operational Webhook Payload
       * @description The payload of the Svix operational webhook request.
       */
      data: {
        [key: string]: string
      }
    }
    /** @description Set of provider specific tax configs. */
    TaxConfig: {
      /**
       * Stripe tax config
       * @description Stripe tax config.
       */
      stripe?: components['schemas']['StripeTaxConfig']
    }
    /**
     * @description The mode of the tiered price.
     * @enum {string}
     */
    TieredPriceMode: 'volume' | 'graduated'
    /** @description Tiered price with spend commitments. */
    TieredPriceWithCommitments: {
      /** @enum {string} */
      type: 'tiered'
      /**
       * Mode
       * @description Defines if the tiering mode is volume-based or graduated:
       * - In `volume`-based tiering, the maximum quantity within a period determines the per unit price.
       * - In `graduated` tiering, pricing can change as the quantity grows.
       */
      mode: components['schemas']['TieredPriceMode']
      /**
       * Tiers
       * @description The tiers of the tiered price.
       * At least one price component is required in each tier.
       */
      tiers: components['schemas']['PriceTier'][]
      /**
       * Minimum amount
       * @description The customer is committed to spend at least the amount.
       */
      minimumAmount?: components['schemas']['Numeric']
      /**
       * Maximum amount
       * @description The customer is limited to spend at most the amount.
       */
      maximumAmount?: components['schemas']['Numeric']
    }
    /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
    UnauthorizedProblemResponse: components['schemas']['UnexpectedProblemResponse']
    /**
     * @description A Problem Details object (RFC 7807).
     * Additional properties specific to the problem type may be present.
     */
    UnexpectedProblemResponse: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @default about:blank
       * @example about:blank
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int16
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status?: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example The request body must be a JSON object.
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance: string
      [key: string]: (string | number) | undefined
    }
    /** @description Unit price. */
    UnitPrice: {
      /** @enum {string} */
      type: 'unit'
      /** @description The amount of the unit price. */
      amount: components['schemas']['Numeric']
    }
    /** @description Unit price with spend commitments. */
    UnitPriceWithCommitments: {
      /** @enum {string} */
      type: 'unit'
      /** @description The amount of the unit price. */
      amount: components['schemas']['Numeric']
      /**
       * Minimum amount
       * @description The customer is committed to spend at least the amount.
       */
      minimumAmount?: components['schemas']['Numeric']
      /**
       * Maximum amount
       * @description The customer is limited to spend at most the amount.
       */
      maximumAmount?: components['schemas']['Numeric']
    }
    /**
     * @description Aggregation window size.
     * @enum {string}
     */
    WindowSize: 'MINUTE' | 'HOUR' | 'DAY'
    /** @description The windowed balance history. */
    WindowedBalanceHistory: {
      /**
       * @description The windowed balance history.
       * - It only returns rows for windows where there was usage.
       * - The windows are inclusive at their start and exclusive at their end.
       * - The last window may be smaller than the window size and is inclusive at both ends.
       */
      windowedHistory: components['schemas']['BalanceHistoryWindow'][]
      /** @description Grant burndown history. */
      burndownHistory: components['schemas']['GrantBurnDownHistorySegment'][]
    }
  }
  responses: never
  parameters: {
    'BillingInvoiceListParams.expand'?: components['schemas']['BillingInvoiceExpand'][]
    'BillingInvoiceListParams.extendedStatuses'?: components['schemas']['BillingInvoiceExtendedStatus'][]
    'BillingInvoiceListParams.issuedAfter'?: string
    'BillingInvoiceListParams.issuedBefore'?: string
    'BillingInvoiceListParams.statuses'?: components['schemas']['BillingInvoiceStatus'][]
    /** @description The order direction. */
    'CustomerOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'CustomerOrderByOrdering.orderBy'?: components['schemas']['CustomerOrderBy']
    /** @description The order direction. */
    'CustomerOverrideOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'CustomerOverrideOrderByOrdering.orderBy'?: components['schemas']['BillingCustomerOverrideOrderBy']
    /** @description The order direction. */
    'EntitlementOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'EntitlementOrderByOrdering.orderBy'?: components['schemas']['EntitlementOrderBy']
    /** @description The order direction. */
    'FeatureOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'FeatureOrderByOrdering.orderBy'?: components['schemas']['FeatureOrderBy']
    /** @description The order direction. */
    'GrantOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'GrantOrderByOrdering.orderBy'?: components['schemas']['GrantOrderBy']
    /** @description The order direction. */
    'InvoiceOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'InvoiceOrderByOrdering.orderBy'?: components['schemas']['BillingInvoiceOrderBy']
    /**
     * @description Number of items to return.
     *
     * Default is 100.
     */
    'LimitOffset.limit'?: number
    /**
     * @description Number of items to skip.
     *
     * Default is 0.
     */
    'LimitOffset.offset'?: number
    /** @description The type of the app to install. */
    'MarketplaceApiKeyInstallRequest.type': components['schemas']['AppType']
    /** @description The type of the app to install. */
    'MarketplaceOAuth2InstallAuthorizeRequest.type': components['schemas']['AppType']
    /** @description Simple filter for group bys with exact match. */
    'MeterQuery.filterGroupBy'?: {
      [key: string]: string
    }
    /**
     * @description Start date-time in RFC 3339 format.
     *
     * Inclusive.
     */
    'MeterQuery.from'?: string
    /**
     * @description If not specified a single aggregate will be returned for each subject and time window.
     * `subject` is a reserved group by value.
     */
    'MeterQuery.groupBy'?: string[]
    /** @description Filtering by multiple subjects. */
    'MeterQuery.subject'?: string[]
    /**
     * @description End date-time in RFC 3339 format.
     *
     * Inclusive.
     */
    'MeterQuery.to'?: string
    /** @description If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group. */
    'MeterQuery.windowSize'?: components['schemas']['WindowSize']
    /**
     * @description The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
     * If not specified, the UTC timezone will be used.
     */
    'MeterQuery.windowTimeZone'?: string
    /** @description The order direction. */
    'NotificationChannelOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'NotificationChannelOrderByOrdering.orderBy'?: components['schemas']['NotificationChannelOrderBy']
    /** @description The order direction. */
    'NotificationEventOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'NotificationEventOrderByOrdering.orderBy'?: components['schemas']['NotificationEventOrderBy']
    /** @description The order direction. */
    'NotificationRuleOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'NotificationRuleOrderByOrdering.orderBy'?: components['schemas']['NotificationRuleOrderBy']
    /**
     * @description Error code.
     * Required with the error response.
     */
    'OAuth2AuthorizationCodeGrantErrorParams.error'?: components['schemas']['OAuth2AuthorizationCodeGrantErrorType']
    /**
     * @description Optional human-readable text providing additional information,
     * used to assist the client developer in understanding the error that occurred.
     */
    'OAuth2AuthorizationCodeGrantErrorParams.error_description'?: string
    /**
     * @description Optional uri identifying a human-readable web page with
     * information about the error, used to provide the client
     * developer with additional information about the error
     */
    'OAuth2AuthorizationCodeGrantErrorParams.error_uri'?: string
    /**
     * @description Authorization code which the client will later exchange for an access token.
     * Required with the success response.
     */
    'OAuth2AuthorizationCodeGrantSuccessParams.code'?: string
    /**
     * @description Required if the "state" parameter was present in the client authorization request.
     * The exact value received from the client:
     *
     * Unique, randomly generated, opaque, and non-guessable string that is sent
     * when starting an authentication request and validated when processing the response.
     */
    'OAuth2AuthorizationCodeGrantSuccessParams.state'?: string
    /** @description The page number. */
    'PaginatedQuery.page'?: number
    /** @description The number of items in the page. */
    'PaginatedQuery.pageSize'?: number
    /**
     * @description Start date-time in RFC 3339 format.
     *
     * Inclusive.
     */
    'Pagination.page'?: number
    /**
     * @description Number of items per page.
     *
     * Default is 100.
     */
    'Pagination.pageSize'?: number
    /** @description The order direction. */
    'PhasesOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'PhasesOrderByOrdering.orderBy'?: components['schemas']['PhasesOrderBy']
    /** @description The order direction. */
    'PlanOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'PlanOrderByOrdering.orderBy'?: components['schemas']['PlanOrderBy']
    /** @description The order direction. */
    'ProfileOrderByOrdering.order'?: components['schemas']['SortOrder']
    /** @description The order by field. */
    'ProfileOrderByOrdering.orderBy'?: components['schemas']['BillingProfileOrderBy']
    /** @description Include deleted customers. */
    'queryCustomerList.includeDeleted'?: boolean
    /**
     * @description Filter customers by name.
     * Case-insensitive partial match.
     */
    'queryCustomerList.name'?: string
    /**
     * @description Filter customers by primary email.
     * Case-insensitive partial match.
     */
    'queryCustomerList.primaryEmail'?: string
    /**
     * @description Filter customers by usage attribution subject.
     * Case-insensitive partial match.
     */
    'queryCustomerList.subject'?: string
  }
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /** @description List apps. */
  listApps: {
    parameters: {
      query?: {
        page?: components['parameters']['PaginatedQuery.page']
        pageSize?: components['parameters']['PaginatedQuery.pageSize']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['AppList']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get the app. */
  getApp: {
    parameters: {
      path: {
        id: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['App']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Uninstall an app. */
  uninstallApp: {
    parameters: {
      path: {
        id: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Stripe webhook. */
  appStripeWebhook: {
    parameters: {
      path: {
        id: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['StripeWebhookEvent']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['StripeWebhookResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List customer overrides
   * @description List customer overrides
   */
  billingListCustomerOverrides: {
    parameters: {
      query?: {
        billingProfile?: string[]
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        offset?: components['parameters']['LimitOffset.offset']
        limit?: components['parameters']['LimitOffset.limit']
        order?: components['parameters']['CustomerOverrideOrderByOrdering.order']
        orderBy?: components['parameters']['CustomerOverrideOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['CustomerOverridePaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get a customer override
   * @description Get a customer override by id.
   */
  billingGetCustomerOverrideById: {
    parameters: {
      path: {
        customerId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingCustomerOverride']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create/update a customer override
   * @description Create/update a new customer override.
   */
  billingUpsertCustomerOverride: {
    parameters: {
      path: {
        customerId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['BillingCustomerWorkflowOverrideCreate']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingCustomerOverride']
        }
      }
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['BillingCustomerOverride']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Delete a customer override
   * @description Delete a customer override by id.
   */
  billingDeleteCustomerOverride: {
    parameters: {
      path: {
        customerId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List invoices
   * @description List invoices
   */
  billingListInvoices: {
    parameters: {
      query?: {
        customers?: string[]
        statuses?: components['parameters']['BillingInvoiceListParams.statuses']
        extendedStatuses?: components['parameters']['BillingInvoiceListParams.extendedStatuses']
        issuedAfter?: components['parameters']['BillingInvoiceListParams.issuedAfter']
        issuedBefore?: components['parameters']['BillingInvoiceListParams.issuedBefore']
        expand?: components['parameters']['BillingInvoiceListParams.expand']
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        offset?: components['parameters']['LimitOffset.offset']
        limit?: components['parameters']['LimitOffset.limit']
        order?: components['parameters']['InvoiceOrderByOrdering.order']
        orderBy?: components['parameters']['InvoiceOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['InvoicePaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List invoices
   * @description List invoices for a specific customer
   */
  billingListInvoicesByCustomer: {
    parameters: {
      query?: {
        statuses?: components['parameters']['BillingInvoiceListParams.statuses']
        extendedStatuses?: components['parameters']['BillingInvoiceListParams.extendedStatuses']
        issuedAfter?: components['parameters']['BillingInvoiceListParams.issuedAfter']
        issuedBefore?: components['parameters']['BillingInvoiceListParams.issuedBefore']
        expand?: components['parameters']['BillingInvoiceListParams.expand']
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        offset?: components['parameters']['LimitOffset.offset']
        limit?: components['parameters']['LimitOffset.limit']
        order?: components['parameters']['InvoiceOrderByOrdering.order']
        orderBy?: components['parameters']['InvoiceOrderByOrdering.orderBy']
      }
      path: {
        customerId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['InvoicePaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create an invoice
   * @description Create a new invoice from the pending line items.
   *
   * This should be only called if for some reason we need to invoice a customer outside of the normal billing cycle.
   *
   * When creating an invoice, the pending line items will be marked as invoiced and the invoice will be created with the total amount of the pending items.
   *
   * New pending line items will be created for the period between now() and the next billing cycle's begining date for any metered item.
   *
   * The call can return multiple invoices if the pending line items are in different currencies.
   */
  billingCreateInvoice: {
    parameters: {
      path: {
        customerId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['BillingInvoiceCreateInput']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['BillingInvoice'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get an invoice
   * @description Get an invoice by ID.
   */
  billingGetInvoiceByCustomerInvoiceId: {
    parameters: {
      query: {
        expand: components['schemas']['BillingInvoiceExpand'][]
      }
      path: {
        customerId: string
        invoiceId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingInvoice']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Delete an invoice
   * @description Delete an invoice
   *
   * Only invoices that are in the draft (or earlier) status can be deleted.
   */
  billingDeleteInvoiceByCustomerInvoiceId: {
    parameters: {
      path: {
        customerId: string
        invoiceId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Advance the invoice's state to the next status
   * @description Advance the invoice's state to the next status.
   *
   * The call doesn't "approve the invoice", it only advances the invoice to the next status if the transition would be automatic.
   *
   * The action can be called when the invoice's statusDetails' actions field contain the "advance" action.
   */
  billingInvoiceAdvance: {
    parameters: {
      path: {
        customerId: string
        invoiceId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingInvoice']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Send the invoice to the customer
   * @description Approve an invoice and start executing the payment workflow.
   *
   * This call instantly sends the invoice to the customer using the configured billing profile app.
   *
   * This call is valid in two invoice statuses:
   * - `draft`: the invoice will be sent to the customer, the invluce state becomes issued
   * - `manual_approval_needed`: the invoice will be sent to the customer, the invoice state becomes issued
   */
  billingApproveInvoice: {
    parameters: {
      path: {
        customerId: string
        invoiceId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingInvoice']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Update an invoice line
   * @description Update an invoice line
   */
  billingUpdateInvoiceLine: {
    parameters: {
      path: {
        customerId: string
        invoiceId: string
        lineId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['BillingInvoiceLineCreateOrUpdate']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingInvoiceLine']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Delete an invoice line
   * @description Delete an invoice line
   */
  billingDeleteInvoiceLine: {
    parameters: {
      path: {
        customerId: string
        invoiceId: string
        lineId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Retry advancing the invoice after a failed attempt.
   * @description Retry advancing the invoice after a failed attempt.
   *
   * The action can be called when the invoice's statusDetails' actions field contain the "retry" action.
   */
  billingInvoiceRetry: {
    parameters: {
      path: {
        customerId: string
        invoiceId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingInvoice']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Recalculate an invoice's tax amounts
   * @description Recalculate an invoice's tax amounts (using the app set in the customer's billing profile)
   *
   * Note: charges might apply, depending on the tax provider.
   */
  billingRecalculateInvoiceTax: {
    parameters: {
      path: {
        customerId: string
        invoiceId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingInvoice']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Void an invoice
   * @description Void an invoice
   *
   * Only invoices that have been alread issued can be voided.
   *
   * Voiding an invoice will mark it as voided, the user can specify how to handle the voided line items.
   */
  billingVoidInvoice: {
    parameters: {
      path: {
        customerId: string
        invoiceId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['BillingVoidInvoiceInput']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingInvoice']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create line items
   * @description Create a new pending line item (charge).
   *
   * This call is used to create a new pending line item for the customer without explicitly
   * assigning it to an invoice.
   *
   * The line item will be either allocated to an existing invoice in gathering state or a new invoice is
   * created for the line item.
   *
   * A new invoice will be created if:
   * - there is no invoice in gathering state
   * - the currency of the line item doesn't match the currency of any invoices in gathering state
   */
  billingCreateLineByCustomer: {
    parameters: {
      path: {
        customerId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['BillingCreateLinesRequest']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['BillingCreateLineResult']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List all billing profiles */
  billingListProfiles: {
    parameters: {
      query?: {
        includeArchived?: boolean
        expand?: components['schemas']['BillingProfileExpand'][]
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        offset?: components['parameters']['LimitOffset.offset']
        limit?: components['parameters']['LimitOffset.limit']
        order?: components['parameters']['ProfileOrderByOrdering.order']
        orderBy?: components['parameters']['ProfileOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['ProfilePaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create a new billing profile
   * @description Create a new billing profile
   *
   * Billing profiles are representations of a customer's billing information. Customer overrides
   * can be applied to a billing profile to customize the billing behavior for a specific customer.
   */
  billingCreateProfile: {
    requestBody: {
      content: {
        'application/json': components['schemas']['BillingProfileCreateInput']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['BillingProfile']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get a billing profile by ID
   * @description Get a billing profile by ID
   */
  billingGetProfile: {
    parameters: {
      query?: {
        expand?: components['schemas']['BillingProfileExpand'][]
      }
      path: {
        id: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingProfile']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Update a billing profile
   * @description Update a billing profile
   */
  billingUpdateProfile: {
    parameters: {
      path: {
        id: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['BillingProfileCreateOrUpdate']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['BillingProfile']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Archive a billing profile
   * @description Archive a billing profile
   */
  billingArchiveProfile: {
    parameters: {
      path: {
        id: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List customers. */
  listCustomers: {
    parameters: {
      query?: {
        order?: components['parameters']['CustomerOrderByOrdering.order']
        orderBy?: components['parameters']['CustomerOrderByOrdering.orderBy']
        includeDeleted?: components['parameters']['queryCustomerList.includeDeleted']
        name?: components['parameters']['queryCustomerList.name']
        primaryEmail?: components['parameters']['queryCustomerList.primaryEmail']
        subject?: components['parameters']['queryCustomerList.subject']
        page?: components['parameters']['PaginatedQuery.page']
        pageSize?: components['parameters']['PaginatedQuery.pageSize']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['CustomerList']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Create a new customer. */
  createCustomer: {
    requestBody: {
      content: {
        'application/json': components['schemas']['Customer']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get a customer by ID. */
  getCustomer: {
    parameters: {
      path: {
        id: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Update a customer by ID. */
  updateCustomer: {
    parameters: {
      path: {
        id: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['Customer']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Delete a customer by ID. */
  deleteCustomer: {
    parameters: {
      path: {
        id: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Customer']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get event metrics
   * @description Returns debug metrics (in OpenMetrics format) like the number of ingested events since mindnight UTC.
   *
   * The OpenMetrics Counter(s) reset every day at midnight UTC.
   */
  getDebugMetrics: {
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'text/plain': string
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List all entitlements
   * @description List all entitlements for all the subjects and features. This endpoint is intended for administrative purposes only.
   * To fetch the entitlements of a specific subject please use the /api/v1/subjects/{subjectKeyOrID}/entitlements endpoint.
   * If page is provided that takes precedence and the paginated response is returned.
   */
  listEntitlements: {
    parameters: {
      query?: {
        /**
         * @description Filtering by multiple features.
         *
         * Usage: `?feature=feature-1&feature=feature-2`
         */
        feature?: string[]
        /**
         * @description Filtering by multiple subjects.
         *
         * Usage: `?subject=customer-1&subject=customer-2`
         */
        subject?: string[]
        /**
         * @description Filtering by multiple entitlement types.
         *
         * Usage: `?entitlementType=metered&entitlementType=boolean`
         */
        entitlementType?: components['schemas']['EntitlementType'][]
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        offset?: components['parameters']['LimitOffset.offset']
        limit?: components['parameters']['LimitOffset.limit']
        order?: components['parameters']['EntitlementOrderByOrdering.order']
        orderBy?: components['parameters']['EntitlementOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['ListEntitlementsResult']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get entitlement by id. */
  getEntitlementById: {
    parameters: {
      path: {
        entitlementId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List ingested events
   * @description List ingested events within a time range.
   *
   * If the from query param is not provided it defaults to last 72 hours.
   */
  listEvents: {
    parameters: {
      query?: {
        /**
         * @description Start date-time in RFC 3339 format.
         *
         * Inclusive.
         */
        ingestedAtFrom?: string
        /**
         * @description End date-time in RFC 3339 format.
         *
         * Inclusive.
         */
        ingestedAtTo?: string
        /**
         * @description If not provided lists all events.
         *
         * If provided with true, only list events with processing error.
         *
         * If provided with false, only list events without processing error.
         */
        hasError?: boolean
        /**
         * @description The event ID.
         *
         * Accepts partial ID.
         */
        id?: string
        /**
         * @description The event subject.
         *
         * Accepts partial subject.
         */
        subject?: string
        /**
         * @description Start date-time in RFC 3339 format.
         *
         * Inclusive.
         */
        from?: string
        /**
         * @description End date-time in RFC 3339 format.
         *
         * Inclusive.
         */
        to?: string
        /** @description Number of events to return. */
        limit?: number
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['IngestedEvent'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Ingests an event or batch of events following the CloudEvents specification. */
  ingestEvents: {
    requestBody: {
      content: {
        'application/cloudevents+json': components['schemas']['Event']
        'application/cloudevents-batch+json': components['schemas']['Event'][]
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/cloudevents+json': components['schemas']['Event']
          'application/cloudevents-batch+json': components['schemas']['Event'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List features. */
  listFeatures: {
    parameters: {
      query?: {
        /** @description Filter by meterSlug */
        meterSlug?: string[]
        /** @description Filter by meterGroupByFilters */
        includeArchived?: boolean
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        offset?: components['parameters']['LimitOffset.offset']
        limit?: components['parameters']['LimitOffset.limit']
        order?: components['parameters']['FeatureOrderByOrdering.order']
        orderBy?: components['parameters']['FeatureOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['ListFeaturesResult']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Features are either metered or static. A feature is metered if meterSlug is provided at creation.
   * For metered features you can pass additional filters that will be applied when calculating feature usage, based on the meter's groupBy fields.
   * Only meters with SUM and COUNT aggregation are supported for features.
   * Features cannot be updated later, only archived.
   */
  createFeature: {
    requestBody: {
      content: {
        'application/json': components['schemas']['FeatureCreateInputs']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get a feature by ID. */
  getFeature: {
    parameters: {
      path: {
        featureId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Feature']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Archive a feature by ID.
   *
   * Once a feature is archived it cannot be unarchived. If a feature is archived, new entitlements cannot be created for it, but archiving the feature does not affect existing entitlements.
   * This means, if you want to create a new feature with the same key, and then create entitlements for it, the previous entitlements have to be deleted first on a per subject basis.
   */
  deleteFeature: {
    parameters: {
      path: {
        featureId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description List all grants for all the subjects and entitlements. This endpoint is intended for administrative purposes only.
   * To fetch the grants of a specific entitlement please use the /api/v1/subjects/{subjectKeyOrID}/entitlements/{entitlementOrFeatureID}/grants endpoint.
   * If page is provided that takes precedence and the paginated response is returned.
   */
  listGrants: {
    parameters: {
      query?: {
        /**
         * @description Filtering by multiple features.
         *
         * Usage: `?feature=feature-1&feature=feature-2`
         */
        feature?: string[]
        /**
         * @description Filtering by multiple subjects.
         *
         * Usage: `?subject=customer-1&subject=customer-2`
         */
        subject?: string[]
        /** @description Include deleted */
        includeDeleted?: boolean
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        offset?: components['parameters']['LimitOffset.offset']
        limit?: components['parameters']['LimitOffset.limit']
        order?: components['parameters']['GrantOrderByOrdering.order']
        orderBy?: components['parameters']['GrantOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json':
            | components['schemas']['EntitlementGrant'][]
            | components['schemas']['GrantPaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Voiding a grant means it is no longer valid, it doesn't take part in further balance calculations. Voiding a grant does not retroactively take effect, meaning any usage that has already been attributed to the grant will remain, but future usage cannot be burnt down from the grant.
   * For example, if you have a single grant for your metered entitlement with an initial amount of 100, and so far 60 usage has been metered, the grant (and the entitlement itself) would have a balance of 40. If you then void that grant, balance becomes 0, but the 60 previous usage will not be affected.
   */
  voidGrant: {
    parameters: {
      path: {
        grantId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Create checkout session. */
  createStripeCheckoutSession: {
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateStripeCheckoutSessionRequest']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['CreateStripeCheckoutSessionResult']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List available apps of the app marketplace. */
  listMarketplaceListings: {
    parameters: {
      query?: {
        page?: components['parameters']['PaginatedQuery.page']
        pageSize?: components['parameters']['PaginatedQuery.pageSize']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['MarketplaceListingList']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get a marketplace listing by type. */
  getMarketplaceListing: {
    parameters: {
      path: {
        type: components['schemas']['AppType']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['MarketplaceListing']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Install an marketplace via API Key. */
  marketplaceAppAPIKeyInstall: {
    parameters: {
      path: {
        type: components['parameters']['MarketplaceApiKeyInstallRequest.type']
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description The API key for the provider.
           * For example, the Stripe API key.
           */
          apiKey: string
          /**
           * @description Name of the application to install.
           *
           * If not set defaults to the marketplace item's description.
           */
          name?: string
        }
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['AppBase']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Install an app via OAuth.
   * Returns a URL to start the OAuth 2.0 flow.
   */
  marketplaceOAuth2InstallGetURL: {
    parameters: {
      path: {
        type: components['schemas']['AppType']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['ClientAppStartResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Authorize OAuth2 code.
   * Verifies the OAuth code and exchanges it for a token and refresh token
   */
  marketplaceOAuth2InstallAuthorize: {
    parameters: {
      query?: {
        state?: components['parameters']['OAuth2AuthorizationCodeGrantSuccessParams.state']
        code?: components['parameters']['OAuth2AuthorizationCodeGrantSuccessParams.code']
        error?: components['parameters']['OAuth2AuthorizationCodeGrantErrorParams.error']
        error_description?: components['parameters']['OAuth2AuthorizationCodeGrantErrorParams.error_description']
        error_uri?: components['parameters']['OAuth2AuthorizationCodeGrantErrorParams.error_uri']
      }
      path: {
        type: components['parameters']['MarketplaceOAuth2InstallAuthorizeRequest.type']
      }
    }
    responses: {
      /** @description Redirection */
      303: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List meters. */
  listMeters: {
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Meter'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Create a meter. */
  createMeter: {
    requestBody: {
      content: {
        'application/json': components['schemas']['MeterCreate']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get a meter by ID or slug. */
  getMeter: {
    parameters: {
      path: {
        meterIdOrSlug: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Delete a meter. */
  deleteMeter: {
    parameters: {
      path: {
        meterIdOrSlug: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Query meter for usage. Query meter for usage. */
  queryMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['MeterQuery.from']
        to?: components['parameters']['MeterQuery.to']
        windowSize?: components['parameters']['MeterQuery.windowSize']
        windowTimeZone?: components['parameters']['MeterQuery.windowTimeZone']
        subject?: components['parameters']['MeterQuery.subject']
        filterGroupBy?: components['parameters']['MeterQuery.filterGroupBy']
        groupBy?: components['parameters']['MeterQuery.groupBy']
      }
      path: {
        meterIdOrSlug: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List subjects for a meter. */
  listMeterSubjects: {
    parameters: {
      path: {
        meterIdOrSlug: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': string[]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List notification channels
   * @description List all notification channels.
   */
  listNotificationChannels: {
    parameters: {
      query?: {
        /**
         * @description Include deleted notification channels in response.
         *
         * Usage: `?includeDeleted=true`
         */
        includeDeleted?: boolean
        /**
         * @description Include disabled notification channels in response.
         *
         * Usage: `?includeDisabled=false`
         */
        includeDisabled?: boolean
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        order?: components['parameters']['NotificationChannelOrderByOrdering.order']
        orderBy?: components['parameters']['NotificationChannelOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationChannelPaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create a notification channel
   * @description Create a new notification channel.
   */
  createNotificationChannel: {
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationChannelCreateRequest']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['NotificationChannel']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get notification channel
   * @description Get a notification channel by id.
   */
  getNotificationChannel: {
    parameters: {
      path: {
        channelId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationChannel']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Update a notification channel
   * @description Update notification channel.
   */
  updateNotificationChannel: {
    parameters: {
      path: {
        channelId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationChannelCreateRequest']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationChannel']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Delete a notification channel
   * @description Soft delete notification channel by id.
   *
   * Once a notification channel is deleted it cannot be undeleted.
   */
  deleteNotificationChannel: {
    parameters: {
      path: {
        channelId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List notification events
   * @description List all notification events.
   */
  listNotificationEvents: {
    parameters: {
      query?: {
        /**
         * @description Start date-time in RFC 3339 format.
         * Inclusive.
         */
        from?: string
        /**
         * @description End date-time in RFC 3339 format.
         * Inclusive.
         */
        to?: string
        /**
         * @description Filtering by multiple feature ids or keys.
         *
         * Usage: `?feature=feature-1&feature=feature-2`
         */
        feature?: string[]
        /**
         * @description Filtering by multiple subject ids or keys.
         *
         * Usage: `?subject=subject-1&subject=subject-2`
         */
        subject?: string[]
        /**
         * @description Filtering by multiple rule ids.
         *
         * Usage: `?rule=01J8J2XYZ2N5WBYK09EDZFBSZM&rule=01J8J4R4VZH180KRKQ63NB2VA5`
         */
        rule?: string[]
        /**
         * @description Filtering by multiple channel ids.
         *
         * Usage: `?channel=01J8J4RXH778XB056JS088PCYT&channel=01J8J4S1R1G9EVN62RG23A9M6J`
         */
        channel?: string[]
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        order?: components['parameters']['NotificationEventOrderByOrdering.order']
        orderBy?: components['parameters']['NotificationEventOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationEventPaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get notification event
   * @description Get a notification event by id.
   */
  getNotificationEvent: {
    parameters: {
      path: {
        eventId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationEvent']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List notification rules
   * @description List all notification rules.
   */
  listNotificationRules: {
    parameters: {
      query?: {
        /**
         * @description Include deleted notification rules in response.
         *
         * Usage: `?includeDeleted=true`
         */
        includeDeleted?: boolean
        /**
         * @description Include disabled notification rules in response.
         *
         * Usage: `?includeDisabled=false`
         */
        includeDisabled?: boolean
        /**
         * @description Filtering by multiple feature ids/keys.
         *
         * Usage: `?feature=feature-1&feature=feature-2`
         */
        feature?: string[]
        /**
         * @description Filtering by multiple notifiaction channel ids.
         *
         * Usage: `?channel=01ARZ3NDEKTSV4RRFFQ69G5FAV&channel=01J8J2Y5X4NNGQS32CF81W95E3`
         */
        channel?: string[]
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        order?: components['parameters']['NotificationRuleOrderByOrdering.order']
        orderBy?: components['parameters']['NotificationRuleOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRulePaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create a notification rule
   * @description Create a new notification rule.
   */
  createNotificationRule: {
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationRuleCreateRequest']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['NotificationRule']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get notification rule
   * @description Get a notification rule by id.
   */
  getNotificationRule: {
    parameters: {
      path: {
        ruleId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRule']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Update a notification rule
   * @description Update notification rule.
   */
  updateNotificationRule: {
    parameters: {
      path: {
        ruleId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationRuleCreateRequest']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRule']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Delete a notification rule
   * @description Soft delete notification rule by id.
   *
   * Once a notification rule is deleted it cannot be undeleted.
   */
  deleteNotificationRule: {
    parameters: {
      path: {
        ruleId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Test a notification rule by sending a test event with random data. */
  testNotificationRule: {
    parameters: {
      path: {
        ruleId: string
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['NotificationEvent']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Receive Svix operational events
   * @description Callback endpoint used by Svix to notify about operational events.
   */
  receiveSvixOperationalEvent: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SvixOperationalWebhookRequest']
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List plans
   * @description List all plans.
   */
  listPlans: {
    parameters: {
      query?: {
        /**
         * @description Include deleted plans in response.
         *
         * Usage: `?includeDeleted=true`
         */
        includeDeleted?: boolean
        /** @description Filter by plan.id attribute */
        id?: string[]
        /** @description Filter by plan.key attribute */
        key?: string[]
        /** @description Filter by plan.key and plan.version attributes */
        keyVersion?: {
          [key: string]: number[]
        }
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        order?: components['parameters']['PlanOrderByOrdering.order']
        orderBy?: components['parameters']['PlanOrderByOrdering.orderBy']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['PlanPaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create a plan
   * @description Create a new plan.
   */
  createPlan: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PlanCreate']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['Plan']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * New draft plan
   * @description Create a new draft version from plan.
   * It returns error if there is already a plan in draft or planId does not reference the latest published version.
   */
  nextPlan: {
    parameters: {
      path: {
        planIdOrKey: string
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['Plan']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get plan
   * @description Get a plan by id or key. The latest published version is returned if latter is used.
   */
  getPlan: {
    parameters: {
      query?: {
        /**
         * @description Include latest version of the Plan instead of the version in active state.
         *
         * Usage: `?includeLatest=true`
         */
        includeLatest?: boolean
      }
      path: {
        planId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Plan']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Update a plan
   * @description Update plan by id.
   */
  updatePlan: {
    parameters: {
      path: {
        planId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['PlanUpdate']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Plan']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Delete plan
   * @description Soft delete plan by plan.id.
   *
   * Once a plan is deleted it cannot be undeleted.
   */
  deletePlan: {
    parameters: {
      path: {
        planId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Archive plan version
   * @description Archive a plan version.
   */
  archivePlan: {
    parameters: {
      path: {
        planId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Plan']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * List phases in plan
   * @description List all phases in plan.
   */
  listPlanPhases: {
    parameters: {
      query?: {
        /** @description Filter by phase.key attribute */
        key?: string[]
        page?: components['parameters']['Pagination.page']
        pageSize?: components['parameters']['Pagination.pageSize']
        order?: components['parameters']['PhasesOrderByOrdering.order']
        orderBy?: components['parameters']['PhasesOrderByOrdering.orderBy']
      }
      path: {
        planId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['PlanPhasePaginatedResponse']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create new phase in plan
   * @description Create new phase in plan.
   */
  createPlanPhase: {
    parameters: {
      path: {
        planId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['PlanPhaseCreate']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['PlanPhase']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Get phase for plan
   * @description Get phase in plan.
   */
  getPlanPhase: {
    parameters: {
      path: {
        planId: string
        planPhaseKey: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['PlanPhase']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Update phase in plan
   * @description Update phase in plan.
   */
  updatePlanPhase: {
    parameters: {
      path: {
        planId: string
        planPhaseKey: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['PlanPhaseUpdate']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['PlanPhase']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Delete phase for plan
   * @description Delete phase in plan.
   *
   * Once a phase is deleted it cannot be undeleted.
   */
  deletePlanPhase: {
    parameters: {
      path: {
        planId: string
        planPhaseKey: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Publish plan
   * @description Publish a plan version.
   */
  publishPlan: {
    parameters: {
      path: {
        planId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Plan']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Query meter for consumer portal. This endpoint is publicly exposable to consumers. Query meter for consumer portal. This endpoint is publicly exposable to consumers. */
  queryPortalMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['MeterQuery.from']
        to?: components['parameters']['MeterQuery.to']
        windowSize?: components['parameters']['MeterQuery.windowSize']
        windowTimeZone?: components['parameters']['MeterQuery.windowTimeZone']
        filterGroupBy?: components['parameters']['MeterQuery.filterGroupBy']
        groupBy?: components['parameters']['MeterQuery.groupBy']
      }
      path: {
        meterSlug: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List tokens. */
  listPortalTokens: {
    parameters: {
      query?: {
        limit?: number
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Create a consumer portal token. */
  createPortalToken: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PortalToken']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Invalidates consumer portal tokens by ID or subject. */
  invalidatePortalTokens: {
    requestBody: {
      content: {
        'application/json': {
          /** @description Invalidate a portal token by ID. */
          id?: string
          /** @description Invalidate all portal tokens for a subject. */
          subject?: string
        }
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List subjects. */
  listSubjects: {
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Upserts a subject. Creates or updates subject.
   *
   * If the subject doesn't exist, it will be created.
   * If the subject exists, it will be partially updated with the provided fields.
   */
  upsertSubject: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SubjectUpsert'][]
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get subject by ID or key. */
  getSubject: {
    parameters: {
      path: {
        subjectIdOrKey: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subject']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Delete subject by ID or key. */
  deleteSubject: {
    parameters: {
      path: {
        subjectIdOrKey: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List all entitlements for a subject. For checking entitlement access, use the /value endpoint instead. */
  listSubjectEntitlements: {
    parameters: {
      query?: {
        includeDeleted?: boolean
      }
      path: {
        subjectIdOrKey: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * Create an entitlement
   * @description OpenMeter has three types of entitlements: metered, boolean, and static. The type property determines the type of entitlement. The underlying feature has to be compatible with the entitlement type specified in the request (e.g., a metered entitlement needs a feature associated with a meter).
   *
   * - Boolean entitlements define static feature access, e.g. "Can use SSO authentication".
   * - Static entitlements let you pass along a configuration while granting access, e.g. "Using this feature with X Y settings" (passed in the config).
   * - Metered entitlements have many use cases, from setting up usage-based access to implementing complex credit systems.  Example: The customer can use 10000 AI tokens during the usage period of the entitlement.
   *
   * A given subject can only have one active (non-deleted) entitlement per featureKey. If you try to create a new entitlement for a featureKey that already has an active entitlement, the request will fail with a 409 error.
   *
   * Once an entitlement is created you cannot modify it, only delete it.
   */
  createEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementCreateInputs']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description List all grants issued for an entitlement. The entitlement can be defined either by its id or featureKey. */
  listEntitlementGrants: {
    parameters: {
      query?: {
        includeDeleted?: boolean
        orderBy?: components['schemas']['GrantOrderBy']
      }
      path: {
        subjectIdOrKey: string
        entitlementIdOrFeatureKey: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementGrant'][]
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Grants define a behavior of granting usage for a metered entitlement. They can have complicated recurrence and rollover rules, thanks to which you can define a wide range of access patterns with a single grant, in most cases you don't have to periodically create new grants. You can only issue grants for active metered entitlements.
   *
   * A grant defines a given amount of usage that can be consumed for the entitlement. The grant is in effect between its effective date and its expiration date. Specifying both is mandatory for new grants.
   *
   * Grants have a priority setting that determines their order of use. Lower numbers have higher priority, with 0 being the highest priority.
   *
   * Grants can have a recurrence setting intended to automate the manual reissuing of grants. For example, a daily recurrence is equal to reissuing that same grant every day (ignoring rollover settings).
   *
   * Rollover settings define what happens to the remaining balance of a grant at a reset. Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
   *
   * Grants cannot be changed once created, only deleted. This is to ensure that balance is deterministic regardless of when it is queried.
   */
  createGrant: {
    parameters: {
      path: {
        subjectIdOrKey: string
        entitlementIdOrFeatureKey: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementGrantCreateInput']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['EntitlementGrant']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Overriding an entitlement creates a new entitlement from the provided inputs and soft deletes the previous entitlement for the provided subject-feature pair. If the previous entitlement is already deleted or otherwise doesnt exist, the override will fail.
   *
   * This endpoint is useful for upgrades, downgrades, or other changes to entitlements that require a new entitlement to be created with zero downtime.
   */
  overrideEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: string
        entitlementIdOrFeatureKey: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['EntitlementCreateInputs']
      }
    }
    responses: {
      /** @description The request has succeeded and a new resource has been created as a result. */
      201: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description This endpoint should be used for access checks and enforcement. All entitlement types share the hasAccess property in their value response, but multiple other properties are returned based on the entitlement type.
   *
   * For convenience reasons, /value works with both entitlementId and featureKey.
   */
  getEntitlementValue: {
    parameters: {
      query?: {
        time?: string
      }
      path: {
        subjectIdOrKey: string
        entitlementIdOrFeatureKey: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['EntitlementValue']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Get entitlement by id. For checking entitlement access, use the /value endpoint instead. */
  getEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: string
        entitlementId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Entitlement']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Deleting an entitlement revokes access to the associated feature. As a single subject can only have one entitlement per featureKey, when "migrating" features you have to delete the old entitlements as well.
   * As access and status checks can be historical queries, deleting an entitlement populates the deletedAt timestamp. When queried for a time before that, the entitlement is still considered active, you cannot have retroactive changes to access, which is important for, among other things, auditing.
   */
  deleteEntitlement: {
    parameters: {
      path: {
        subjectIdOrKey: string
        entitlementId: string
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Returns historical balance and usage data for the entitlement. The queried history can span accross multiple reset events.
   *
   * BurndownHistory returns a continous history of segments, where the segments are seperated by events that changed either the grant burndown priority or the usage period.
   *
   * WindowedHistory returns windowed usage data for the period enriched with balance information and the list of grants that were being burnt down in that window.
   */
  getEntitlementHistory: {
    parameters: {
      query: {
        /** @description Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to the last reset. Gets truncated to the granularity of the underlying meter. */
        from?: string
        /**
         * @description End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.
         * If not now then gets truncated to the granularity of the underlying meter.
         */
        to?: string
        /** @description Windowsize */
        windowSize: components['schemas']['WindowSize']
        /** @description The timezone used when calculating the windows. */
        windowTimeZone?: string
      }
      path: {
        subjectIdOrKey: string
        entitlementId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['WindowedBalanceHistory']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Reset marks the start of a new usage period for the entitlement and initiates grant rollover. At the start of a period usage is zerod out and grants are rolled over based on their rollover settings. It would typically be synced with the subjects billing period to enforce usage based on their subscription.
   *
   * Usage is automatically reset for metered entitlements based on their usage period, but this endpoint allows to manually reset it at any time. When doing so the period anchor of the entitlement can be changed if needed.
   */
  resetEntitlementUsage: {
    parameters: {
      path: {
        subjectIdOrKey: string
        entitlementId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['ResetEntitlementUsageInput']
      }
    }
    responses: {
      /** @description There is no content to send for this request, but the headers may be useful. */
      204: {
        content: never
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  Subscriptions_create: {
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSubscriptionRequestBody']
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subscription']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  getSubscription: {
    parameters: {
      query?: {
        expand?: false | true
        /** @description The time at which the subscription should be queried. If not provided the current time is used. */
        at?: string
      }
      path: {
        subscriptionId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json':
            | components['schemas']['Subscription']
            | components['schemas']['SubscriptionExpanded']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /**
   * @description Batch processing commands for manipulating running subscriptions.
   * The key format is `/phases/{phaseKey}` or `/phases/{phaseKey}/items/{itemKey}`.
   *
   * Add operations insert a new member based on the creation input without altering the existing members.
   *
   * Remove operations remove the member from the collection / document.
   *
   * The extend operation extends the specific phase if possible, while delaying all subsequent phases by the same amount.
   */
  editSubscription: {
    parameters: {
      path: {
        subscriptionId: string
      }
    }
    requestBody: {
      content: {
        'application/json': (
          | components['schemas']['SubscriptionEditAddUpdateItem']
          | components['schemas']['SubscriptionEditRemoveUpdateItem']
          | components['schemas']['SubscriptionEditAdd']
          | components['schemas']['SubscriptionEditExtend']
          | components['schemas']['SubscriptionEditRemoveWithValue']
        )[]
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subscription']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Cancels the subscription. */
  cancelSubscription: {
    parameters: {
      path: {
        subscriptionId: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * Format: date-time
           * @description If not provided the subscription is canceled immediately.
           * @example "2023-01-01T01:01:01.001Z"
           */
          effectiveDate?: string
        }
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subscription']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Migrates the subscripiton to the procided version of the plan. */
  migrateSubscription: {
    parameters: {
      path: {
        subscriptionId: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          targetVersion: number
        }
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subscription']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
  /** @description Cancels the scheduled cancelation. */
  unscheduleCancelation: {
    parameters: {
      path: {
        subscriptionId: string
      }
    }
    responses: {
      /** @description The request has succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['Subscription']
        }
      }
      /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
      400: {
        content: {
          'application/problem+json': components['schemas']['BadRequestProblemResponse']
        }
      }
      /** @description The request has not been applied because it lacks valid authentication credentials for the target resource. */
      401: {
        content: {
          'application/problem+json': components['schemas']['UnauthorizedProblemResponse']
        }
      }
      /** @description The server understood the request but refuses to authorize it. */
      403: {
        content: {
          'application/problem+json': components['schemas']['ForbiddenProblemResponse']
        }
      }
      /** @description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. */
      404: {
        content: {
          'application/problem+json': components['schemas']['NotFoundProblemResponse']
        }
      }
      /** @description The request could not be completed due to a conflict with the current state of the target resource. */
      409: {
        content: {
          'application/problem+json': components['schemas']['ConflictProblemResponse']
        }
      }
      /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
      500: {
        content: {
          'application/problem+json': components['schemas']['InternalServerErrorProblemResponse']
        }
      }
      /** @description The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. */
      503: {
        content: {
          'application/problem+json': components['schemas']['ServiceUnavailableProblemResponse']
        }
      }
      /** @description An unexpected error response. */
      default: {
        content: {
          'application/problem+json': components['schemas']['UnexpectedProblemResponse']
        }
      }
    }
  }
}
