// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package meters

import (
	v3 "github.com/openmeterio/openmeter/api/v3"
	response "github.com/openmeterio/openmeter/api/v3/response"
	meter "github.com/openmeterio/openmeter/openmeter/meter"
	models "github.com/openmeterio/openmeter/pkg/models"
	"time"
)

func init() {
	ConvertFromCreateMeterRequestToCreateMeterInput = func(context string, source v3.CreateMeterRequest) meter.CreateMeterInput {
		var meterCreateMeterInput meter.CreateMeterInput
		meterCreateMeterInput.Namespace = NamespaceFromContext(context)
		meterCreateMeterInput.Name = source.Name
		meterCreateMeterInput.Key = source.Key
		meterCreateMeterInput.Description = source.Description
		meterCreateMeterInput.Aggregation = ConvertAPIMeterAggregationToMeterAggregation(source.Aggregation)
		meterCreateMeterInput.EventType = source.EventType
		meterCreateMeterInput.EventFrom = source.EventsFrom
		meterCreateMeterInput.ValueProperty = source.ValueProperty
		if source.Dimensions != nil {
			meterCreateMeterInput.GroupBy = (*source.Dimensions)
		}
		meterCreateMeterInput.Metadata = pV3LabelsToModelsMetadata(source.Labels)
		return meterCreateMeterInput
	}
	ConvertMeterListResponse = func(source response.PagePaginationResponse[meter.Meter]) v3.MeterPagePaginatedResponse {
		var v3MeterPagePaginatedResponse v3.MeterPagePaginatedResponse
		if source.Data != nil {
			v3MeterPagePaginatedResponse.Data = make([]v3.Meter, len(source.Data))
			for i := 0; i < len(source.Data); i++ {
				v3MeterPagePaginatedResponse.Data[i] = ConvertMeterToAPIMeter(source.Data[i])
			}
		}
		v3MeterPagePaginatedResponse.Meta = responsePageMetaToV3PaginatedMeta(source.Meta)
		return v3MeterPagePaginatedResponse
	}
	ConvertMeterToAPIMeter = func(source meter.Meter) v3.Meter {
		var v3Meter v3.Meter
		v3Meter.Aggregation = ConvertMeterAggregationToAPIMeterAggregation(source.Aggregation)
		v3Meter.CreatedAt = timeTimeToPTimeTime(source.ManagedResource.ManagedModel.CreatedAt)
		v3Meter.DeletedAt = source.ManagedResource.ManagedModel.DeletedAt
		v3Meter.Description = source.ManagedResource.Description
		v3Meter.Dimensions = &source.GroupBy
		v3Meter.EventType = source.EventType
		v3Meter.EventsFrom = source.EventFrom
		v3Meter.Id = source.ManagedResource.ID
		v3Meter.Key = source.Key
		v3Meter.Labels = modelsMetadataToPV3Labels(source.Metadata)
		v3Meter.Name = source.ManagedResource.Name
		v3Meter.UpdatedAt = timeTimeToPTimeTime(source.ManagedResource.ManagedModel.UpdatedAt)
		v3Meter.ValueProperty = source.ValueProperty
		return v3Meter
	}
}
func modelsMetadataToPV3Labels(source models.Metadata) *v3.Labels {
	v3Labels := modelsMetadataToV3Labels(source)
	return &v3Labels
}
func modelsMetadataToV3Labels(source models.Metadata) v3.Labels {
	var v3Labels v3.Labels
	if source != nil {
		v3Labels = make(v3.Labels, len(source))
		for key, value := range source {
			v3Labels[key] = value
		}
	}
	return v3Labels
}
func pV3LabelsToModelsMetadata(source *v3.Labels) models.Metadata {
	var modelsMetadata models.Metadata
	if source != nil {
		modelsMetadata = v3LabelsToModelsMetadata((*source))
	}
	return modelsMetadata
}
func responsePageMetaPageToV3PageMeta(source response.PageMetaPage) v3.PageMeta {
	var v3PageMeta v3.PageMeta
	v3PageMeta.Number = IntToFloat32(source.Number)
	v3PageMeta.Size = IntToFloat32(source.Size)
	if source.Total != nil {
		v3PageMeta.Total = IntToFloat32(*source.Total)
	}
	return v3PageMeta
}
func responsePageMetaToV3PaginatedMeta(source response.PageMeta) v3.PaginatedMeta {
	var v3PaginatedMeta v3.PaginatedMeta
	v3PaginatedMeta.Page = responsePageMetaPageToV3PageMeta(source.Page)
	return v3PaginatedMeta
}
func timeTimeToPTimeTime(source time.Time) *time.Time {
	return &source
}
func v3LabelsToModelsMetadata(source v3.Labels) models.Metadata {
	var modelsMetadata models.Metadata
	if source != nil {
		modelsMetadata = make(models.Metadata, len(source))
		for key, value := range source {
			modelsMetadata[key] = value
		}
	}
	return modelsMetadata
}
