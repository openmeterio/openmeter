// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/cloudevents/sdk-go/v2/event"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	"github.com/openmeterio/openmeter/pkg/models"
)

const (
	CloudCookieAuthScopes      = "CloudCookieAuth.Scopes"
	CloudPortalTokenAuthScopes = "CloudPortalTokenAuth.Scopes"
	CloudTokenAuthScopes       = "CloudTokenAuth.Scopes"
	PortalTokenAuthScopes      = "PortalTokenAuth.Scopes"
)

// Defines values for EntitlementBooleanType.
const (
	EntitlementBooleanTypeBoolean EntitlementBooleanType = "boolean"
)

// Defines values for EntitlementBooleanCreateInputsType.
const (
	EntitlementBooleanCreateInputsTypeBoolean EntitlementBooleanCreateInputsType = "boolean"
)

// Defines values for EntitlementMeteredType.
const (
	EntitlementMeteredTypeMetered EntitlementMeteredType = "metered"
)

// Defines values for EntitlementMeteredCreateInputsType.
const (
	EntitlementMeteredCreateInputsTypeMetered EntitlementMeteredCreateInputsType = "metered"
)

// Defines values for EntitlementStaticType.
const (
	EntitlementStaticTypeStatic EntitlementStaticType = "static"
)

// Defines values for EntitlementStaticCreateInputsType.
const (
	EntitlementStaticCreateInputsTypeStatic EntitlementStaticCreateInputsType = "static"
)

// Defines values for ExpirationPeriodDuration.
const (
	ExpirationPeriodDurationDAY   ExpirationPeriodDuration = "DAY"
	ExpirationPeriodDurationHOUR  ExpirationPeriodDuration = "HOUR"
	ExpirationPeriodDurationMONTH ExpirationPeriodDuration = "MONTH"
	ExpirationPeriodDurationWEEK  ExpirationPeriodDuration = "WEEK"
	ExpirationPeriodDurationYEAR  ExpirationPeriodDuration = "YEAR"
)

// Defines values for NotificationChannelType.
const (
	WEBHOOK NotificationChannelType = "WEBHOOK"
)

// Defines values for NotificationEventDeliveryStatusState.
const (
	FAILED  NotificationEventDeliveryStatusState = "FAILED"
	SENDING NotificationEventDeliveryStatusState = "SENDING"
	SUCCESS NotificationEventDeliveryStatusState = "SUCCESS"
)

// Defines values for NotificationEventType.
const (
	EntitlementsBalanceThreshold NotificationEventType = "entitlements.balance.threshold"
)

// Defines values for NotificationRuleBalanceThresholdValueType.
const (
	NUMBER  NotificationRuleBalanceThresholdValueType = "NUMBER"
	PERCENT NotificationRuleBalanceThresholdValueType = "PERCENT"
)

// Defines values for RecurringPeriodEnum.
const (
	RecurringPeriodEnumDAY   RecurringPeriodEnum = "DAY"
	RecurringPeriodEnumMONTH RecurringPeriodEnum = "MONTH"
	RecurringPeriodEnumWEEK  RecurringPeriodEnum = "WEEK"
	RecurringPeriodEnumYEAR  RecurringPeriodEnum = "YEAR"
)

// Defines values for ListEntitlementsParamsOrderBy.
const (
	ListEntitlementsParamsOrderByCreatedAt ListEntitlementsParamsOrderBy = "createdAt"
	ListEntitlementsParamsOrderByUpdatedAt ListEntitlementsParamsOrderBy = "updatedAt"
)

// Defines values for ListFeaturesParamsOrderBy.
const (
	ListFeaturesParamsOrderByCreatedAt ListFeaturesParamsOrderBy = "createdAt"
	ListFeaturesParamsOrderById        ListFeaturesParamsOrderBy = "id"
	ListFeaturesParamsOrderByUpdatedAt ListFeaturesParamsOrderBy = "updatedAt"
)

// Defines values for ListGrantsParamsOrderBy.
const (
	ListGrantsParamsOrderByCreatedAt ListGrantsParamsOrderBy = "createdAt"
	ListGrantsParamsOrderById        ListGrantsParamsOrderBy = "id"
	ListGrantsParamsOrderByUpdatedAt ListGrantsParamsOrderBy = "updatedAt"
)

// Defines values for ListNotificationChannelsParamsOrderBy.
const (
	ListNotificationChannelsParamsOrderByCreatedAt ListNotificationChannelsParamsOrderBy = "createdAt"
	ListNotificationChannelsParamsOrderById        ListNotificationChannelsParamsOrderBy = "id"
	ListNotificationChannelsParamsOrderByType      ListNotificationChannelsParamsOrderBy = "type"
	ListNotificationChannelsParamsOrderByUpdatedAt ListNotificationChannelsParamsOrderBy = "updatedAt"
)

// Defines values for ListNotificationEventsParamsOrderBy.
const (
	ListNotificationEventsParamsOrderByCreatedAt ListNotificationEventsParamsOrderBy = "createdAt"
	ListNotificationEventsParamsOrderById        ListNotificationEventsParamsOrderBy = "id"
)

// Defines values for ListNotificationRulesParamsOrderBy.
const (
	ListNotificationRulesParamsOrderByCreatedAt ListNotificationRulesParamsOrderBy = "createdAt"
	ListNotificationRulesParamsOrderById        ListNotificationRulesParamsOrderBy = "id"
	ListNotificationRulesParamsOrderByType      ListNotificationRulesParamsOrderBy = "type"
	ListNotificationRulesParamsOrderByUpdatedAt ListNotificationRulesParamsOrderBy = "updatedAt"
)

// Defines values for ListEntitlementGrantsParamsOrderBy.
const (
	CreatedAt ListEntitlementGrantsParamsOrderBy = "createdAt"
	Id        ListEntitlementGrantsParamsOrderBy = "id"
	UpdatedAt ListEntitlementGrantsParamsOrderBy = "updatedAt"
)

// Defines values for GetEntitlementHistoryParamsWindowSize.
const (
	DAY    GetEntitlementHistoryParamsWindowSize = "DAY"
	HOUR   GetEntitlementHistoryParamsWindowSize = "HOUR"
	MINUTE GetEntitlementHistoryParamsWindowSize = "MINUTE"
)

// BalanceHistoryWindow Windowed usage and balance information.
type BalanceHistoryWindow struct {
	// BalanceAtStart The entitlement balance at the start of the period.
	BalanceAtStart *float64 `json:"balanceAtStart,omitempty"`

	// Period A time period
	Period *Period `json:"period,omitempty"`

	// Usage The total usage of the feature in the period.
	Usage *float64 `json:"usage,omitempty"`
}

// ConflictProblem Conflict
type ConflictProblem struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail     string `json:"detail"`
	Extensions *struct {
		// ConflictingEntityId The id of the conflicting entity.
		ConflictingEntityId string `json:"conflictingEntityId"`
	} `json:"extensions,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code generated by the origin server for this occurrence of the problem.
	Status int32 `json:"status"`

	// Title A a short, human-readable summary of the problem type.
	Title string `json:"title"`

	// Type Type contains a URI that identifies the problem type.
	Type                 string                 `json:"type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Entitlement defines model for Entitlement.
type Entitlement struct {
	union json.RawMessage
}

// EntitlementBoolean defines model for EntitlementBoolean.
type EntitlementBoolean struct {
	// CreatedAt The date and time the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CurrentUsagePeriod A time period
	CurrentUsagePeriod *Period `json:"currentUsagePeriod,omitempty"`

	// DeletedAt The date and time the resource was deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string                 `json:"subjectKey"`
	Type       EntitlementBooleanType `json:"type"`

	// UpdatedAt The date and time the resource was last updated. The initial value is the same as createdAt.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UsagePeriod Recurring period of an entitlement.
	UsagePeriod *RecurringPeriod `json:"usagePeriod,omitempty"`
}

// EntitlementBooleanType defines model for EntitlementBoolean.Type.
type EntitlementBooleanType string

// EntitlementBooleanCreateInputs defines model for EntitlementBooleanCreateInputs.
type EntitlementBooleanCreateInputs struct {
	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *map[string]string                 `json:"metadata,omitempty"`
	Type     EntitlementBooleanCreateInputsType `json:"type"`

	// UsagePeriod Recurring period of an entitlement.
	UsagePeriod *RecurringPeriodCreateInput `json:"usagePeriod,omitempty"`
}

// EntitlementBooleanCreateInputsType defines model for EntitlementBooleanCreateInputs.Type.
type EntitlementBooleanCreateInputsType string

// EntitlementCreateInputs defines model for EntitlementCreateInputs.
type EntitlementCreateInputs struct {
	union json.RawMessage
}

// EntitlementCreateSharedFields defines model for EntitlementCreateSharedFields.
type EntitlementCreateSharedFields struct {
	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// UsagePeriod Recurring period of an entitlement.
	UsagePeriod *RecurringPeriodCreateInput `json:"usagePeriod,omitempty"`
}

// EntitlementGrant defines model for EntitlementGrant.
type EntitlementGrant struct {
	// Amount The amount to grant. Should be a positive number.
	Amount float64 `json:"amount"`

	// CreatedAt The date and time the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DeletedAt The date and time the resource was deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// EffectiveAt Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
	EffectiveAt time.Time `json:"effectiveAt"`

	// EntitlementId The unique entitlement ULID that the grant is associated with.
	EntitlementId *string          `json:"entitlementId,omitempty"`
	Expiration    ExpirationPeriod `json:"expiration"`

	// ExpiresAt The expiration date of the grant.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// MaxRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	//
	// Balance after the reset is calculated as:
	// Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MaxRolloverAmount *float64           `json:"maxRolloverAmount,omitempty"`
	Metadata          *map[string]string `json:"metadata,omitempty"`

	// MinRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	//
	// Balance after the reset is calculated as:
	// Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MinRolloverAmount *float64 `json:"minRolloverAmount,omitempty"`

	// NextRecurrence The next time the grant will recurr.
	NextRecurrence *time.Time `json:"nextRecurrence,omitempty"`

	// Priority The priority of the grant. Grants with higher priority are applied first.
	// Priority is a positive decimal numbers. With lower numbers indicating higher importance.
	// For example, a priority of 1 is more urgent than a priority of 2.
	// When there are several grants available for the same subject, the system selects the grant with the highest priority.
	// In cases where grants share the same priority level, the grant closest to its expiration will be used first.
	// In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
	Priority *int `json:"priority,omitempty"`

	// Recurrence Recurring period of an entitlement.
	Recurrence *RecurringPeriod `json:"recurrence,omitempty"`

	// UpdatedAt The date and time the resource was last updated. The initial value is the same as createdAt.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// VoidedAt The date and time the grant was voided (cannot be used after that).
	VoidedAt *time.Time `json:"voidedAt,omitempty"`
}

// EntitlementGrantCreateInput Grants are used to increase balance of specific subjects.
type EntitlementGrantCreateInput struct {
	// Amount The amount to grant. Should be a positive number.
	Amount float64 `json:"amount"`

	// EffectiveAt Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
	EffectiveAt time.Time        `json:"effectiveAt"`
	Expiration  ExpirationPeriod `json:"expiration"`

	// MaxRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	//
	// Balance after the reset is calculated as:
	// Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MaxRolloverAmount *float64           `json:"maxRolloverAmount,omitempty"`
	Metadata          *map[string]string `json:"metadata,omitempty"`

	// MinRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	//
	// Balance after the reset is calculated as:
	// Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MinRolloverAmount *float64 `json:"minRolloverAmount,omitempty"`

	// Priority The priority of the grant. Grants with higher priority are applied first.
	// Priority is a positive decimal numbers. With lower numbers indicating higher importance.
	// For example, a priority of 1 is more urgent than a priority of 2.
	// When there are several grants available for the same subject, the system selects the grant with the highest priority.
	// In cases where grants share the same priority level, the grant closest to its expiration will be used first.
	// In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
	Priority *int `json:"priority,omitempty"`

	// Recurrence Recurring period of an entitlement.
	Recurrence *RecurringPeriodCreateInput `json:"recurrence,omitempty"`
}

// EntitlementMetered defines model for EntitlementMetered.
type EntitlementMetered struct {
	// CreatedAt The date and time the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CurrentUsagePeriod A time period
	CurrentUsagePeriod Period `json:"currentUsagePeriod"`

	// DeletedAt The date and time the resource was deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// IsSoftLimit If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
	IsSoftLimit *bool `json:"isSoftLimit,omitempty"`

	// IsUnlimited Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
	IsUnlimited *bool `json:"isUnlimited,omitempty"`

	// IssueAfterReset You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance. If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
	// That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
	//
	// Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
	IssueAfterReset *float64 `json:"issueAfterReset,omitempty"`

	// IssueAfterResetPriority Defines the grant priority for the default grant. If provided, issueAfterReset must have a value.
	IssueAfterResetPriority *int `json:"issueAfterResetPriority,omitempty"`

	// LastReset The last time a reset happened.
	LastReset time.Time `json:"lastReset"`

	// Metadata Additional metadata for the feature.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string                 `json:"subjectKey"`
	Type       EntitlementMeteredType `json:"type"`

	// UpdatedAt The date and time the resource was last updated. The initial value is the same as createdAt.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UsagePeriod Recurring period of an entitlement.
	UsagePeriod RecurringPeriod `json:"usagePeriod"`
}

// EntitlementMeteredType defines model for EntitlementMetered.Type.
type EntitlementMeteredType string

// EntitlementMeteredCalculatedFields Calculated fields for a metered entitlement.
type EntitlementMeteredCalculatedFields struct {
	// CurrentUsagePeriod A time period
	CurrentUsagePeriod Period `json:"currentUsagePeriod"`

	// LastReset The last time a reset happened.
	LastReset time.Time `json:"lastReset"`
}

// EntitlementMeteredCreateInputs defines model for EntitlementMeteredCreateInputs.
type EntitlementMeteredCreateInputs struct {
	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// IsSoftLimit If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
	IsSoftLimit *bool `json:"isSoftLimit,omitempty"`

	// IsUnlimited Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
	IsUnlimited *bool `json:"isUnlimited,omitempty"`

	// IssueAfterReset You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance. If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
	// That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
	//
	// Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
	IssueAfterReset *float64 `json:"issueAfterReset,omitempty"`

	// IssueAfterResetPriority Defines the grant priority for the default grant. If provided, issueAfterReset must have a value.
	IssueAfterResetPriority *int `json:"issueAfterResetPriority,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *map[string]string                 `json:"metadata,omitempty"`
	Type     EntitlementMeteredCreateInputsType `json:"type"`

	// UsagePeriod Recurring period of an entitlement.
	UsagePeriod RecurringPeriodCreateInput `json:"usagePeriod"`
}

// EntitlementMeteredCreateInputsType defines model for EntitlementMeteredCreateInputs.Type.
type EntitlementMeteredCreateInputsType string

// EntitlementSharedFields defines model for EntitlementSharedFields.
type EntitlementSharedFields struct {
	// CreatedAt The date and time the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CurrentUsagePeriod A time period
	CurrentUsagePeriod *Period `json:"currentUsagePeriod,omitempty"`

	// DeletedAt The date and time the resource was deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string `json:"subjectKey"`

	// UpdatedAt The date and time the resource was last updated. The initial value is the same as createdAt.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UsagePeriod Recurring period of an entitlement.
	UsagePeriod *RecurringPeriod `json:"usagePeriod,omitempty"`
}

// EntitlementStatic defines model for EntitlementStatic.
type EntitlementStatic struct {
	// Config The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
	Config string `json:"config"`

	// CreatedAt The date and time the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CurrentUsagePeriod A time period
	CurrentUsagePeriod *Period `json:"currentUsagePeriod,omitempty"`

	// DeletedAt The date and time the resource was deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string                `json:"subjectKey"`
	Type       EntitlementStaticType `json:"type"`

	// UpdatedAt The date and time the resource was last updated. The initial value is the same as createdAt.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UsagePeriod Recurring period of an entitlement.
	UsagePeriod *RecurringPeriod `json:"usagePeriod,omitempty"`
}

// EntitlementStaticType defines model for EntitlementStatic.Type.
type EntitlementStaticType string

// EntitlementStaticCreateInputs defines model for EntitlementStaticCreateInputs.
type EntitlementStaticCreateInputs struct {
	// Config The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
	Config string `json:"config"`

	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *map[string]string                `json:"metadata,omitempty"`
	Type     EntitlementStaticCreateInputsType `json:"type"`

	// UsagePeriod Recurring period of an entitlement.
	UsagePeriod *RecurringPeriodCreateInput `json:"usagePeriod,omitempty"`
}

// EntitlementStaticCreateInputsType defines model for EntitlementStaticCreateInputs.Type.
type EntitlementStaticCreateInputsType string

// EntitlementValue defines model for EntitlementValue.
type EntitlementValue struct {
	// Balance Only available for metered entitlements. Metered entitlements are built around a balance calculation where feature usage is deducted from the issued grants. Balance represents the remaining balance of the entitlement, it's value never turns negative.
	Balance *float64 `json:"balance,omitempty"`

	// Config Only available for static entitlements. The JSON parsable config of the entitlement.
	Config *string `json:"config,omitempty"`

	// HasAccess Whether the subject has access to the feature. Shared accross all entitlement types.
	HasAccess *bool `json:"hasAccess,omitempty"`

	// Overage Only available for metered entitlements. Overage represents the usage that wasn't covered by grants, e.g. if the subject had a total feature usage of 100 in the period but they were only granted 80, there would be 20 overage.
	Overage *float64 `json:"overage,omitempty"`

	// Usage Only available for metered entitlements. Returns the total feature usage in the current period.
	Usage *float64 `json:"usage,omitempty"`
}

// Event CloudEvents Specification JSON Schema
type Event = event.Event

// ExpirationPeriod Expiration period of a grant.
type ExpirationPeriod struct {
	// Count The expiration period count like 12 months.
	Count int `json:"count"`

	// Duration The expiration period duration like month.
	Duration ExpirationPeriodDuration `json:"duration"`
}

// ExpirationPeriodDuration The expiration period duration like month.
type ExpirationPeriodDuration string

// Feature defines model for Feature.
type Feature struct {
	// ArchivedAt If the feature is archived, no new entitlements can be created for it.
	ArchivedAt *time.Time `json:"archivedAt,omitempty"`

	// CreatedAt The date and time the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DeletedAt The date and time the resource was deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// Key The key is an immutable unique identifier of the feature used throughout the API, for example when interacting with a subject's entitlements. The key has to be unique across all active features, but archived features can share the same key. The key should consist of lowercase alphanumeric characters and dashes.
	Key string `json:"key"`

	// Metadata Additional metadata for the feature, useful for syncing with external systems and annotating custom fields.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// MeterGroupByFilters Optional meter group by filters. Useful if the meter scope is broader than what feature tracks. Example scenario would be a meter tracking all token use with groupBy fields for the model, then the feature could filter for model=gpt-4.
	MeterGroupByFilters *map[string]string `json:"meterGroupByFilters,omitempty"`

	// MeterSlug The meter that the feature is associated with and and based on which usage is calculated.
	// The meter selected must have SUM or COUNT aggregation.
	MeterSlug *string `json:"meterSlug,omitempty"`

	// Name The name of the feature.
	Name string `json:"name"`

	// UpdatedAt The date and time the resource was last updated. The initial value is the same as createdAt.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// FeatureCreateInputs A feature is a feature or service offered to a customer.
// For example: CPU-Hours, Tokens, API Calls, etc.
type FeatureCreateInputs struct {
	// Key The key is an immutable unique identifier of the feature used throughout the API, for example when interacting with a subject's entitlements. The key has to be unique across all active features, but archived features can share the same key. The key should consist of lowercase alphanumeric characters and dashes.
	Key string `json:"key"`

	// Metadata Additional metadata for the feature, useful for syncing with external systems and annotating custom fields.
	Metadata *map[string]string `json:"metadata,omitempty"`

	// MeterGroupByFilters Optional meter group by filters. Useful if the meter scope is broader than what feature tracks. Example scenario would be a meter tracking all token use with groupBy fields for the model, then the feature could filter for model=gpt-4.
	MeterGroupByFilters *map[string]string `json:"meterGroupByFilters,omitempty"`

	// MeterSlug The meter that the feature is associated with and and based on which usage is calculated.
	// The meter selected must have SUM or COUNT aggregation.
	MeterSlug *string `json:"meterSlug,omitempty"`

	// Name The name of the feature.
	Name string `json:"name"`
}

// FeatureMeta Limited representation of a feature resource which includes only its unique identifiers (id, key).
type FeatureMeta struct {
	// Id A unique identifier for the notification rule.
	Id string `json:"id"`

	// Key The key is an immutable unique identifier of the feature used throughout the API,
	// for example when interacting with a subject's entitlements.
	Key string `json:"key"`
}

// GrantBurnDownHistorySegment A segment of the grant burn down history.
//
// A given segment represents the usage of a grant between events that changed either the grant burn down priority order or the usag period.
type GrantBurnDownHistorySegment struct {
	// BalanceAtEnd The entitlement balance at the end of the period.
	BalanceAtEnd *float64 `json:"balanceAtEnd,omitempty"`

	// BalanceAtStart The entitlement balance at the start of the period.
	BalanceAtStart *float64 `json:"balanceAtStart,omitempty"`

	// GrantBalancesAtEnd The balance breakdown of each active grant at the start of the period: GrantID: Balance
	GrantBalancesAtEnd *map[string]float64 `json:"grantBalancesAtEnd,omitempty"`

	// GrantBalancesAtStart The balance breakdown of each active grant at the start of the period: GrantID: Balance
	GrantBalancesAtStart *map[string]float64 `json:"grantBalancesAtStart,omitempty"`

	// GrantUsages Which grants were actually burnt down in the period and by what amount.
	GrantUsages *[]GrantUsageRecord `json:"grantUsages,omitempty"`

	// Overage Overuse that wasn't covered by grants.
	Overage *float64 `json:"overage,omitempty"`

	// Period A time period
	Period *Period `json:"period,omitempty"`

	// Usage The usage of the grant in the period.
	Usage *float64 `json:"usage,omitempty"`
}

// GrantUsageRecord defines model for GrantUsageRecord.
type GrantUsageRecord struct {
	// GrantId The id of the grant.
	GrantId *string `json:"grantId,omitempty"`

	// Usage The usage of the grant.
	Usage *float64 `json:"usage,omitempty"`
}

// IdOrSlug A unique identifier.
type IdOrSlug = string

// IngestedEvent An ingested event with optional validation error.
type IngestedEvent struct {
	// Event CloudEvents Specification JSON Schema
	Event           Event   `json:"event"`
	ValidationError *string `json:"validationError,omitempty"`
}

// ListEntitlementGrantResponse defines model for ListEntitlementGrantResponse.
type ListEntitlementGrantResponse struct {
	union json.RawMessage
}

// ListEntitlementGrantResponse0 defines model for .
type ListEntitlementGrantResponse0 = []EntitlementGrant

// ListEntitlementGrantResponse1 defines model for .
type ListEntitlementGrantResponse1 struct {
	// Items List of grants.
	Items []EntitlementGrant `json:"items"`

	// Page Current page number.
	Page int `json:"page"`

	// PageSize Number of grants per page.
	PageSize int `json:"pageSize"`

	// TotalCount Total number of grants.
	TotalCount int `json:"totalCount"`
}

// ListEntitlementResponse defines model for ListEntitlementResponse.
type ListEntitlementResponse struct {
	union json.RawMessage
}

// ListEntitlementResponse0 defines model for .
type ListEntitlementResponse0 = []Entitlement

// ListEntitlementResponse1 defines model for .
type ListEntitlementResponse1 struct {
	// Items List of entitlements.
	Items []Entitlement `json:"items"`

	// Page Current page number.
	Page int `json:"page"`

	// PageSize Number of entitlements per page.
	PageSize int `json:"pageSize"`

	// TotalCount Total number of entitlements.
	TotalCount int `json:"totalCount"`
}

// ListFeatureResponse defines model for ListFeatureResponse.
type ListFeatureResponse struct {
	union json.RawMessage
}

// ListFeatureResponse0 defines model for .
type ListFeatureResponse0 = []Feature

// ListFeatureResponse1 defines model for .
type ListFeatureResponse1 struct {
	// Items List of features.
	Items []Feature `json:"items"`

	// Page Current page number.
	Page int `json:"page"`

	// PageSize Number of features per page.
	PageSize int `json:"pageSize"`

	// TotalCount Total number of features.
	TotalCount int `json:"totalCount"`
}

// Meter A meter is a configuration that defines how to match and aggregate events.
type Meter = models.Meter

// MeterAggregation The aggregation type to use for the meter.
type MeterAggregation = models.MeterAggregation

// MeterQueryResult The result of a meter query.
type MeterQueryResult struct {
	Data []MeterQueryRow `json:"data"`
	From *time.Time      `json:"from,omitempty"`
	To   *time.Time      `json:"to,omitempty"`

	// WindowSize Aggregation window size.
	WindowSize *WindowSize `json:"windowSize,omitempty"`
}

// MeterQueryRow A row in the result of a meter query.
type MeterQueryRow = models.MeterQueryRow

// NotificationChannel defines model for NotificationChannel.
type NotificationChannel struct {
	union json.RawMessage
}

// NotificationChannelCommon defines model for NotificationChannelCommon.
type NotificationChannelCommon struct {
	// CreatedAt Timestamp when the channel was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Disabled Whether the channel is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Id A unique identifier for the notification channel.
	Id string `json:"id"`

	// Name User friendly name of the channel.
	Name *string `json:"name,omitempty"`

	// Type The type of the notification channel.
	Type NotificationChannelType `json:"type"`

	// UpdatedAt Timestamp when the channel was modified.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// NotificationChannelCommonCreateRequest Common fields for create notification channel request.
type NotificationChannelCommonCreateRequest struct {
	// Disabled Whether the channel is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Name User friendly name of the channel.
	Name string `json:"name"`

	// Type The type of the notification channel.
	Type NotificationChannelType `json:"type"`
}

// NotificationChannelCreateRequest defines model for NotificationChannelCreateRequest.
type NotificationChannelCreateRequest struct {
	union json.RawMessage
}

// NotificationChannelMeta Limited representation of notification channel which includes only the channel identifier and its type.
type NotificationChannelMeta struct {
	// Id A unique identifier for the notification channel.
	Id string `json:"id"`

	// Type The type of the notification channel.
	Type NotificationChannelType `json:"type"`
}

// NotificationChannelType The type of the notification channel.
type NotificationChannelType string

// NotificationChannelWebhook defines model for NotificationChannelWebhook.
type NotificationChannelWebhook struct {
	// CreatedAt Timestamp when the channel was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CustomHeaders Custom HTTP headers sent as part of the webhook request.
	CustomHeaders *map[string]interface{} `json:"customHeaders"`

	// Disabled Whether the channel is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Id A unique identifier for the notification channel.
	Id string `json:"id"`

	// Name User friendly name of the channel.
	Name *string `json:"name,omitempty"`

	// SigningSecret Signing secret used for webhook request validation on the receiving end.
	//
	// Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
	SigningSecret string `json:"signingSecret"`

	// Type The type of the notification channel.
	Type NotificationChannelType `json:"type"`

	// UpdatedAt Timestamp when the channel was modified.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Url Webhook URL where the notification is sent.
	Url string `json:"url"`
}

// NotificationChannelWebhookCreateRequest defines model for NotificationChannelWebhookCreateRequest.
type NotificationChannelWebhookCreateRequest struct {
	// CustomHeaders Custom HTTP headers sent as part of the webhook request.
	CustomHeaders *map[string]interface{} `json:"customHeaders"`

	// Disabled Whether the channel is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Name User friendly name of the channel.
	Name string `json:"name"`

	// SigningSecret Signing secret used for webhook request validation on the receiving end. Automatically generated if not provided.
	//
	// Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
	SigningSecret *string `json:"signingSecret"`

	// Type The type of the notification channel.
	Type NotificationChannelType `json:"type"`

	// Url Webhook URL where the notification is sent.
	Url string `json:"url"`
}

// NotificationChannels defines model for NotificationChannels.
type NotificationChannels = []NotificationChannel

// NotificationEvent Notification event generated by the system based on the criteria defined in the corresponding
// a notification rule.
//
// The `payload` field contains the actual message sent to the notification channel.
type NotificationEvent struct {
	// CreatedAt Timestamp when the notification event was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeliveryStatus The delivery status of the notification event.
	DeliveryStatus []NotificationEventDeliveryStatus `json:"deliveryStatus"`

	// Id A unique identifier for the notification event.
	Id string `json:"id"`

	// Payload The actual payload sent to channel as part of the notification event.
	Payload NotificationEventPayload `json:"payload"`

	// Rule Defines the common fields of a notification rule.
	Rule *NotificationRuleMeta `json:"rule,omitempty"`
}

// NotificationEventBalanceThresholdPayload defines model for NotificationEventBalanceThresholdPayload.
type NotificationEventBalanceThresholdPayload struct {
	Data struct {
		Balance EntitlementValue `json:"balance"`

		// Entitlement Metered entitlements are useful for many different use cases, from setting up usage based access to implementing complex credit systems. Access is determined based on feature usage using a balance calculation (the "usage allowance" provided by the issued grants is "burnt down" by the usage).
		Entitlement EntitlementMetered `json:"entitlement"`

		// Feature A feature is a feature or service offered to a customer.
		// For example: CPU-Hours, Tokens, API Calls, etc.
		Feature Feature `json:"feature"`

		// Subject A subject is a unique identifier for a user or entity.
		Subject Subject `json:"subject"`

		// Threshold Threshold value with multiple supported types.
		Threshold NotificationRuleBalanceThresholdValue `json:"threshold"`
	} `json:"data"`

	// Id A unique identifier for the notification event the payload belongs to.
	Id string `json:"id"`

	// Timestamp Timestamp when the notification event was created.
	Timestamp time.Time `json:"timestamp"`

	// Type The type of the notification event.
	Type NotificationEventType `json:"type"`
}

// NotificationEventCommonPayload Common fields for notification event payload.
type NotificationEventCommonPayload struct {
	// Id A unique identifier for the notification event the payload belongs to.
	Id string `json:"id"`

	// Timestamp Timestamp when the notification event was created.
	Timestamp time.Time `json:"timestamp"`

	// Type The type of the notification event.
	Type NotificationEventType `json:"type"`
}

// NotificationEventDeliveryStatus defines model for NotificationEventDeliveryStatus.
type NotificationEventDeliveryStatus struct {
	// Channel Limited representation of notification channel which includes only the channel identifier and its type.
	Channel   NotificationChannelMeta              `json:"channel"`
	State     NotificationEventDeliveryStatusState `json:"state"`
	UpdatedAt time.Time                            `json:"updatedAt"`
}

// NotificationEventDeliveryStatusState defines model for NotificationEventDeliveryStatus.State.
type NotificationEventDeliveryStatusState string

// NotificationEventPayload The actual payload sent to channel as part of the notification event.
type NotificationEventPayload struct {
	union json.RawMessage
}

// NotificationEventType The type of the notification event.
type NotificationEventType string

// NotificationRule defines model for NotificationRule.
type NotificationRule struct {
	union json.RawMessage
}

// NotificationRuleBalanceThreshold defines model for NotificationRuleBalanceThreshold.
type NotificationRuleBalanceThreshold struct {
	// Channels List of notification channels the rule applies to.
	Channels *[]NotificationChannelMeta `json:"channels,omitempty"`

	// CreatedAt Timestamp when the rule was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Features Optional field containing list of features the rule applies to.
	Features *[]FeatureMeta `json:"features"`

	// Id A unique identifier for the notification rule.
	Id string `json:"id"`

	// Name The user friendly name of the notification rule.
	Name *string `json:"name,omitempty"`

	// Thresholds List of thresholds the rule suppose to be triggered.
	Thresholds []NotificationRuleBalanceThresholdValue `json:"thresholds"`

	// Type The type of the notification event.
	Type NotificationEventType `json:"type"`

	// UpdatedAt Timestamp when the rule was modified.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// NotificationRuleBalanceThresholdCreateRequest defines model for NotificationRuleBalanceThresholdCreateRequest.
type NotificationRuleBalanceThresholdCreateRequest struct {
	// Channels List of notification channel identifiers or names the rule applies to.
	Channels []string `json:"channels"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Features Optional field for defining the scope of notification by feature. It may contain features by id or key.
	Features *[]string `json:"features"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Thresholds List of thresholds the rule suppose to be triggered.
	Thresholds []NotificationRuleBalanceThresholdValue `json:"thresholds"`

	// Type The type of the notification event.
	Type NotificationEventType `json:"type"`
}

// NotificationRuleBalanceThresholdValue Threshold value with multiple supported types.
type NotificationRuleBalanceThresholdValue struct {
	Type  NotificationRuleBalanceThresholdValueType `json:"type"`
	Value float64                                   `json:"value"`
}

// NotificationRuleBalanceThresholdValueType defines model for NotificationRuleBalanceThresholdValue.Type.
type NotificationRuleBalanceThresholdValueType string

// NotificationRuleCommon defines model for NotificationRuleCommon.
type NotificationRuleCommon struct {
	// Channels List of notification channels the rule applies to.
	Channels *[]NotificationChannelMeta `json:"channels,omitempty"`

	// CreatedAt Timestamp when the rule was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Id A unique identifier for the notification rule.
	Id string `json:"id"`

	// Name The user friendly name of the notification rule.
	Name *string `json:"name,omitempty"`

	// Type The type of the notification event.
	Type NotificationEventType `json:"type"`

	// UpdatedAt Timestamp when the rule was modified.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// NotificationRuleCommonCreateRequest Defines the common fields for create notification rule request.
type NotificationRuleCommonCreateRequest struct {
	// Channels List of notification channel identifiers or names the rule applies to.
	Channels []string `json:"channels"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Type The type of the notification event.
	Type NotificationEventType `json:"type"`
}

// NotificationRuleCreateRequest defines model for NotificationRuleCreateRequest.
type NotificationRuleCreateRequest struct {
	union json.RawMessage
}

// NotificationRuleMeta Defines the common fields of a notification rule.
type NotificationRuleMeta struct {
	// Id A unique identifier for the notification rule.
	Id string `json:"id"`

	// Type The type of the notification event.
	Type NotificationEventType `json:"type"`
}

// NotificationRules defines model for NotificationRules.
type NotificationRules = []NotificationRule

// Period A time period
type Period struct {
	// From Period start time where the amount was applied. If applicable.
	From time.Time `json:"from"`

	// To Period end time where the amount was applied. If applicable.
	To time.Time `json:"to"`
}

// PortalToken A consumer portal token.
type PortalToken struct {
	// AllowedMeterSlugs Optional, if defined only the specified meters will be allowed
	AllowedMeterSlugs *[]string  `json:"allowedMeterSlugs,omitempty"`
	CreatedAt         *time.Time `json:"createdAt,omitempty"`
	Expired           *bool      `json:"expired,omitempty"`
	ExpiresAt         *time.Time `json:"expiresAt,omitempty"`
	Id                *string    `json:"id,omitempty"`
	Subject           string     `json:"subject"`

	// Token The token is only returned at creation.
	Token *string `json:"token,omitempty"`
}

// Problem A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type Problem = models.StatusProblem

// RecurringPeriod Recurring period of an entitlement.
type RecurringPeriod struct {
	// Anchor An arbitrary anchor to base the recurring period on.
	Anchor time.Time `json:"anchor"`

	// Interval List of pre-defined periods that can be used for recurring & scheduling.
	//
	// DAY:      Every day
	// WEEK:     Every week
	// MONTH:    Every month
	// YEAR:     Every year
	Interval RecurringPeriodEnum `json:"interval"`
}

// RecurringPeriodCreateInput Recurring period of an entitlement.
type RecurringPeriodCreateInput struct {
	// Anchor An arbitrary anchor to base the recurring period on.
	// If not provided then defaults to now truncated to the hour.
	Anchor *time.Time `json:"anchor,omitempty"`

	// Interval List of pre-defined periods that can be used for recurring & scheduling.
	//
	// DAY:      Every day
	// WEEK:     Every week
	// MONTH:    Every month
	// YEAR:     Every year
	Interval RecurringPeriodEnum `json:"interval"`
}

// RecurringPeriodEnum List of pre-defined periods that can be used for recurring & scheduling.
//
// DAY:      Every day
// WEEK:     Every week
// MONTH:    Every month
// YEAR:     Every year
type RecurringPeriodEnum string

// SharedMetaFields Metadata fields for all resources.
// These fields are automatically populated by the system for managed entities. Their use and meaning is uniform across all resources.
type SharedMetaFields struct {
	// CreatedAt The date and time the resource was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DeletedAt The date and time the resource was deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Id Readonly unique ULID identifier.
	Id *string `json:"id,omitempty"`

	// UpdatedAt The date and time the resource was last updated. The initial value is the same as createdAt.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Subject A subject is a unique identifier for a user or entity.
type Subject struct {
	CurrentPeriodEnd   *time.Time              `json:"currentPeriodEnd"`
	CurrentPeriodStart *time.Time              `json:"currentPeriodStart"`
	DisplayName        *string                 `json:"displayName"`
	Id                 *string                 `json:"id,omitempty"`
	Key                string                  `json:"key"`
	Metadata           *map[string]interface{} `json:"metadata"`
	StripeCustomerId   *string                 `json:"stripeCustomerId"`
}

// WindowSize Aggregation window size.
type WindowSize = models.WindowSize

// WindowedBalanceHistory The windowed balance history.
type WindowedBalanceHistory struct {
	// BurndownHistory Grant burndown history.
	BurndownHistory *[]GrantBurnDownHistorySegment `json:"burndownHistory,omitempty"`

	// WindowedHistory The windowed balance history.
	// - It only returns rows for windows where there was usage.
	// - The windows are inclusive at their start and exclusive at their end.
	// - The last window may be smaller than the window size and is inclusive at both ends.
	WindowedHistory *[]BalanceHistoryWindow `json:"windowedHistory,omitempty"`
}

// ChannelId defines model for channelId.
type ChannelId = string

// EntitlementId defines model for entitlementId.
type EntitlementId = string

// EntitlementIdOrFeatureKey defines model for entitlementIdOrFeatureKey.
type EntitlementIdOrFeatureKey = string

// EventId defines model for eventId.
type EventId = string

// FeatureId defines model for featureId.
type FeatureId = string

// GrantId defines model for grantId.
type GrantId = string

// IncludeDeleted defines model for includeDeleted.
type IncludeDeleted = bool

// MeterIdOrSlug A unique identifier.
type MeterIdOrSlug = IdOrSlug

// QueryFilterFeature defines model for queryFilterFeature.
type QueryFilterFeature = []string

// QueryFilterGroupBy Simple filter for group bys with exact match.
//
// Usage: `?filterGroupBy[type]=input&filterGroupBy[model]=gpt-4`
type QueryFilterGroupBy map[string]string

// QueryFilterSubject defines model for queryFilterSubject.
type QueryFilterSubject = []string

// QueryFrom defines model for queryFrom.
type QueryFrom = time.Time

// QueryGroupBy defines model for queryGroupBy.
type QueryGroupBy = []string

// QueryIncludeDisabled defines model for queryIncludeDisabled.
type QueryIncludeDisabled = bool

// QueryLimit defines model for queryLimit.
type QueryLimit = int

// QueryOffset defines model for queryOffset.
type QueryOffset = int

// QueryPage defines model for queryPage.
type QueryPage = int

// QueryPageSize defines model for queryPageSize.
type QueryPageSize = int

// QueryTo defines model for queryTo.
type QueryTo = time.Time

// QueryWindowSize Aggregation window size.
type QueryWindowSize = WindowSize

// QueryWindowTimeZone defines model for queryWindowTimeZone.
type QueryWindowTimeZone = string

// RuleId defines model for ruleId.
type RuleId = string

// SubjectIdOrKey defines model for subjectIdOrKey.
type SubjectIdOrKey = string

// BadRequestProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type BadRequestProblemResponse = Problem

// ConflictProblemResponse Conflict
type ConflictProblemResponse = ConflictProblem

// NotFoundProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type NotFoundProblemResponse = Problem

// NotImplementedProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type NotImplementedProblemResponse = Problem

// UnauthorizedProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type UnauthorizedProblemResponse = Problem

// UnexpectedProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type UnexpectedProblemResponse = Problem

// ListEntitlementsParams defines parameters for ListEntitlements.
type ListEntitlementsParams struct {
	// Page Page number to return
	Page *QueryPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of entries to return per page
	PageSize *QueryPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Limit Number of entries to return
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of entries to skip
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// OrderBy Order by field
	OrderBy *ListEntitlementsParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListEntitlementsParamsOrderBy defines parameters for ListEntitlements.
type ListEntitlementsParamsOrderBy string

// ListEventsParams defines parameters for ListEvents.
type ListEventsParams struct {
	// From Start date-time in RFC 3339 format.
	// Inclusive.
	From *QueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	// Inclusive.
	To *QueryTo `form:"to,omitempty" json:"to,omitempty"`

	// Limit Number of events to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// IngestEventsApplicationCloudeventsBatchPlusJSONBody defines parameters for IngestEvents.
type IngestEventsApplicationCloudeventsBatchPlusJSONBody = []Event

// ListFeaturesParams defines parameters for ListFeatures.
type ListFeaturesParams struct {
	// Page Page number to return
	Page *QueryPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of entries to return per page
	PageSize *QueryPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Limit Number of entries to return
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of entries to skip
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// OrderBy Order by field
	OrderBy *ListFeaturesParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// IncludeArchived Include archived features.
	IncludeArchived *bool `form:"includeArchived,omitempty" json:"includeArchived,omitempty"`
}

// ListFeaturesParamsOrderBy defines parameters for ListFeatures.
type ListFeaturesParamsOrderBy string

// ListGrantsParams defines parameters for ListGrants.
type ListGrantsParams struct {
	// Page Page number to return
	Page *QueryPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of entries to return per page
	PageSize *QueryPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Limit Number of entries to return
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of entries to skip
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// OrderBy Order by field
	OrderBy *ListGrantsParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// IncludeDeleted Include deleted entries.
	IncludeDeleted *IncludeDeleted `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`
}

// ListGrantsParamsOrderBy defines parameters for ListGrants.
type ListGrantsParamsOrderBy string

// QueryMeterParams defines parameters for QueryMeter.
type QueryMeterParams struct {
	// From Start date-time in RFC 3339 format.
	// Inclusive.
	From *QueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	// Inclusive.
	To *QueryTo `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.
	WindowSize *QueryWindowSize `form:"windowSize,omitempty" json:"windowSize,omitempty"`

	// WindowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
	// If not specified, the UTC timezone will be used.
	WindowTimeZone *QueryWindowTimeZone `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`

	// Subject Filtering by multiple subjects.
	//
	// Usage: `?subject=customer-1&subject=customer-2`
	Subject       *QueryFilterSubject `form:"subject,omitempty" json:"subject,omitempty"`
	FilterGroupBy *QueryFilterGroupBy `json:"filterGroupBy,omitempty"`

	// GroupBy If not specified a single aggregate will be returned for each subject and time window.
	// `subject` is a reserved group by value.
	GroupBy *QueryGroupBy `form:"groupBy,omitempty" json:"groupBy,omitempty"`
}

// ListNotificationChannelsParams defines parameters for ListNotificationChannels.
type ListNotificationChannelsParams struct {
	// Limit Number of entries to return
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of entries to skip
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// OrderBy Order by field
	OrderBy *ListNotificationChannelsParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// IncludeDisabled Include disabled entries.
	IncludeDisabled *QueryIncludeDisabled `form:"includeDisabled,omitempty" json:"includeDisabled,omitempty"`
}

// ListNotificationChannelsParamsOrderBy defines parameters for ListNotificationChannels.
type ListNotificationChannelsParamsOrderBy string

// ListNotificationEventsParams defines parameters for ListNotificationEvents.
type ListNotificationEventsParams struct {
	// Limit Number of entries to return
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of entries to skip
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// OrderBy Order by field
	OrderBy *ListNotificationEventsParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// Feature Filtering by multiple features.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *QueryFilterFeature `form:"feature,omitempty" json:"feature,omitempty"`

	// Subject Filtering by multiple subjects.
	//
	// Usage: `?subject=customer-1&subject=customer-2`
	Subject *QueryFilterSubject `form:"subject,omitempty" json:"subject,omitempty"`
}

// ListNotificationEventsParamsOrderBy defines parameters for ListNotificationEvents.
type ListNotificationEventsParamsOrderBy string

// ListNotificationRulesParams defines parameters for ListNotificationRules.
type ListNotificationRulesParams struct {
	// Limit Number of entries to return
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of entries to skip
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// OrderBy Order by field
	OrderBy *ListNotificationRulesParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// IncludeDisabled Include disabled entries.
	IncludeDisabled *QueryIncludeDisabled `form:"includeDisabled,omitempty" json:"includeDisabled,omitempty"`

	// Feature Filtering by multiple features.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *QueryFilterFeature `form:"feature,omitempty" json:"feature,omitempty"`
}

// ListNotificationRulesParamsOrderBy defines parameters for ListNotificationRules.
type ListNotificationRulesParamsOrderBy string

// QueryPortalMeterParams defines parameters for QueryPortalMeter.
type QueryPortalMeterParams struct {
	// From Start date-time in RFC 3339 format.
	// Inclusive.
	From *QueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	// Inclusive.
	To *QueryTo `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.
	WindowSize *QueryWindowSize `form:"windowSize,omitempty" json:"windowSize,omitempty"`

	// WindowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
	// If not specified, the UTC timezone will be used.
	WindowTimeZone *QueryWindowTimeZone `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`
	FilterGroupBy  *QueryFilterGroupBy  `json:"filterGroupBy,omitempty"`

	// GroupBy If not specified a single aggregate will be returned for each subject and time window.
	// `subject` is a reserved group by value.
	GroupBy *QueryGroupBy `form:"groupBy,omitempty" json:"groupBy,omitempty"`
}

// ListPortalTokensParams defines parameters for ListPortalTokens.
type ListPortalTokensParams struct {
	// Limit Number of portal tokens to return. Default is 25.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// InvalidatePortalTokensJSONBody defines parameters for InvalidatePortalTokens.
type InvalidatePortalTokensJSONBody struct {
	// Id Invalidate a portal token by ID.
	Id *string `json:"id,omitempty"`

	// Subject Invalidate all portal tokens for a subject.
	Subject *string `json:"subject,omitempty"`
}

// UpsertSubjectJSONBody defines parameters for UpsertSubject.
type UpsertSubjectJSONBody = []Subject

// ListSubjectEntitlementsParams defines parameters for ListSubjectEntitlements.
type ListSubjectEntitlementsParams struct {
	// IncludeDeleted Include deleted entries.
	IncludeDeleted *IncludeDeleted `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`
}

// ListEntitlementGrantsParams defines parameters for ListEntitlementGrants.
type ListEntitlementGrantsParams struct {
	// IncludeDeleted Include deleted entries.
	IncludeDeleted *IncludeDeleted `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// OrderBy Order by field
	OrderBy *ListEntitlementGrantsParamsOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListEntitlementGrantsParamsOrderBy defines parameters for ListEntitlementGrants.
type ListEntitlementGrantsParamsOrderBy string

// GetEntitlementValueParams defines parameters for GetEntitlementValue.
type GetEntitlementValueParams struct {
	// Time Point of time to check value: date-time in RFC 3339 format. Defaults to now.
	Time *time.Time `form:"time,omitempty" json:"time,omitempty"`
}

// GetEntitlementHistoryParams defines parameters for GetEntitlementHistory.
type GetEntitlementHistoryParams struct {
	// From Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to
	// the last reset.
	// Gets truncated to the granularity of the underlying meter.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.
	// If not now then gets truncated to the granularity of the underlying meter.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize Size of the time window to group the history by. Cannot be shorter than meter granularity.
	WindowSize GetEntitlementHistoryParamsWindowSize `form:"windowSize" json:"windowSize"`

	// WindowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
	// If not specified, the UTC timezone will be used.
	WindowTimeZone *QueryWindowTimeZone `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`
}

// GetEntitlementHistoryParamsWindowSize defines parameters for GetEntitlementHistory.
type GetEntitlementHistoryParamsWindowSize string

// ResetEntitlementUsageJSONBody defines parameters for ResetEntitlementUsage.
type ResetEntitlementUsageJSONBody struct {
	// EffectiveAt The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.
	EffectiveAt *time.Time `json:"effectiveAt,omitempty"`

	// RetainAnchor Determines whether the usage period anchor is retained or reset to the effectiveAt time.
	// - If true, the usage period anchor is retained.
	// - If false, the usage period anchor is reset to the effectiveAt time.
	RetainAnchor *bool `json:"retainAnchor,omitempty"`
}

// IngestEventsApplicationCloudeventsPlusJSONRequestBody defines body for IngestEvents for application/cloudevents+json ContentType.
type IngestEventsApplicationCloudeventsPlusJSONRequestBody = Event

// IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody defines body for IngestEvents for application/cloudevents-batch+json ContentType.
type IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody = IngestEventsApplicationCloudeventsBatchPlusJSONBody

// CreateFeatureJSONRequestBody defines body for CreateFeature for application/json ContentType.
type CreateFeatureJSONRequestBody = FeatureCreateInputs

// CreateMeterJSONRequestBody defines body for CreateMeter for application/json ContentType.
type CreateMeterJSONRequestBody = Meter

// CreateNotificationChannelJSONRequestBody defines body for CreateNotificationChannel for application/json ContentType.
type CreateNotificationChannelJSONRequestBody = NotificationChannelCreateRequest

// UpdateNotificationChannelJSONRequestBody defines body for UpdateNotificationChannel for application/json ContentType.
type UpdateNotificationChannelJSONRequestBody = NotificationChannelCreateRequest

// CreateNotificationRuleJSONRequestBody defines body for CreateNotificationRule for application/json ContentType.
type CreateNotificationRuleJSONRequestBody = NotificationRuleCreateRequest

// UpdateNotificationRuleJSONRequestBody defines body for UpdateNotificationRule for application/json ContentType.
type UpdateNotificationRuleJSONRequestBody = NotificationRuleCreateRequest

// CreatePortalTokenJSONRequestBody defines body for CreatePortalToken for application/json ContentType.
type CreatePortalTokenJSONRequestBody = PortalToken

// InvalidatePortalTokensJSONRequestBody defines body for InvalidatePortalTokens for application/json ContentType.
type InvalidatePortalTokensJSONRequestBody InvalidatePortalTokensJSONBody

// UpsertSubjectJSONRequestBody defines body for UpsertSubject for application/json ContentType.
type UpsertSubjectJSONRequestBody = UpsertSubjectJSONBody

// CreateEntitlementJSONRequestBody defines body for CreateEntitlement for application/json ContentType.
type CreateEntitlementJSONRequestBody = EntitlementCreateInputs

// CreateGrantJSONRequestBody defines body for CreateGrant for application/json ContentType.
type CreateGrantJSONRequestBody = EntitlementGrantCreateInput

// ResetEntitlementUsageJSONRequestBody defines body for ResetEntitlementUsage for application/json ContentType.
type ResetEntitlementUsageJSONRequestBody ResetEntitlementUsageJSONBody

// Getter for additional properties for ConflictProblem. Returns the specified
// element and whether it was found
func (a ConflictProblem) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConflictProblem
func (a *ConflictProblem) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConflictProblem to handle AdditionalProperties
func (a *ConflictProblem) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &a.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
		delete(object, "detail")
	}

	if raw, found := object["extensions"]; found {
		err = json.Unmarshal(raw, &a.Extensions)
		if err != nil {
			return fmt.Errorf("error reading 'extensions': %w", err)
		}
		delete(object, "extensions")
	}

	if raw, found := object["instance"]; found {
		err = json.Unmarshal(raw, &a.Instance)
		if err != nil {
			return fmt.Errorf("error reading 'instance': %w", err)
		}
		delete(object, "instance")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConflictProblem to handle AdditionalProperties
func (a ConflictProblem) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["detail"], err = json.Marshal(a.Detail)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'detail': %w", err)
	}

	if a.Extensions != nil {
		object["extensions"], err = json.Marshal(a.Extensions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'extensions': %w", err)
		}
	}

	if a.Instance != nil {
		object["instance"], err = json.Marshal(a.Instance)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'instance': %w", err)
		}
	}

	object["status"], err = json.Marshal(a.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsEntitlementMetered returns the union data inside the Entitlement as a EntitlementMetered
func (t Entitlement) AsEntitlementMetered() (EntitlementMetered, error) {
	var body EntitlementMetered
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementMetered overwrites any union data inside the Entitlement as the provided EntitlementMetered
func (t *Entitlement) FromEntitlementMetered(v EntitlementMetered) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementMetered performs a merge with any union data inside the Entitlement, using the provided EntitlementMetered
func (t *Entitlement) MergeEntitlementMetered(v EntitlementMetered) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementStatic returns the union data inside the Entitlement as a EntitlementStatic
func (t Entitlement) AsEntitlementStatic() (EntitlementStatic, error) {
	var body EntitlementStatic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementStatic overwrites any union data inside the Entitlement as the provided EntitlementStatic
func (t *Entitlement) FromEntitlementStatic(v EntitlementStatic) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementStatic performs a merge with any union data inside the Entitlement, using the provided EntitlementStatic
func (t *Entitlement) MergeEntitlementStatic(v EntitlementStatic) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementBoolean returns the union data inside the Entitlement as a EntitlementBoolean
func (t Entitlement) AsEntitlementBoolean() (EntitlementBoolean, error) {
	var body EntitlementBoolean
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementBoolean overwrites any union data inside the Entitlement as the provided EntitlementBoolean
func (t *Entitlement) FromEntitlementBoolean(v EntitlementBoolean) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementBoolean performs a merge with any union data inside the Entitlement, using the provided EntitlementBoolean
func (t *Entitlement) MergeEntitlementBoolean(v EntitlementBoolean) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Entitlement) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Entitlement) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsEntitlementBoolean()
	case "metered":
		return t.AsEntitlementMetered()
	case "static":
		return t.AsEntitlementStatic()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Entitlement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Entitlement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEntitlementMeteredCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementMeteredCreateInputs
func (t EntitlementCreateInputs) AsEntitlementMeteredCreateInputs() (EntitlementMeteredCreateInputs, error) {
	var body EntitlementMeteredCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementMeteredCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementMeteredCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementMeteredCreateInputs(v EntitlementMeteredCreateInputs) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementMeteredCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementMeteredCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementMeteredCreateInputs(v EntitlementMeteredCreateInputs) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementStaticCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementStaticCreateInputs
func (t EntitlementCreateInputs) AsEntitlementStaticCreateInputs() (EntitlementStaticCreateInputs, error) {
	var body EntitlementStaticCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementStaticCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementStaticCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementStaticCreateInputs(v EntitlementStaticCreateInputs) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementStaticCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementStaticCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementStaticCreateInputs(v EntitlementStaticCreateInputs) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementBooleanCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementBooleanCreateInputs
func (t EntitlementCreateInputs) AsEntitlementBooleanCreateInputs() (EntitlementBooleanCreateInputs, error) {
	var body EntitlementBooleanCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementBooleanCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementBooleanCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementBooleanCreateInputs(v EntitlementBooleanCreateInputs) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementBooleanCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementBooleanCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementBooleanCreateInputs(v EntitlementBooleanCreateInputs) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntitlementCreateInputs) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EntitlementCreateInputs) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsEntitlementBooleanCreateInputs()
	case "metered":
		return t.AsEntitlementMeteredCreateInputs()
	case "static":
		return t.AsEntitlementStaticCreateInputs()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EntitlementCreateInputs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntitlementCreateInputs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsListEntitlementGrantResponse0 returns the union data inside the ListEntitlementGrantResponse as a ListEntitlementGrantResponse0
func (t ListEntitlementGrantResponse) AsListEntitlementGrantResponse0() (ListEntitlementGrantResponse0, error) {
	var body ListEntitlementGrantResponse0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListEntitlementGrantResponse0 overwrites any union data inside the ListEntitlementGrantResponse as the provided ListEntitlementGrantResponse0
func (t *ListEntitlementGrantResponse) FromListEntitlementGrantResponse0(v ListEntitlementGrantResponse0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListEntitlementGrantResponse0 performs a merge with any union data inside the ListEntitlementGrantResponse, using the provided ListEntitlementGrantResponse0
func (t *ListEntitlementGrantResponse) MergeListEntitlementGrantResponse0(v ListEntitlementGrantResponse0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsListEntitlementGrantResponse1 returns the union data inside the ListEntitlementGrantResponse as a ListEntitlementGrantResponse1
func (t ListEntitlementGrantResponse) AsListEntitlementGrantResponse1() (ListEntitlementGrantResponse1, error) {
	var body ListEntitlementGrantResponse1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListEntitlementGrantResponse1 overwrites any union data inside the ListEntitlementGrantResponse as the provided ListEntitlementGrantResponse1
func (t *ListEntitlementGrantResponse) FromListEntitlementGrantResponse1(v ListEntitlementGrantResponse1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListEntitlementGrantResponse1 performs a merge with any union data inside the ListEntitlementGrantResponse, using the provided ListEntitlementGrantResponse1
func (t *ListEntitlementGrantResponse) MergeListEntitlementGrantResponse1(v ListEntitlementGrantResponse1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ListEntitlementGrantResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ListEntitlementGrantResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsListEntitlementResponse0 returns the union data inside the ListEntitlementResponse as a ListEntitlementResponse0
func (t ListEntitlementResponse) AsListEntitlementResponse0() (ListEntitlementResponse0, error) {
	var body ListEntitlementResponse0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListEntitlementResponse0 overwrites any union data inside the ListEntitlementResponse as the provided ListEntitlementResponse0
func (t *ListEntitlementResponse) FromListEntitlementResponse0(v ListEntitlementResponse0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListEntitlementResponse0 performs a merge with any union data inside the ListEntitlementResponse, using the provided ListEntitlementResponse0
func (t *ListEntitlementResponse) MergeListEntitlementResponse0(v ListEntitlementResponse0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsListEntitlementResponse1 returns the union data inside the ListEntitlementResponse as a ListEntitlementResponse1
func (t ListEntitlementResponse) AsListEntitlementResponse1() (ListEntitlementResponse1, error) {
	var body ListEntitlementResponse1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListEntitlementResponse1 overwrites any union data inside the ListEntitlementResponse as the provided ListEntitlementResponse1
func (t *ListEntitlementResponse) FromListEntitlementResponse1(v ListEntitlementResponse1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListEntitlementResponse1 performs a merge with any union data inside the ListEntitlementResponse, using the provided ListEntitlementResponse1
func (t *ListEntitlementResponse) MergeListEntitlementResponse1(v ListEntitlementResponse1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ListEntitlementResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ListEntitlementResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsListFeatureResponse0 returns the union data inside the ListFeatureResponse as a ListFeatureResponse0
func (t ListFeatureResponse) AsListFeatureResponse0() (ListFeatureResponse0, error) {
	var body ListFeatureResponse0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListFeatureResponse0 overwrites any union data inside the ListFeatureResponse as the provided ListFeatureResponse0
func (t *ListFeatureResponse) FromListFeatureResponse0(v ListFeatureResponse0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListFeatureResponse0 performs a merge with any union data inside the ListFeatureResponse, using the provided ListFeatureResponse0
func (t *ListFeatureResponse) MergeListFeatureResponse0(v ListFeatureResponse0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsListFeatureResponse1 returns the union data inside the ListFeatureResponse as a ListFeatureResponse1
func (t ListFeatureResponse) AsListFeatureResponse1() (ListFeatureResponse1, error) {
	var body ListFeatureResponse1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListFeatureResponse1 overwrites any union data inside the ListFeatureResponse as the provided ListFeatureResponse1
func (t *ListFeatureResponse) FromListFeatureResponse1(v ListFeatureResponse1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListFeatureResponse1 performs a merge with any union data inside the ListFeatureResponse, using the provided ListFeatureResponse1
func (t *ListFeatureResponse) MergeListFeatureResponse1(v ListFeatureResponse1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ListFeatureResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ListFeatureResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotificationChannelWebhook returns the union data inside the NotificationChannel as a NotificationChannelWebhook
func (t NotificationChannel) AsNotificationChannelWebhook() (NotificationChannelWebhook, error) {
	var body NotificationChannelWebhook
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationChannelWebhook overwrites any union data inside the NotificationChannel as the provided NotificationChannelWebhook
func (t *NotificationChannel) FromNotificationChannelWebhook(v NotificationChannelWebhook) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationChannelWebhook performs a merge with any union data inside the NotificationChannel, using the provided NotificationChannelWebhook
func (t *NotificationChannel) MergeNotificationChannelWebhook(v NotificationChannelWebhook) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NotificationChannel) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NotificationChannel) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "WEBHOOK":
		return t.AsNotificationChannelWebhook()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NotificationChannel) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NotificationChannel) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotificationChannelWebhookCreateRequest returns the union data inside the NotificationChannelCreateRequest as a NotificationChannelWebhookCreateRequest
func (t NotificationChannelCreateRequest) AsNotificationChannelWebhookCreateRequest() (NotificationChannelWebhookCreateRequest, error) {
	var body NotificationChannelWebhookCreateRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationChannelWebhookCreateRequest overwrites any union data inside the NotificationChannelCreateRequest as the provided NotificationChannelWebhookCreateRequest
func (t *NotificationChannelCreateRequest) FromNotificationChannelWebhookCreateRequest(v NotificationChannelWebhookCreateRequest) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationChannelWebhookCreateRequest performs a merge with any union data inside the NotificationChannelCreateRequest, using the provided NotificationChannelWebhookCreateRequest
func (t *NotificationChannelCreateRequest) MergeNotificationChannelWebhookCreateRequest(v NotificationChannelWebhookCreateRequest) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NotificationChannelCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NotificationChannelCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "WEBHOOK":
		return t.AsNotificationChannelWebhookCreateRequest()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NotificationChannelCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NotificationChannelCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotificationEventBalanceThresholdPayload returns the union data inside the NotificationEventPayload as a NotificationEventBalanceThresholdPayload
func (t NotificationEventPayload) AsNotificationEventBalanceThresholdPayload() (NotificationEventBalanceThresholdPayload, error) {
	var body NotificationEventBalanceThresholdPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationEventBalanceThresholdPayload overwrites any union data inside the NotificationEventPayload as the provided NotificationEventBalanceThresholdPayload
func (t *NotificationEventPayload) FromNotificationEventBalanceThresholdPayload(v NotificationEventBalanceThresholdPayload) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationEventBalanceThresholdPayload performs a merge with any union data inside the NotificationEventPayload, using the provided NotificationEventBalanceThresholdPayload
func (t *NotificationEventPayload) MergeNotificationEventBalanceThresholdPayload(v NotificationEventBalanceThresholdPayload) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NotificationEventPayload) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NotificationEventPayload) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "entitlements.balance.threshold":
		return t.AsNotificationEventBalanceThresholdPayload()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NotificationEventPayload) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NotificationEventPayload) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotificationRuleBalanceThreshold returns the union data inside the NotificationRule as a NotificationRuleBalanceThreshold
func (t NotificationRule) AsNotificationRuleBalanceThreshold() (NotificationRuleBalanceThreshold, error) {
	var body NotificationRuleBalanceThreshold
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationRuleBalanceThreshold overwrites any union data inside the NotificationRule as the provided NotificationRuleBalanceThreshold
func (t *NotificationRule) FromNotificationRuleBalanceThreshold(v NotificationRuleBalanceThreshold) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationRuleBalanceThreshold performs a merge with any union data inside the NotificationRule, using the provided NotificationRuleBalanceThreshold
func (t *NotificationRule) MergeNotificationRuleBalanceThreshold(v NotificationRuleBalanceThreshold) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NotificationRule) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NotificationRule) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "entitlements.balance.threshold":
		return t.AsNotificationRuleBalanceThreshold()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NotificationRule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NotificationRule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNotificationRuleBalanceThresholdCreateRequest returns the union data inside the NotificationRuleCreateRequest as a NotificationRuleBalanceThresholdCreateRequest
func (t NotificationRuleCreateRequest) AsNotificationRuleBalanceThresholdCreateRequest() (NotificationRuleBalanceThresholdCreateRequest, error) {
	var body NotificationRuleBalanceThresholdCreateRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNotificationRuleBalanceThresholdCreateRequest overwrites any union data inside the NotificationRuleCreateRequest as the provided NotificationRuleBalanceThresholdCreateRequest
func (t *NotificationRuleCreateRequest) FromNotificationRuleBalanceThresholdCreateRequest(v NotificationRuleBalanceThresholdCreateRequest) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNotificationRuleBalanceThresholdCreateRequest performs a merge with any union data inside the NotificationRuleCreateRequest, using the provided NotificationRuleBalanceThresholdCreateRequest
func (t *NotificationRuleCreateRequest) MergeNotificationRuleBalanceThresholdCreateRequest(v NotificationRuleBalanceThresholdCreateRequest) error {
	v.Type = "entitlements.balance.threshold"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NotificationRuleCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NotificationRuleCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "entitlements.balance.threshold":
		return t.AsNotificationRuleBalanceThresholdCreateRequest()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NotificationRuleCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NotificationRuleCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get event metrics
	// (GET /api/v1/debug/metrics)
	GetDebugMetrics(w http.ResponseWriter, r *http.Request)
	// List entitlements
	// (GET /api/v1/entitlements)
	ListEntitlements(w http.ResponseWriter, r *http.Request, params ListEntitlementsParams)
	// List ingested events
	// (GET /api/v1/events)
	ListEvents(w http.ResponseWriter, r *http.Request, params ListEventsParams)
	// Ingest events
	// (POST /api/v1/events)
	IngestEvents(w http.ResponseWriter, r *http.Request)
	// List features
	// (GET /api/v1/features)
	ListFeatures(w http.ResponseWriter, r *http.Request, params ListFeaturesParams)
	// Create a feature
	// (POST /api/v1/features)
	CreateFeature(w http.ResponseWriter, r *http.Request)
	// Archive a feature
	// (DELETE /api/v1/features/{featureId})
	DeleteFeature(w http.ResponseWriter, r *http.Request, featureId FeatureId)
	// Get feature
	// (GET /api/v1/features/{featureId})
	GetFeature(w http.ResponseWriter, r *http.Request, featureId FeatureId)
	// List grants
	// (GET /api/v1/grants)
	ListGrants(w http.ResponseWriter, r *http.Request, params ListGrantsParams)
	// Void a grant
	// (DELETE /api/v1/grants/{grantId})
	VoidGrant(w http.ResponseWriter, r *http.Request, grantId GrantId)
	// List meters
	// (GET /api/v1/meters)
	ListMeters(w http.ResponseWriter, r *http.Request)
	//  Create meter
	// (POST /api/v1/meters)
	CreateMeter(w http.ResponseWriter, r *http.Request)
	//  Delete meter
	// (DELETE /api/v1/meters/{meterIdOrSlug})
	DeleteMeter(w http.ResponseWriter, r *http.Request, meterIdOrSlug MeterIdOrSlug)
	// Get meter
	// (GET /api/v1/meters/{meterIdOrSlug})
	GetMeter(w http.ResponseWriter, r *http.Request, meterIdOrSlug MeterIdOrSlug)
	// Query meter
	// (GET /api/v1/meters/{meterIdOrSlug}/query)
	QueryMeter(w http.ResponseWriter, r *http.Request, meterIdOrSlug MeterIdOrSlug, params QueryMeterParams)
	// List meter subjects
	// (GET /api/v1/meters/{meterIdOrSlug}/subjects)
	ListMeterSubjects(w http.ResponseWriter, r *http.Request, meterIdOrSlug MeterIdOrSlug)
	// List notification channels
	// (GET /api/v1/notification/channels)
	ListNotificationChannels(w http.ResponseWriter, r *http.Request, params ListNotificationChannelsParams)
	// Create a notification channel
	// (POST /api/v1/notification/channels)
	CreateNotificationChannel(w http.ResponseWriter, r *http.Request)
	// Delete a notification channel
	// (DELETE /api/v1/notification/channels/{channelId})
	DeleteNotificationChannel(w http.ResponseWriter, r *http.Request, channelId ChannelId)
	// Get notification channel
	// (GET /api/v1/notification/channels/{channelId})
	GetNotificationChannel(w http.ResponseWriter, r *http.Request, channelId ChannelId)
	// Update notification channel
	// (PUT /api/v1/notification/channels/{channelId})
	UpdateNotificationChannel(w http.ResponseWriter, r *http.Request, channelId ChannelId)
	// List notification evens
	// (GET /api/v1/notification/events)
	ListNotificationEvents(w http.ResponseWriter, r *http.Request, params ListNotificationEventsParams)
	// Get notification event
	// (GET /api/v1/notification/events/{eventId})
	GetNotificationEvent(w http.ResponseWriter, r *http.Request, eventId EventId)
	// List notification rules
	// (GET /api/v1/notification/rules)
	ListNotificationRules(w http.ResponseWriter, r *http.Request, params ListNotificationRulesParams)
	// Create a notification rule
	// (POST /api/v1/notification/rules)
	CreateNotificationRule(w http.ResponseWriter, r *http.Request)
	// Delete a notification rule
	// (DELETE /api/v1/notification/rules/{ruleId})
	DeleteNotificationRule(w http.ResponseWriter, r *http.Request, ruleId RuleId)
	// Get notification rule
	// (GET /api/v1/notification/rules/{ruleId})
	GetNotificationRule(w http.ResponseWriter, r *http.Request, ruleId RuleId)
	// Update a notification rule
	// (PUT /api/v1/notification/rules/{ruleId})
	UpdateNotificationRule(w http.ResponseWriter, r *http.Request, ruleId RuleId)
	// Query portal meter
	// (GET /api/v1/portal/meters/{meterSlug}/query)
	QueryPortalMeter(w http.ResponseWriter, r *http.Request, meterSlug string, params QueryPortalMeterParams)
	//  List portal tokens
	// (GET /api/v1/portal/tokens)
	ListPortalTokens(w http.ResponseWriter, r *http.Request, params ListPortalTokensParams)
	// Create portal token
	// (POST /api/v1/portal/tokens)
	CreatePortalToken(w http.ResponseWriter, r *http.Request)
	//  Invalidate portal tokens
	// (POST /api/v1/portal/tokens/invalidate)
	InvalidatePortalTokens(w http.ResponseWriter, r *http.Request)
	//  List subjects
	// (GET /api/v1/subjects)
	ListSubjects(w http.ResponseWriter, r *http.Request)
	//  Upsert subject
	// (POST /api/v1/subjects)
	UpsertSubject(w http.ResponseWriter, r *http.Request)
	//  Delete subject
	// (DELETE /api/v1/subjects/{subjectIdOrKey})
	DeleteSubject(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey)
	//  Get subject
	// (GET /api/v1/subjects/{subjectIdOrKey})
	GetSubject(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey)
	// List entitlements of a subject
	// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements)
	ListSubjectEntitlements(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, params ListSubjectEntitlementsParams)
	// Create an entitlement
	// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements)
	CreateEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey)
	// List grants for an entitlement
	// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants)
	ListEntitlementGrants(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementIdOrFeatureKey EntitlementIdOrFeatureKey, params ListEntitlementGrantsParams)
	// Create a grant
	// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants)
	CreateGrant(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementIdOrFeatureKey EntitlementIdOrFeatureKey)
	// Get the current value and access of an entitlement
	// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value)
	GetEntitlementValue(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementIdOrFeatureKey EntitlementIdOrFeatureKey, params GetEntitlementValueParams)
	// Delete an entitlement
	// (DELETE /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId})
	DeleteEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementId EntitlementId)
	// Get an entitlement
	// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId})
	GetEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementId EntitlementId)
	// Get the balance history of a specific entitlement.
	// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history)
	GetEntitlementHistory(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementId EntitlementId, params GetEntitlementHistoryParams)
	// Reset an entitlement
	// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset)
	ResetEntitlementUsage(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementId EntitlementId)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Get event metrics
// (GET /api/v1/debug/metrics)
func (_ Unimplemented) GetDebugMetrics(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List entitlements
// (GET /api/v1/entitlements)
func (_ Unimplemented) ListEntitlements(w http.ResponseWriter, r *http.Request, params ListEntitlementsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List ingested events
// (GET /api/v1/events)
func (_ Unimplemented) ListEvents(w http.ResponseWriter, r *http.Request, params ListEventsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Ingest events
// (POST /api/v1/events)
func (_ Unimplemented) IngestEvents(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List features
// (GET /api/v1/features)
func (_ Unimplemented) ListFeatures(w http.ResponseWriter, r *http.Request, params ListFeaturesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a feature
// (POST /api/v1/features)
func (_ Unimplemented) CreateFeature(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Archive a feature
// (DELETE /api/v1/features/{featureId})
func (_ Unimplemented) DeleteFeature(w http.ResponseWriter, r *http.Request, featureId FeatureId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get feature
// (GET /api/v1/features/{featureId})
func (_ Unimplemented) GetFeature(w http.ResponseWriter, r *http.Request, featureId FeatureId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List grants
// (GET /api/v1/grants)
func (_ Unimplemented) ListGrants(w http.ResponseWriter, r *http.Request, params ListGrantsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Void a grant
// (DELETE /api/v1/grants/{grantId})
func (_ Unimplemented) VoidGrant(w http.ResponseWriter, r *http.Request, grantId GrantId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List meters
// (GET /api/v1/meters)
func (_ Unimplemented) ListMeters(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

//  Create meter
// (POST /api/v1/meters)
func (_ Unimplemented) CreateMeter(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

//  Delete meter
// (DELETE /api/v1/meters/{meterIdOrSlug})
func (_ Unimplemented) DeleteMeter(w http.ResponseWriter, r *http.Request, meterIdOrSlug MeterIdOrSlug) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get meter
// (GET /api/v1/meters/{meterIdOrSlug})
func (_ Unimplemented) GetMeter(w http.ResponseWriter, r *http.Request, meterIdOrSlug MeterIdOrSlug) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Query meter
// (GET /api/v1/meters/{meterIdOrSlug}/query)
func (_ Unimplemented) QueryMeter(w http.ResponseWriter, r *http.Request, meterIdOrSlug MeterIdOrSlug, params QueryMeterParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List meter subjects
// (GET /api/v1/meters/{meterIdOrSlug}/subjects)
func (_ Unimplemented) ListMeterSubjects(w http.ResponseWriter, r *http.Request, meterIdOrSlug MeterIdOrSlug) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List notification channels
// (GET /api/v1/notification/channels)
func (_ Unimplemented) ListNotificationChannels(w http.ResponseWriter, r *http.Request, params ListNotificationChannelsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a notification channel
// (POST /api/v1/notification/channels)
func (_ Unimplemented) CreateNotificationChannel(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a notification channel
// (DELETE /api/v1/notification/channels/{channelId})
func (_ Unimplemented) DeleteNotificationChannel(w http.ResponseWriter, r *http.Request, channelId ChannelId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get notification channel
// (GET /api/v1/notification/channels/{channelId})
func (_ Unimplemented) GetNotificationChannel(w http.ResponseWriter, r *http.Request, channelId ChannelId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update notification channel
// (PUT /api/v1/notification/channels/{channelId})
func (_ Unimplemented) UpdateNotificationChannel(w http.ResponseWriter, r *http.Request, channelId ChannelId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List notification evens
// (GET /api/v1/notification/events)
func (_ Unimplemented) ListNotificationEvents(w http.ResponseWriter, r *http.Request, params ListNotificationEventsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get notification event
// (GET /api/v1/notification/events/{eventId})
func (_ Unimplemented) GetNotificationEvent(w http.ResponseWriter, r *http.Request, eventId EventId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List notification rules
// (GET /api/v1/notification/rules)
func (_ Unimplemented) ListNotificationRules(w http.ResponseWriter, r *http.Request, params ListNotificationRulesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a notification rule
// (POST /api/v1/notification/rules)
func (_ Unimplemented) CreateNotificationRule(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a notification rule
// (DELETE /api/v1/notification/rules/{ruleId})
func (_ Unimplemented) DeleteNotificationRule(w http.ResponseWriter, r *http.Request, ruleId RuleId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get notification rule
// (GET /api/v1/notification/rules/{ruleId})
func (_ Unimplemented) GetNotificationRule(w http.ResponseWriter, r *http.Request, ruleId RuleId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a notification rule
// (PUT /api/v1/notification/rules/{ruleId})
func (_ Unimplemented) UpdateNotificationRule(w http.ResponseWriter, r *http.Request, ruleId RuleId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Query portal meter
// (GET /api/v1/portal/meters/{meterSlug}/query)
func (_ Unimplemented) QueryPortalMeter(w http.ResponseWriter, r *http.Request, meterSlug string, params QueryPortalMeterParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

//  List portal tokens
// (GET /api/v1/portal/tokens)
func (_ Unimplemented) ListPortalTokens(w http.ResponseWriter, r *http.Request, params ListPortalTokensParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create portal token
// (POST /api/v1/portal/tokens)
func (_ Unimplemented) CreatePortalToken(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

//  Invalidate portal tokens
// (POST /api/v1/portal/tokens/invalidate)
func (_ Unimplemented) InvalidatePortalTokens(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

//  List subjects
// (GET /api/v1/subjects)
func (_ Unimplemented) ListSubjects(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

//  Upsert subject
// (POST /api/v1/subjects)
func (_ Unimplemented) UpsertSubject(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

//  Delete subject
// (DELETE /api/v1/subjects/{subjectIdOrKey})
func (_ Unimplemented) DeleteSubject(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey) {
	w.WriteHeader(http.StatusNotImplemented)
}

//  Get subject
// (GET /api/v1/subjects/{subjectIdOrKey})
func (_ Unimplemented) GetSubject(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List entitlements of a subject
// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements)
func (_ Unimplemented) ListSubjectEntitlements(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, params ListSubjectEntitlementsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create an entitlement
// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements)
func (_ Unimplemented) CreateEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List grants for an entitlement
// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants)
func (_ Unimplemented) ListEntitlementGrants(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementIdOrFeatureKey EntitlementIdOrFeatureKey, params ListEntitlementGrantsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a grant
// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants)
func (_ Unimplemented) CreateGrant(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementIdOrFeatureKey EntitlementIdOrFeatureKey) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the current value and access of an entitlement
// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value)
func (_ Unimplemented) GetEntitlementValue(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementIdOrFeatureKey EntitlementIdOrFeatureKey, params GetEntitlementValueParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete an entitlement
// (DELETE /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId})
func (_ Unimplemented) DeleteEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementId EntitlementId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get an entitlement
// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId})
func (_ Unimplemented) GetEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementId EntitlementId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get the balance history of a specific entitlement.
// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history)
func (_ Unimplemented) GetEntitlementHistory(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementId EntitlementId, params GetEntitlementHistoryParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Reset an entitlement
// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset)
func (_ Unimplemented) ResetEntitlementUsage(w http.ResponseWriter, r *http.Request, subjectIdOrKey SubjectIdOrKey, entitlementId EntitlementId) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetDebugMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetDebugMetrics(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDebugMetrics(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListEntitlements operation middleware
func (siw *ServerInterfaceWrapper) ListEntitlements(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEntitlementsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListEntitlements(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListEvents operation middleware
func (siw *ServerInterfaceWrapper) ListEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEventsParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListEvents(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// IngestEvents operation middleware
func (siw *ServerInterfaceWrapper) IngestEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IngestEvents(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListFeatures operation middleware
func (siw *ServerInterfaceWrapper) ListFeatures(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFeaturesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	// ------------- Optional query parameter "includeArchived" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeArchived", r.URL.Query(), &params.IncludeArchived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeArchived", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFeatures(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateFeature operation middleware
func (siw *ServerInterfaceWrapper) CreateFeature(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateFeature(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteFeature operation middleware
func (siw *ServerInterfaceWrapper) DeleteFeature(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "featureId" -------------
	var featureId FeatureId

	err = runtime.BindStyledParameterWithOptions("simple", "featureId", chi.URLParam(r, "featureId"), &featureId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "featureId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFeature(w, r, featureId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetFeature operation middleware
func (siw *ServerInterfaceWrapper) GetFeature(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "featureId" -------------
	var featureId FeatureId

	err = runtime.BindStyledParameterWithOptions("simple", "featureId", chi.URLParam(r, "featureId"), &featureId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "featureId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFeature(w, r, featureId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListGrants operation middleware
func (siw *ServerInterfaceWrapper) ListGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGrantsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGrants(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// VoidGrant operation middleware
func (siw *ServerInterfaceWrapper) VoidGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "grantId" -------------
	var grantId GrantId

	err = runtime.BindStyledParameterWithOptions("simple", "grantId", chi.URLParam(r, "grantId"), &grantId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VoidGrant(w, r, grantId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListMeters operation middleware
func (siw *ServerInterfaceWrapper) ListMeters(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMeters(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateMeter operation middleware
func (siw *ServerInterfaceWrapper) CreateMeter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateMeter(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteMeter operation middleware
func (siw *ServerInterfaceWrapper) DeleteMeter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "meterIdOrSlug" -------------
	var meterIdOrSlug MeterIdOrSlug

	err = runtime.BindStyledParameterWithOptions("simple", "meterIdOrSlug", chi.URLParam(r, "meterIdOrSlug"), &meterIdOrSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "meterIdOrSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteMeter(w, r, meterIdOrSlug)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetMeter operation middleware
func (siw *ServerInterfaceWrapper) GetMeter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "meterIdOrSlug" -------------
	var meterIdOrSlug MeterIdOrSlug

	err = runtime.BindStyledParameterWithOptions("simple", "meterIdOrSlug", chi.URLParam(r, "meterIdOrSlug"), &meterIdOrSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "meterIdOrSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMeter(w, r, meterIdOrSlug)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// QueryMeter operation middleware
func (siw *ServerInterfaceWrapper) QueryMeter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "meterIdOrSlug" -------------
	var meterIdOrSlug MeterIdOrSlug

	err = runtime.BindStyledParameterWithOptions("simple", "meterIdOrSlug", chi.URLParam(r, "meterIdOrSlug"), &meterIdOrSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "meterIdOrSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryMeterParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "windowSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "windowSize", r.URL.Query(), &params.WindowSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowSize", Err: err})
		return
	}

	// ------------- Optional query parameter "windowTimeZone" -------------

	err = runtime.BindQueryParameter("form", true, false, "windowTimeZone", r.URL.Query(), &params.WindowTimeZone)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowTimeZone", Err: err})
		return
	}

	// ------------- Optional query parameter "subject" -------------

	err = runtime.BindQueryParameter("form", true, false, "subject", r.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subject", Err: err})
		return
	}

	// ------------- Optional query parameter "filterGroupBy" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "filterGroupBy", r.URL.Query(), &params.FilterGroupBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filterGroupBy", Err: err})
		return
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", r.URL.Query(), &params.GroupBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QueryMeter(w, r, meterIdOrSlug, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListMeterSubjects operation middleware
func (siw *ServerInterfaceWrapper) ListMeterSubjects(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "meterIdOrSlug" -------------
	var meterIdOrSlug MeterIdOrSlug

	err = runtime.BindStyledParameterWithOptions("simple", "meterIdOrSlug", chi.URLParam(r, "meterIdOrSlug"), &meterIdOrSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "meterIdOrSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMeterSubjects(w, r, meterIdOrSlug)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListNotificationChannels operation middleware
func (siw *ServerInterfaceWrapper) ListNotificationChannels(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNotificationChannelsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	// ------------- Optional query parameter "includeDisabled" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeDisabled", r.URL.Query(), &params.IncludeDisabled)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDisabled", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNotificationChannels(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateNotificationChannel operation middleware
func (siw *ServerInterfaceWrapper) CreateNotificationChannel(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateNotificationChannel(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteNotificationChannel operation middleware
func (siw *ServerInterfaceWrapper) DeleteNotificationChannel(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "channelId" -------------
	var channelId ChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", chi.URLParam(r, "channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "channelId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteNotificationChannel(w, r, channelId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNotificationChannel operation middleware
func (siw *ServerInterfaceWrapper) GetNotificationChannel(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "channelId" -------------
	var channelId ChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", chi.URLParam(r, "channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "channelId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNotificationChannel(w, r, channelId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateNotificationChannel operation middleware
func (siw *ServerInterfaceWrapper) UpdateNotificationChannel(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "channelId" -------------
	var channelId ChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", chi.URLParam(r, "channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "channelId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateNotificationChannel(w, r, channelId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListNotificationEvents operation middleware
func (siw *ServerInterfaceWrapper) ListNotificationEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNotificationEventsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	// ------------- Optional query parameter "feature" -------------

	err = runtime.BindQueryParameter("form", true, false, "feature", r.URL.Query(), &params.Feature)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "feature", Err: err})
		return
	}

	// ------------- Optional query parameter "subject" -------------

	err = runtime.BindQueryParameter("form", true, false, "subject", r.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subject", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNotificationEvents(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNotificationEvent operation middleware
func (siw *ServerInterfaceWrapper) GetNotificationEvent(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "eventId" -------------
	var eventId EventId

	err = runtime.BindStyledParameterWithOptions("simple", "eventId", chi.URLParam(r, "eventId"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "eventId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNotificationEvent(w, r, eventId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListNotificationRules operation middleware
func (siw *ServerInterfaceWrapper) ListNotificationRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNotificationRulesParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	// ------------- Optional query parameter "includeDisabled" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeDisabled", r.URL.Query(), &params.IncludeDisabled)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDisabled", Err: err})
		return
	}

	// ------------- Optional query parameter "feature" -------------

	err = runtime.BindQueryParameter("form", true, false, "feature", r.URL.Query(), &params.Feature)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "feature", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNotificationRules(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateNotificationRule operation middleware
func (siw *ServerInterfaceWrapper) CreateNotificationRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateNotificationRule(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteNotificationRule operation middleware
func (siw *ServerInterfaceWrapper) DeleteNotificationRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId RuleId

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", chi.URLParam(r, "ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteNotificationRule(w, r, ruleId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetNotificationRule operation middleware
func (siw *ServerInterfaceWrapper) GetNotificationRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId RuleId

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", chi.URLParam(r, "ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNotificationRule(w, r, ruleId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateNotificationRule operation middleware
func (siw *ServerInterfaceWrapper) UpdateNotificationRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId RuleId

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", chi.URLParam(r, "ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateNotificationRule(w, r, ruleId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// QueryPortalMeter operation middleware
func (siw *ServerInterfaceWrapper) QueryPortalMeter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "meterSlug" -------------
	var meterSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "meterSlug", chi.URLParam(r, "meterSlug"), &meterSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "meterSlug", Err: err})
		return
	}

	ctx = context.WithValue(ctx, PortalTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudPortalTokenAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryPortalMeterParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "windowSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "windowSize", r.URL.Query(), &params.WindowSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowSize", Err: err})
		return
	}

	// ------------- Optional query parameter "windowTimeZone" -------------

	err = runtime.BindQueryParameter("form", true, false, "windowTimeZone", r.URL.Query(), &params.WindowTimeZone)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowTimeZone", Err: err})
		return
	}

	// ------------- Optional query parameter "filterGroupBy" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "filterGroupBy", r.URL.Query(), &params.FilterGroupBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filterGroupBy", Err: err})
		return
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", r.URL.Query(), &params.GroupBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QueryPortalMeter(w, r, meterSlug, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListPortalTokens operation middleware
func (siw *ServerInterfaceWrapper) ListPortalTokens(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPortalTokensParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPortalTokens(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreatePortalToken operation middleware
func (siw *ServerInterfaceWrapper) CreatePortalToken(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePortalToken(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// InvalidatePortalTokens operation middleware
func (siw *ServerInterfaceWrapper) InvalidatePortalTokens(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InvalidatePortalTokens(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListSubjects operation middleware
func (siw *ServerInterfaceWrapper) ListSubjects(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSubjects(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpsertSubject operation middleware
func (siw *ServerInterfaceWrapper) UpsertSubject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpsertSubject(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteSubject operation middleware
func (siw *ServerInterfaceWrapper) DeleteSubject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSubject(w, r, subjectIdOrKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSubject operation middleware
func (siw *ServerInterfaceWrapper) GetSubject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSubject(w, r, subjectIdOrKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListSubjectEntitlements operation middleware
func (siw *ServerInterfaceWrapper) ListSubjectEntitlements(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSubjectEntitlementsParams

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSubjectEntitlements(w, r, subjectIdOrKey, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateEntitlement operation middleware
func (siw *ServerInterfaceWrapper) CreateEntitlement(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateEntitlement(w, r, subjectIdOrKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListEntitlementGrants operation middleware
func (siw *ServerInterfaceWrapper) ListEntitlementGrants(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementIdOrFeatureKey" -------------
	var entitlementIdOrFeatureKey EntitlementIdOrFeatureKey

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementIdOrFeatureKey", chi.URLParam(r, "entitlementIdOrFeatureKey"), &entitlementIdOrFeatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementIdOrFeatureKey", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEntitlementGrantsParams

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListEntitlementGrants(w, r, subjectIdOrKey, entitlementIdOrFeatureKey, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateGrant operation middleware
func (siw *ServerInterfaceWrapper) CreateGrant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementIdOrFeatureKey" -------------
	var entitlementIdOrFeatureKey EntitlementIdOrFeatureKey

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementIdOrFeatureKey", chi.URLParam(r, "entitlementIdOrFeatureKey"), &entitlementIdOrFeatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementIdOrFeatureKey", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGrant(w, r, subjectIdOrKey, entitlementIdOrFeatureKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetEntitlementValue operation middleware
func (siw *ServerInterfaceWrapper) GetEntitlementValue(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementIdOrFeatureKey" -------------
	var entitlementIdOrFeatureKey EntitlementIdOrFeatureKey

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementIdOrFeatureKey", chi.URLParam(r, "entitlementIdOrFeatureKey"), &entitlementIdOrFeatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementIdOrFeatureKey", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntitlementValueParams

	// ------------- Optional query parameter "time" -------------

	err = runtime.BindQueryParameter("form", true, false, "time", r.URL.Query(), &params.Time)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntitlementValue(w, r, subjectIdOrKey, entitlementIdOrFeatureKey, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteEntitlement operation middleware
func (siw *ServerInterfaceWrapper) DeleteEntitlement(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementId" -------------
	var entitlementId EntitlementId

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementId", chi.URLParam(r, "entitlementId"), &entitlementId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteEntitlement(w, r, subjectIdOrKey, entitlementId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetEntitlement operation middleware
func (siw *ServerInterfaceWrapper) GetEntitlement(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementId" -------------
	var entitlementId EntitlementId

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementId", chi.URLParam(r, "entitlementId"), &entitlementId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntitlement(w, r, subjectIdOrKey, entitlementId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetEntitlementHistory operation middleware
func (siw *ServerInterfaceWrapper) GetEntitlementHistory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementId" -------------
	var entitlementId EntitlementId

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementId", chi.URLParam(r, "entitlementId"), &entitlementId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntitlementHistoryParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Required query parameter "windowSize" -------------

	if paramValue := r.URL.Query().Get("windowSize"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "windowSize"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "windowSize", r.URL.Query(), &params.WindowSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowSize", Err: err})
		return
	}

	// ------------- Optional query parameter "windowTimeZone" -------------

	err = runtime.BindQueryParameter("form", true, false, "windowTimeZone", r.URL.Query(), &params.WindowTimeZone)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowTimeZone", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntitlementHistory(w, r, subjectIdOrKey, entitlementId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ResetEntitlementUsage operation middleware
func (siw *ServerInterfaceWrapper) ResetEntitlementUsage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey SubjectIdOrKey

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementId" -------------
	var entitlementId EntitlementId

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementId", chi.URLParam(r, "entitlementId"), &entitlementId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, CloudTokenAuthScopes, []string{})

	ctx = context.WithValue(ctx, CloudCookieAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResetEntitlementUsage(w, r, subjectIdOrKey, entitlementId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/debug/metrics", wrapper.GetDebugMetrics)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/entitlements", wrapper.ListEntitlements)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/events", wrapper.ListEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/events", wrapper.IngestEvents)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/features", wrapper.ListFeatures)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/features", wrapper.CreateFeature)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/features/{featureId}", wrapper.DeleteFeature)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/features/{featureId}", wrapper.GetFeature)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/grants", wrapper.ListGrants)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/grants/{grantId}", wrapper.VoidGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/meters", wrapper.ListMeters)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/meters", wrapper.CreateMeter)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/meters/{meterIdOrSlug}", wrapper.DeleteMeter)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/meters/{meterIdOrSlug}", wrapper.GetMeter)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/meters/{meterIdOrSlug}/query", wrapper.QueryMeter)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/meters/{meterIdOrSlug}/subjects", wrapper.ListMeterSubjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/channels", wrapper.ListNotificationChannels)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/notification/channels", wrapper.CreateNotificationChannel)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/notification/channels/{channelId}", wrapper.DeleteNotificationChannel)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/channels/{channelId}", wrapper.GetNotificationChannel)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/notification/channels/{channelId}", wrapper.UpdateNotificationChannel)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/events", wrapper.ListNotificationEvents)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/events/{eventId}", wrapper.GetNotificationEvent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/rules", wrapper.ListNotificationRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/notification/rules", wrapper.CreateNotificationRule)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/notification/rules/{ruleId}", wrapper.DeleteNotificationRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/rules/{ruleId}", wrapper.GetNotificationRule)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/notification/rules/{ruleId}", wrapper.UpdateNotificationRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/portal/meters/{meterSlug}/query", wrapper.QueryPortalMeter)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/portal/tokens", wrapper.ListPortalTokens)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/portal/tokens", wrapper.CreatePortalToken)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/portal/tokens/invalidate", wrapper.InvalidatePortalTokens)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects", wrapper.ListSubjects)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subjects", wrapper.UpsertSubject)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}", wrapper.DeleteSubject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}", wrapper.GetSubject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements", wrapper.ListSubjectEntitlements)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements", wrapper.CreateEntitlement)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants", wrapper.ListEntitlementGrants)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants", wrapper.CreateGrant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value", wrapper.GetEntitlementValue)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}", wrapper.DeleteEntitlement)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}", wrapper.GetEntitlement)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history", wrapper.GetEntitlementHistory)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset", wrapper.ResetEntitlementUsage)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9fXPbtrIw/lUwvGfmJOfQsuwkbeLfdO4ofknc1HbqlzZt7V8CkZCEYwpQAdKymskf",
	"z7d4Pt/9JM9gAZAgCUqULCe+ac7cuY1FElgsFvuO3Y9BxMcTzghLZbDzMZhggcckJQL+ikaYMZIcxuqP",
	"mMhI0ElKOQt2gh7KGP0zI+jip8M9RGPCUjqgRKABFwgjxtWfEVZvIzNMJwgDqr6d4HQUhAHDYxLsOJOE",
	"gSB/ZlSQONhJRUbCQEYjMsZqdnKLx5NEvd/d6p3+/uR4b//N+dkvT09PDw5+/u7Fq2cHvV+CMEhnE/WO",
	"TAVlw+DTpzBQgKUJGROWLl4HAM+Q800D0OVR7x/wE3FAcJoJ8obM6os4HxFEY8QHKB0RF3rEBfx0TWb2",
	"6UCP02ZdpUnvukYFynCSPn2f8mvCpH/JN612aT61wSBNy7tZbsN+3H732+/7b4923xy9fNN7/e7H3w+e",
	"nz357Wcv9AazK8A/f0+Kce+FzoYCL0B6DV74pAFaO9y9wEpZlGQx2SMJSYkH5EP9HMX6BXUUBCUyB/XP",
	"jIhZAWtlOBfEmAxwlqTBzgAnkoQFyHotBrQ+5wnBDGADtqkOzVmSDdtjU51J+LQBn+Vh52H1H4IMgp3g",
	"vzYLlr6pn8rNfAAFKWDhgCYpsQe8Dq5+TNkQ9WdonCUpnSQ585CdS3bJLiQekh304b/Nrz+Y/25sXWbd",
	"7vZ31Z+3P1yyho0wr5R2gKZkDFKoQgY58rEQeFZd0CvBs8lL4JHeiUovudPhOKZq7Th5K/iEiJQS/+xl",
	"PJ3RMSAGxoUNHarBUX8m0ZSmI0RucZSiMU6jUQVrLih/qGmufqBskqUGe6XHYx6T5OqH4STdeKrRmBPk",
	"xwAeqqOnnhbnBgZz8MX7/yER/CDTGZy+mJDJSf6rg8WzTP/akiykfr1CFubXH6JMpnxMhKWL2u9zCMO8",
	"ezfCEHxcX8lZikWKYpySjZSOCaIMnR7soidPnrxQ2zjGaeeSAT+R9IZ0mklXje5nbtvd7Scb3a2N7tZ5",
	"t7sD//d7EAZ6dIV+O7mX18E8DjlXON1AST0kJyRSvCRGGEnKhglBeDgUZIhTgqY0SVCfIEHSTDASA3kS",
	"HI3shiHMYgSrn1IW82nnkn0wjz4gKhFGgkgibkicUzW6wUk2Bx1Dz9HKMfKHIVWz3Ktw6b00DH6PStxP",
	"5koA80ZbEWAHvJsMgMF/omPqOTrH2bhPhFLDDEgo5WZrGmBLYCAvRFvdbtcBaEv9Nca3dJyN7cMxZeZP",
	"hyOkZEhEAerJYCBJW1jlNZ00QMr1OF5QXThdsLrNYL3FQ49IUr8ipiFbhLqJGsGPORdt7bCkJj6jf5Gl",
	"9hRNiEAGjCYIYdCm/V1pQ895Hch9Fq+Bz6V8EZfbXpnL/Qrcx4/iKqMLC06XKUmziN9Zi0iQNLeBCq45",
	"IYLyBsYIrKwZIdMC6LZamLPOytrP6Zj8zhnx23bAcxVDVsCr6e1CYEf/4owgLFFMBlStmjJ4dtg77iE1",
	"LlIDoz2c4j6WBD0apelkZ3NzOp12KGa4w8VwUw20oQaSjxU51HCuBrw434UJYT6L60ySeBGO8sV5ST24",
	"ON919ZmgNyaCRnjzmEzf/8bFtZduRJaQu1qKaowGrdsMfy92oqExpZJ7rflmu8t82QBzZdx2sOdKGI09",
	"wCpEEznhTGpl+CWOT8mfGZHpW8H7CRmfmqfgLeIsJQykCZ5MEoPlzYl+89//kWp1H13FNSYppkpzHREc",
	"E4F29Qgb57MJQSMsUcbI7YREypTTZ+CyNPTtOLkMFFWlOM1ksPNUsUlwYAQ7ClZkgC1Wlgm2YwDaUD/t",
	"9HG8Icxbn9qeY7N4jaDy5rmzfgqDXc4GCY3Wg67IDEbZcJ+lQhs5MRDg63e/HHXPurtHv/949vP2k1cv",
	"jt68O/357fcB2KU4xiksSm3shLzFM+sOCyb0/dMT0bse/XQzoyPKX0yebY1eUHrAXgYFrRbUtbGlbSCz",
	"cQmJh0QgcktlKks78aLYCfMSTgTB8ax4uWlPzAutt6OCZN+22FfUoMc8PeAZi9dLwmCnA9scqMFLuHha",
	"4OKYp+jAvNC0fsbTDT3IOiiymFGv/VCBrvafrBkDxogHHNBiEgcTz7pbZUwcll6bhw93wHVh5bA85gXD",
	"WTrigv61bsyMqVQqC+ICUXaDExoj8IKWiMRBjQvJHLxk7mvrQMpFZcCLnP2uFx8OWydCcFEika6Lh/y9",
	"ffNeMy7sq2vCRAXCT/moRhAmmEXkNZUptzpcXZLr30lsNVUWo77+EFGmFWTKmVafJiWvk3mtl4Kbwq8V",
	"un5+OyxOtYILzg2jJGodt1P2GoGBUejoPOsnBFQGHJ+wZFaxcbXVpTCrB1uIWf3WpzCAlfvhT3mKE4Oa",
	"cnDCqrBrhNznBqvKjUYvoB6xQaKEzSKaprPDXD4f7/14+uzJ9v7zV+cvfznb3X735tne06AuSx8ZzbjT",
	"/NVjV5amMgX10JouhaBWWqJMFV2YE2MUnZ2ERzjZ/PHoJIlS+eaX5xtd9b+tJvntLNV6Zfo8S3f6CWbX",
	"QBQl2rULquu1o2yM2YaCHPcTgsjtJMFM6+LG1oiUAZ2OqEQ8ijIhiCJqS8d6mzolY6HP4xkaZzJVxghG",
	"P56dHCNufYY1pxK5TQmTlDPZvNnG2VNek3df54fhnE/0UZ2VIV8y9FEo8394obnyEHix/fW9uDg9RIIM",
	"iEZxOsJpYW9I10qO2m5FOwrLT24mqG+LLAX6kPv6/Pwt0i+giMcEDQkjAisu3Z8BYFzQIWUInJY2vtKa",
	"mJ6WOAtl6ZPtwPHCPHvxwnHCaFuj4obJz0wd3xjJERdpWD0EMhuPsZhV4EJq5DJ6vfZM1V9aw5qypJSk",
	"xpRJhGHXfXvdPO1ci2nRdlboFp5aHOVbnbNAHwnvF0IOVkfV6saU4ZQLiH3gyURNpWSmccQ2yCRnpJfm",
	"TRO0U8At/ObIvKnBplGLT870iwWDnB0bX5pa5acw4IycDIKdP+YLUw8Qn8LWn+RAtP7CYufTVRn/9nfF",
	"OZNkOcDNt7uC4JQcskkG9l37RYywIPEBJUksg09XYc3DCW/KwkWixEgmiRNbByViHnn5QFxlqXqAMsTh",
	"x1UhnniCkR8DwhQL+iMn+auySLTU3eI01s9cZder+FjrCSwNvsJprHy/5MmsUOO6T+nKxO4D7m4nzbun",
	"JRLd+VghtTnZLOeOpg6KgqFgKq1NEhtq7lyyfZqOlCjOM4mUFZwPrr6xNFnR85dSkPLsm8b8qM8AsPnX",
	"hk14uAYvbA1S1yG3YtZBL/8M2dHyYMd8hgfm1ttWRtwpUUoTZUP9ukNRfnPKIbBXAhvPwLLcE74sTbWA",
	"9DUVH5EUO8y2TMoLUgAVdRiPu2tSQwABdCWFVUhrgpi4lDyioHNOaTpaimgbbFTXPplQQWSvyeJXj7W9",
	"FOM012V1OlYFkGWSDxbCxchtqsmBeM0JBZx6RwekCnxBlEjAh3eBrwaPKMGyBBGrj284jUnchGNAbJ4X",
	"4SwFS6S/RI8izBhPbfgL4UFKBJDK486KKK6I5jLFLpTRtUNTWxm8IREWBuSUI8oiQbAkue+IDwqTz8no",
	"qSkheMwz1oA9/UwNr4kSnY14lsTaOJ9wSVN6Y4P47fw6NQ8UGQxIpIbx7eC+faj3Uedj6aWzGGEWjbg2",
	"C4WlC/O8g94KfgPbqyNNNsAZEWrEA2gn6osi8osejSnLUvJ4rdRdHPMlWGj+jSV0RSNjfHvKk4TfENFz",
	"dq3IzGikEsETtWz1JcIp5AGloaH06YhGI3U0ZijCDI3wjdrdmA7Am1A4IxWYijkr5E0NI52hEVbkMOBG",
	"FsPIkDj20vowzXEyzxTTjXASZQkwXSx38lff99Sr70/htR/Q0eHxo6PqikN01Hv3yH7wEibWX4ToiLLy",
	"y48fr0aTK4l0x224dFyuJnzH1aV82+l72emJoFzQdFbNKaqzQvtmWUojg3nIDR3RoVI18zfVdkAshcRo",
	"QIVU2HprH0I+Xs5CYxLRMU4MK5Ud9KsaMOFTIuxviLIYojJsaGei4wkX4BLsXLIDLpBZf6iGduDdUrON",
	"1cZlYqg2Oh1hVnlnu3PJfh0R8NQruAVBktwQgZOc5d5gmoCTy+qmEo9z7VsnlciZTMkYSZIocVNSHVKg",
	"PA26TPO5IV0JRVgSiaYwtZlOKk2wmCaHNSE3JAmdoaOESzWiEoKpdLUqN6sl34FDHYxQM8JeTrmdEc6D",
	"9qRFOLEzUqKlTUVbk6UFw0zK3i/AAl1TqRkRSPICgKCSsmYdktvPns3PCruDolTV9l3txCgAZVFcElsL",
	"PHnWjbWKgXBH49p+nrMZx2pYjzPKzODaErniNcgSOAtjzGYOG1V0AAQdooHg6jSkcGqziQmP9THomVFE",
	"JKQY5tFw9ZaCNiG3imximhoCkx3U069TiWIF0hiSw/RInOX2sJ4gg/g0Lhi6wY8i3keKRC8DE8NMEj5V",
	"r1wGaGI1JuN8p1JmkCoMh4NKdBn0M8FSFPMpuwzsazDQ48UOuaatqil9xRtoAK+YdKlxfSc6NW1Wn4/0",
	"or1dXFgSCZYpCBi/MqweazMCGwE3wpMJYXXPwd0yxd2zWYAU+pbW7mB+Hh+o56AYho7bU67PQKHyjA9S",
	"Jw27nMZdyy+V9u0flG1W8hAprcdyaTsvuSEM0fpdO6pEyQhnMiVxiEZYmgMIrB4nUzyTSraoOUrEnyeQ",
	"hwGVFwyyvm1q+zzI98hEkAjDbHTIuChOYh9H14TFHfQ2ARNPLcHBCqJMpgTH/5+OjsGhcbJnx/ymSCMd",
	"ZDVvUglgmRHQzRrOwW88AyRqEWd4SJbyMQaZmcwQTjgbShqTKkK1vDSHBMmIMCwoR1NrUIKY1GwL8h3g",
	"VormXx10OEBKY9HmKJVOyq+isNBeYivMPCNzG6EpFBLnzgUM37lk50p0OwNqxSD9pwTtGlRrw9MlxIXp",
	"MBMaxRhN8UyLfq0NQxqy5haKpoEFh2ZTNW82ThVIMi9injixqy0vFRTuI8wyQHaOM5lFowIJgNIx0Sq+",
	"eqxZvh7wMgjRZd3AUD8rNeeybmVeBpYRY41dq5RpMmqhZlfo6m0rrXsPEqBdJTLXAa0Caj62yvjhIBdi",
	"IarMqbMKjMnj3HpZVRWrxm5ssKMUuxnnUcaaubg+z60nJJvNlREVd1M1cNBOPHgdtXeTJ+uT5N+iHfcV",
	"7TCzz7m3nie5X5OZdcRDFlAOemne4jrhek9J7Wg4kJcQ7lLL4rNiQpIrKFF3iwN+jpC5B8J70xb1XCWJ",
	"POTm6o5QmpA05pAlfStnG3Ms9Qt+qoQ8sgkWcCvQDOWpr9BB50qByu/n4ETy4vrRdEQYikYkus5zwAzk",
	"RsFV4pPCwXRsQws3rIUysjEUGBRg81GuSJgzYtYbujnXSrOY8UwgPmXGIOyg1xi+6ROlGen9rJ7pj5fB",
	"NZltXQY76DKAVW1dBp/mpRtZaWZC7yVhZn5rmRVktmPhifpFgVWPVxvtqL6dJ0wpmSVXlMcwlB3UaLj3",
	"M5qkCAuesbjBRtZ2S9mmBvMlziCJGMz6mo3cQdYTmlOwNO7QMabMUWg9tBdqBVPTHiNKx1R0JxEjQ5zm",
	"d/nunPHbdEw8eJW1MyrVCWl/nNqS48KAZW59eZKyRwREnisaR1g63hU3io40W1JPBZdaoXVPsppZVuDW",
	"MDXA6BhPSmH2Zke3JtkTPUKVfDT9WX8i+2eKIjWXtg816YWIdIYda8YWeFAErhOzy8TMB2ir2y0nZqN+",
	"Zjz9U0X9XEENo5MYPe+GxjGc22vbXWRWXMHXanTZkFneGnenRB+XNE9Frxxf4/bVWqU/F/3ZiqnoLvsr",
	"SNXrnLmxdyzmJStX/GEJz2L4UKIzE9HVbArO4Zm+HFEKQNngVamUxEaaiT5X/FuX7NkJtraf+ApMwCW0",
	"Z9FWd4BjsrEVvSAbT+Pvoo3n298/24iebUdPvvv+yVb8RMkCyTMBCemSiBsakQ24vRgGymq9IULqJWx1",
	"uoF7+6xyTZGOq16zrR34v063u/V7AeFE8PEk9aSoz43V+dL9If3iBggBzxKO486cGhwNiPPF7RQk5iaN",
	"P4PX3IkERmNZJuT7aJMUHSkrFcdw1FIOd7u3u0+/s3e7FZRGRLu3dOB2TklY156CPfsTYcN0BBYtyxI4",
	"Uo08V0Hl3u8tedkqqeXwmuZQsBi9AMV9O/Wk4iXhoPHC+fMaUcX6W5JvGZa6tWOoe8H8sOO3qeIxOsSK",
	"Td2qwkNcAq5yVlz8bORJ/C2gc8+Y96K5fmjpzGUkssRI8sCwATuTusRGAbI+wYsAaqozswd/9S25GPFk",
	"NQaY0vJng8rSs4ngcRYRgR7l5iXIPr09jzt+gxJ4ywKINeup4Y6OiUzxeKLAmJqgqHvrIN9W33l98uTJ",
	"i05jPKDC2bwxgSVPiJ/TlHFu+Y1GqCA6vmK0I+NyBHurWGV5DYb3LtL+Aenm2JQpNLSWgaWSmnwMg9uN",
	"Id8wP+pDrQWm82RDB711dUOFoWBI01HW70R8vBkpCocP5aaMrzeGfPNmexN+AEhraTX1jKMiymu0Ij7I",
	"S6R5rc7G5ClSGwpeRgm9JmhrG405S0dVZXNr2+dsjLMigajNRPZ9PRdMZOYxwuP1ycVpEAZ7vd+CMPh1",
	"f/9NEAZHJ8fnr4Mw+G2/d+psTsNG5yCFBgc+dcepR1a4ESrpZyIa0Rt/At9h5Rqhst/02yFiHDEyLVt3",
	"EWau818pi/Q+Myk9GsB8L4nBx1JOoLqjteb96ZVQlP+hTDgtaRCH2DQceIwshywnjeyg3bcXG695JmSI",
	"zkHTCVHv7SHaxUmiDIw0anAh+VbluTL1OWEs09h1k7fymuhEHIboeJylYGLUq3VUbrPqjMuR4NlwxLXJ",
	"pGAIddkZE98CqaFOsMD6ziDEm3Lv3D+lx6y+hiQr69UxcODCUMU6FdJW7QvBYLMnIv8ZTkEleeaazIop",
	"pM7hjDiTVIKkhTwjSIjByWSEWQYlW1A0wgp6IrRrK8ZyVDOOg7lFQD9XdnzoetzkjEU5xsltSoT61ORR",
	"mMRRxlMt7jSdmfhWA32DwWlKt+mKefIOyzmZFIshRX1BU3NQdtCFXoqx5fVbMuITODl9waG2CmRwQW5e",
	"HhsQOLqWHbTfGGE1KRT6TYi0JomuXACeYsCXKfjmZl4AFMoeAhcAK52FCMZ2yiXCi7qwYWd+YcNPTZj2",
	"F9w8z3GRJ/G7DKWcxm922cky0Bpu7skr8hIh3JujGfLWSOwEC88ujhST2j25OD7Pi1PlLujiHOgj8B5c",
	"D76DoKv6eDPtnQpQJV+9U0Pp0HC7hfqXDtvAZHMEspImdWB+0qkKhftJ6xCgAFlcC6KVO4NQU29Pam8R",
	"TWWdfUqltYeK8zz2ZnfEyxVX9ZZ8KhdvenP8duu383c/n757fb7349M3b0+/f/t717cpn0cwXLI7SIZl",
	"2K1PF1dL9FECJK6+zATb41NmCl+ckWF+M7eyIVI/KmW/on4mGGSDoZEeALITemhIbwjLP/F6MwutGvVJ",
	"OiXEWMxSH+9ohNmQxIjQ3LlbnbJIXhWKIRryUKOXnHsNhTj2Wbx0GQ7C4nspwvFgq4MAyk1MQ+Y4a5J7",
	"LfJA6uuya+kLgq9hX5WRiqOR1Xb0tjcvdUenYB/u7djoS1XszAnFK8x8akREcVgqiMj36e+KCkjK8AZj",
	"lFAwGaNTnfuX6lSlInW0EnUAMT3TukyegRU4tWTnGUevcmhOScRFHDQvwZSenRenuSFCZwfOibRUjtb2",
	"sy9dd6dUccfca/ws9XZquK8FcRtr0ZdLq3gvPC6XQLMUfla6qebDwFLl4Tvz1MXiUnqlcNVPh3vo0QWj",
	"N0RIOEcXetyfyC2N+FDgycgkXp5xofWU3DktHlcw+uq7Z79//+xZ7+DX3pvX+1vbx791d39+cfBaiUmc",
	"KkMp2An+/z+6Gy96L3f39g9evf7xzdHx259Pz85/+fXdb79ffdz+7tM/PPj/2LyyMb61vszvnlRdm+6s",
	"eOOv7saLq38/+u+d9/kfj//lme7KQwCHbEhkSuJVAmw9xZL058Y/CioZt4YalHgz3SiE4KISKyJ2ymWi",
	"bkuE2eIvF2YrVq4LttXqImqfh/avVnWtHC9z84bst7WpXJqyZfaI8QYvef0WvvIpwT9RmVYv3rpF8Ypj",
	"2Uoa1a7M1wqf17Ic83Grppj2zBiZ01YctgBA19KuxyVtXLyoyt2pZMfW3dKTFpW0jTJgy2d3apzXk1qr",
	"WMdug2MdQvusMnynHMX31yIvJSkVU4S2urhTwlsj25+7VKGZ9ZDL3SmlZDSuQC8PgFRKvvz7Ipgqnj4n",
	"2Rjvyx1IxgZU7kwueeuXtqTSPPPnJpPc0X1fJOLi5nORB2Qr+vRILXAhZlJKgTXZFuaOxIhPoaYBTiPj",
	"/MzL6Gu3SkVncRyZwU5wdnEU1JSiw9w1rBcC45yXNIQw7w/iaD3/6JS6gqgfbOklCbpyVUOEzBejpM30",
	"+9a/5RTl3wmODo8vzvfrekZpLfOJGLDcc96vGuJ1/Dt/WyMi7+9Ud9CiC4OthUF7B50fG5OTIGqf8mI3",
	"28XkS/vS5KMohqntWFPo4hiPSQxZZ28xxFYmgkiov6mAJLepwJGtr+P2l5FFwqxel9KUO+gNmcm82KcN",
	"dzEnMgW5f25ESj3NWEyEjLggToCqIX1rDi3Wq2vGK3b5amlhLUxylXMtyVqlyUaQdE7KXZH4Gey42tGv",
	"rt1DaVVC0/nSRT52yY77p9TpaLYSnIn15C+Zj7lAZxdHIer98ipER4fH+iLcUe+dG++RmgdbKQH9G2Ad",
	"xmGtUw8mWEgbws7L4hxwgS6OD3++2H9fCyOFZbA1REUBXD1FBx34QlAFAiwKFYzm7mjVn+Jw1do2TEsN",
	"W5ZoeVK6X6Mb2rnc2OVypVkWpP7AoZUdLRPb5v7wCWG6pg8v/r05uR5u6uEA4JoA8Jc9cnFsWHAmiefo",
	"m3QaLUBhg4IwcPc6CIPeL6+CUEkv9f9778p5mvrL8o40I6NXQu668fJzRsTslEi4junDi4BnOnaj9RJo",
	"ENPxJR//8dGnHFRcIlV/Q5Pr4kZfEtnatlQEoYimXkWG0LST3p/v8+kq1K3eGvOBUr5wgvlqifUGFe3S",
	"HjxGWhkCDqnwqc8cGJgGfWsqn5XytTWoWhOng531uZPKqPGIcsGn1jnf7iw9ZIIJa97+hTrnvKJZLdfX",
	"oFg73TCbkpDP66nHGvE69X5OEvFCZf7GXmLz5XEWUR8H8eumaBuRvI8iJHp15ancxSwhzfPDsVbpdezk",
	"hOzq/uOLahv/uv/y9cnJm6bT7xnxV9IfcX5958rC84a+8i9ml4/Hy1QP9AwBGT+eS/Y6VdZbPTNPgs8z",
	"4E1vd7eqVWd9dRLjUhfQeaVS3Dt/FiYqiyahHCIUJdDMOPVbe/68rAupzCpBCYuTWSlDy+l+72EXU7OT",
	"vhDlJF4R1WMew5WHBlxv30Me81W9P4oiQTctsJSIZcG16WGyE8wjZZ0qbNsfeC5JVSfT1NY0JwxTrwX1",
	"lROUvfaxJCcAa6zK4k04saGGvH8na3t4H+y2PMv98d7KPA2MeNm8SS+9+jInS4RXOHZ0RQGp+3isO3nS",
	"S3jL5U+ukwSLjpUtCbDZeepermxcsjHdLWWWrHL7o2fJc8T3XeSzEfH1Qhlm8HxNvvV4quAp9vEa2nDK",
	"JRth6YR46M2j+3hKJKHIhUQTJ+XMMCaX+zrK/LuN3Yuz85Ojjdf7vb3902DHKJGtFHg6ZJQNz0gkfCXI",
	"zvRjJOG5qe3JRRUgN2uDW5MrIvRGF++IIVX1AITlDvrQx5J89/QDIizisTrKmMV8jPqzVJ1QkwiSzNBE",
	"kAG9tVnmH6YjSaL3HzrolER8PCZMfSvpX2QHbT+tOOD0u2ffDbdf/8TOp/GL3uj19OLw6GA4/OXsxcmA",
	"v8WD4+flVJxH+qPH//0H3virt/F7d+PFvzd/uPr4ZDvc6na9qThBJjzNuiwVXZz+ZIpb1M4G1ftcZgej",
	"NJ3Inc1N8wuo5I0iqXKgFSDV3bxarGkce3mmQvfUOQqd+WexJpzueDCrYqiKX/MECBEUPaCyWyp1hrcB",
	"vIkXfTu8yx5e1CsVHSwah1Hd69qWgXu4p7yKya/p1PtD3J7DVc5UWPJk+nyP7mt5KuAc/qLDkbW+c6aq",
	"c357CNQzQVMiKK42Zo+40E21Y8qGl8zXlFwRodJLPphiEx9Mjc68k5saR2dKozGRkLAKx9bcz/byDd9l",
	"5KWseVZHxD0Z9iShN0TMzub0ArTv2H6APu0tL/OwNMUAKeyVwfBQz53UaU8RiuWUaUMcS6/rrfnOtNFf",
	"5vvTLNF3wbzKeEFOYdFBv7KZBdiLtHaA1dxLOB8JIkc8id8Wa15eQsOIWj4XOPjYEIZpLC/WMj/uFysC",
	"SbmF4dKt/my5wSUSrhyX9tyb4lmO+NQieFlqqG6QWXZzQ5uifqKTepzfaQpcUOoU0i6wctVUGdaQXt0d",
	"ZbiZNrQlSgUdDuEaR878PhgAP1hO88FZ04dLJjMxwdLeWCMi5/of8vV8UCzYR+Rlkmzh3fLA7pQlWqPJ",
	"b7KKRiRHXZ9AhWRTqWdlP4CVLg9L8CzrntjPsxWanRPuYluxvL2a9KsI7SJgsZpPHwozlqo3nl3s7u6f",
	"nQVhcNA7/Gl/LwiDs/3jvcPjV8HVIs/0fQSQCjeFBtWdshUOG8/SeaE4WYq2ipM1HSumj19mz/NdljKG",
	"bUVyh8G2pKsm0bdOn+b8ia58qF3Bi1ZoOobeFmCo5Fpb8O4Cj9upUXDud798gnCt++Sf4Mqz2NpbK2lK",
	"aqRGD6OVpjW7BewfZf7Ym6k5EmVdLtmkac+1SnuPqmT0KEs+qSSja0NfzazbJlmxtEyCumWKDZ4KreuH",
	"gRaYh3pg9YarNM3Jmy/eKYCV2WTCJTF1W3JloyTI/siTH97un+7uQ2KYTcnodtWmmMfHF0cv909LT7vd",
	"1sk5LdW5qulTzWMvELGsww4QArqHRoPa5jrzkMrQVns80x1vmHZwQRqxrdDplMqtFkRocU7W4AAsDk3d",
	"+7ci7SvEgCJpmzLoui5Vt35/VhSsPUzRGM/sqSmOSn8GN2ihzHol1/OPSpWIOVdpXbqqlyz5doTmHaEx",
	"vjWL3+pCQrT9a62ny/Us5+0+GJl62HWbY2c4enHkLpltUbe2s5eX9K7qFOZ53pIzHaFxlqR0YilAQFFC",
	"qMG8sFl6vsuWGq7mJWa1ud/ty3lqFZB0xOvKnCZP0GlughKVDEfIHPRWw/HaF3MOpM+9eDdZPMdYqfrc",
	"lvNZAkAPKf0IAFpvqsi5dTl400UW1D96WVXVkCA4GjX0oFkqJSnH/d3zkdaef6Rgq+ccNUnwnfanrCn5",
	"CJDRmHm02pkrFc1SK8TjZp3YkfZzrh3Nle+FAHs2V379Lc/G+nxHxm1kUqxy0mglVJbJsbofu/f+ErBa",
	"zOaziP05WHeXk1+0EN19eCrbENhqAVjwwnhkeVNR5Z5um6nrEXnilvbGSPkrPZopdAUDFDFs0xtPSSOj",
	"vuoegbrqfT8ha+3grq+geKEjLP6SsFU2HxAJ8Po2/y0XKU7gnrJvjyLOZDYmAkFTaVMZtHpvPEn4FKoR",
	"6zqdUl97d26KXpVUuqa1QclqBbPh//pvWf6krEhAuZy5N2wbC9/oFQd8/F4v7f1hj+09eTv59dft3vav",
	"4vn4xX8Gf5HXyat3z2/Hu++mrzqzZ38+Pdvo/frnQfbdn/8Z4IO/un/9/OfT/b+2n59KNvtl+uNg8O7Z",
	"n7dHN9xzIb2OpCa/QIjoIA8t5ZmgRctHuO4g87aWZuSy+K+if47Ab5Txfmu+pJvfSwVthxI+tmix45DJ",
	"x/tJhbdJAGu71F2EbptuF3nYjfeEgk8eigxQkzWctybDqfEN8PKBvS+SX7YCU2PJf8WVBO8nZLxcolsP",
	"mc/QHkkxTaTpgIYenR7sou+fd79/3LlkTuXo4oTmrS9sds3EjATxjjGewT1unchdvdkKcwFJxjPnljb0",
	"4cnvPkkT6HsKFUOUSga6Z4ysWpMjIRNsx8wON6F2+jjeEDVVy2YymNnrnLtSGYDcThLMtGJSXqwinKKL",
	"hS0eqSEoE87cFdbPDJOpv11bD12cHqK8qYm+LE8r7WMsjC1hU2gzWNpJeISTzR+PTpIolW9+eb7RVf/b",
	"qnedqZ/MOdlIkEBpMpEiHpN6hphumQG163OdsDV2n5YqDlKWPtkOnO6zz168cLrPPm0oaKMJq45vjOSI",
	"i7RWL0Jm4zEWswpcJpm2bCZ5SHVRtxGlixb5bBh23bfXzdPOPQyLttNvcmkc5Vsd2iPU7sKiDthb9rTW",
	"C4vVXqU79Xxi84LbhYTVm+tVFA8WjbivihBDWPRpKtT+65fA045NK3RRm41VWzvPU4+hmPUNTpbs0LrP",
	"snHdfLFjhXY1PpkxpyPyg0TlYTkrWdfRN44UCHoxPkWpyFjktuUZ8Ux88X1ogX4YoNHTNRFkw2q4Giey",
	"VDIlzwEvUHeZdbvb30FbsThLKBtCBu1e77cdBP/bh0zRGM8u2a/7+292nB+nhFxfMmhls1P8Ch1wLtlv",
	"+71T9+UZwaLUFmeZfjhhUOvMUsPBUd6vovAm4sS9JgmJwZLkDdZFtZ/+hE90o4JKbjI0W8AMD20nREp0",
	"GxEqdN9fplvAK3xSKMuviMhtJ+ICsVQqsW5Zp6cA29fUMzCNAdbhnV+oV8ckIavDZ76+R/iol6njGPR2",
	"41SC4r5OgeBlKiAvBGCeb38xghIsU2SG0J1jKKMp1cVwdXPkvLlMsd+9tHOPrZbm5ifPTyg7K6ywZeoC",
	"u73WcYMrEGt/NBf6FFYLeJiIqmWURcmN7SpWSm/OrbwB/vhJgq0LdteYk+hYu5gXe0qg70W1U57TqWeU",
	"9eWEQ+luKFf87DutMQs6IXY2eBhl8n2hfNdtlvry63b7div6WFiDw4e/Vb0Wi5tjuhvgzlLdi5btLdfl",
	"bjANTVq7Gha3Z9ITORTtp43FF8NqxFMB06WjhXjzdL3xnftfS+V+KqfbKfKla5nAnS43r9GUdgrddnml",
	"ZMb8hRYFvBxY1mpL6HFJbEIpppWLn+tPzbt5gkfRt6XeKiUT6mXWOOCrvCFLpQXMUs0bGlrQeKILFvhV",
	"V7iBDlPXbyaR4FOtk+mvZOHEF1oMQu1T+LQYWytpcH1f0hvbhYUKE6hQMpXc1h7qG8d6HBCuhuSMv0mO",
	"cZLYtl5pPhdQpK4CIMtT9nk6UoPKJfBdphBNN95cwPotDal0c5rOoNm0pg/oJrvL+TUlvUxR7kdf32ro",
	"zjclfYQnExTB2wpc9Tz/S4d6g/fvpa7xWJwnPKFvCGw+DOYEMOyUfYIFEQeWifMJ/hPydnygeAMcQRgA",
	"fsDpBYMV04/SdJJPvvK0CgOtp1q8xP9M0/pEvpUhypDiGhtGrysasS6A4hN42nXfvD0eeeyaPR5lY1vo",
	"IjC3T/Nrozmr6lC+GasBwDgdcF8chLAjp8IxIIxhaHejG3do/gdXhqHzganhWXyo0AtxEYlmPFO2s66m",
	"aVLeQl1XzZT6gjF1fU9tPJWsoI2NjUv2r5MJEabkJ6SoqeP4P//3/6BHAN1jpHsHcgZ8gJf701PmQAbb",
	"3/kXHNCERsSU/Dbk3pvgaETQNvRsKBC4s7k5nU47GJ52uBhumk/l5k+Hu/vHZ/sb251uZ5SOE8cNGJTw",
	"EYRBqSlEpwsR+glheEKDneBJp9t5oisNjGB3N/GEbt5sbcaknw03xyQVVG/7kHg9Kpp9wtvIvK1bzUJg",
	"PC+kXa7GKpGkiiOPKYsZHY5SdHG+W95OGAgKaBPxSD5Wm0NgI7W5rxjfmJY+DmBder9AJXlF0j0FlxkN",
	"lCZdbh0WtN3t6ra90IYdomTkNt2cJJhCyKXoeF5I+f9Cr/d/eotysn5vlnPctNBL9l/o/Le3+/VPIr22",
	"S1Z9osN3H43B8cNlobhtXQafEChane6S34XQruSHy0DpUDBMx5N98KlW53mvT4qNDfXONu4qZF097W41",
	"SZ8c/ZsXDGfpiAv6F4mNWzUvhQ8wmMSixeOQ2wn0aayNAhE38HNrUjDXy8Y5MaRYx6yBRoIr9YElfjd/",
	"ppH2wauFk6TcrEApkiJOiIR0E7MZym6mUgnpCacs1SI81dUDwHKMx5RRmQrN7iaZmHAJfOhwoKvmU+m6",
	"DJUuga+J+o1EJIYgA1jwcJ0PGnhDESKNC/WxjQ/6zkmljYW+ySuwDjg35vEUr2wCW32Lh6Sxg7HvZV1Q",
	"s+UHUFip9dsng4EkvuIcJ9AgsG+amlr1A74ptA/oIvhyZqUjLqW6lVwN1jpY5H7Iz9fVQh5kckMUvJv/",
	"kbzCiebpdE3dSDyn2tspBN0HrQFD6C4+yC9xbAJNHnbwIFkK4JCUj41lKe5pQo/2bydEUFCSkscVRnOz",
	"mMVURafSRChDWPvrBGZD0niqb1Y/zweCj1sfuHPuOWxOOxfTz5Mb2mg4eAkccu+xg14e5c4eeZBU/2WD",
	"pJ5mInc+du7Fk5V6fDkwTbJ0mZZf0Zdq+QWt3JZcq1JNnLbZWeou9sXWdrwVP/9+o/sCxxtP+1G0gZ99",
	"H2886z959mz76YsnJN6+78VuNy227ZWgcnO5usXczGr1EdDXvvrZcEjZsPO1s8cK63I5pP7h6lMYTLgv",
	"D18jGvoua8WNC9SHnjYuMpWxZy/QgY21b8wLk0fi9Ocuc0c9fM4fTXLBSx7P5jAGsPr03P9eTjYbcvkU",
	"No23AWv793zW85VznPDr5zNt2Uxr9lI0CPKcj9wBYkxrW1KtktHlHhwnuws6mzAEU6tBG14zgevGUWAe",
	"HGt3Kq+d1DP3pOoPwbOI9aktXPsmEbUix596CstlUUSkHGRJMss50NfMag9dJ5ePxzoKp3s/eb5Vm7c+",
	"Q5/LBj2wsH2zP+fYn4V9WdifrWLgRcCsLmuhADHCIhrRGxKXWwJ6IDQVi3vmfT+kDfe57t0GrrZWnKOU",
	"3S+Nf+XK3aA4ru3s3iZVz5578KITCpcGx7pImpJBMsUpjTqoZ2dUeLbP6UD/8yzJhqXNc/Pgdd8t+0le",
	"N2HGM8g8g+peRcgbDWgCVy1083d738JcjYc7sBFOoizRF/AtUCaeUCoUCVP+UyLTD8WkdnXQCUtmxYWO",
	"dITOLo6AsOqNvRROigvxynzIiRYKmtrFRJgxrtvn6bOPEpwSEZqwhDmpPtarUyYP8spt7XTh5c6lGd3J",
	"zpRN2ozFZ8pNLlGnhRqwtW5IfdCZR0VK24M54M/ajHHM00NlSqgD+XnYhN5uhFFRFnBpD5ml9s2P5l+H",
	"8SfNQhKSenI5ToBHu6wil2o0dU8Jy88EXMnzfRFCdY2Se78YwFABHEmahqifpeZDa5DaEWOuSyohPBgo",
	"jTgvBl12v0KIYEwwk3AVTHGnKTYFzCwiFTx22DwiCal312QWWtnE7Acl0C2gOvee3FCeyfIbI3xj666Y",
	"tEg0oAI6RyIMPXZtFlwfSyp9zGQPviuYyXKKXL7FgUdLeNooOYokzjWdp6d6soXn6YBn7LOcJKNprXCU",
	"Qr+a/4qkDs1DBaGGEOq97GX3c/Lrgdqlr5c21FbegcHqtvmL7UHTvd/mradFCzWpM53qzGzZeCfoKh10",
	"ztGApNHItA+GaeHqfn47zJkLTRKCJdwdgPftsixsmzYg/obMTsTh3qdScHfzo/PXiTAUo94y89olgLL1",
	"uQzhV3pLvpnB920GL1iEMXO1TLtnPlaJ3gIJtDFhNZ3eowH7UM3PoT0kK3K8zY/w3wXq5C+cxkpVw3o+",
	"rZ8pTZIqlQ4lnA1120gah+pnpeuxf2qs62KzlKFBJsCotYmoufnImeyg6hS5uihIKjiOFItMZnpEAhpk",
	"mF/nwWxmkuNgr0dYIpwIguMZ6hPCEE5TQfuZc5NMzwFWrSBjTJnWXAdZYcQ6Sm4/EwDRlBWNtWEE200D",
	"mfhErrKCDomRpGyY2NkUy5/xrDDBXf4Naixm+a0SUzODD9BWt6tVWsnRAAv0XdfAp5YJyzPjhc7KHlny",
	"duegqSTJ4DGa8iyJLYhOZbunXThAkDSo1OcbTs3pgUHD/N0+ifiYSNTVWFPzfNcttGkNHiDXIFCr/H5W",
	"rzYezvnSnN5QbkstWWdn50hTi3tQ1utdNaqn3ReLv9/lbJDQKP0c/EltrD3OqzAoSwjzVDL9TserPxzp",
	"79eY9OC2credyit3KExmsz4DpX7vefgr9DUx/kdH/ysX0P/o2EJSLeq8JNkw2CnXPTGlHm0j/HLDe2+/",
	"7qX6XS8T9Leb9KAF6dhSi6VTQz7NDtt/9RZkOf/rUPs/PTnnofV74sKTVvTPYQM6zDQ1owFNiBrskuV+",
	"JJ1K3ujD1PtzPx5Ms/d+n6XOKF+7x9KttvRVH8Dwrpuw+80l2+7E/8///T/IHKexOS21Y1+TRJsf4b+H",
	"8QnEWeYqzAt5wyXT9lTe7L4/Q4d7EOhJsmGzT9Ee7uU0pRLgLfUlDXDZp3g3DeUBE4PZjEZimOM/9Gyf",
	"z4F4TxvX/cZA18hANc27ntIH6OVcnWNpf1SjRv2zcy8M+nbCZc8aMcNrayHn8P5ysNu86lxAXu6Tczom",
	"v3PW/rMDiKUX7ciW+eqVOWptv8rfvzOz0GmIf3z0nfZKSmIlhbExVdA2INi2J9itAFGrV2gO+bzSD2qV",
	"ulpqUz2DlC+c4A5cBA7DKZHqlMNNYXKbbkbypunqnJ7xPVyNDs0fhMWhQVgI+A0VPkPA1SXzLSus/LgF",
	"P1pUv98Kne0JIfU13NquDbVVHkqjZnvxUNvd2lDbvqGelIfaLg2l01XDp22u312AQ0mR49ecwOiw39W4",
	"uw32zHeZ5OEqXaxFG5PNDpQzO+gXUV18fpgKSynoa36t17beCoufNZHaPXorclAXkItbmHvTrcQ/P9Tp",
	"7YLRFKzz9jJeKXT3cIJrQF6lqJopo7jG4BoAZDJP92xTgXsNsXl3as558JPB157W6V21c85KPb5a53ju",
	"uhlMzU2sfV49X7/v+/Hx+Xr+l7sQ+N1/3g4eXyh/0dsdvQ72sQ/kh5fY+OBCOwUdexDY+pQsElGbH82/",
	"FkSnjfPGS3+NOV36I/+pWk5q5UC2dKx5ie6rz93L3Z13Ipm5eXzLEcArkt777ncfBEP7G2T+3ZGovHWS",
	"LyZxM5Nrpiv92X2Q1sMX9VoZbiPqH8bJsAVdv9qzYWj4XsR0m6odNTvSlEhqYUXepWrHQ7YhC+NxdYNR",
	"e4bzpO/VvNB3FVdLd8laulqEj3L+VoanWrNc00Hd/Aj/Nbp0WzVK36pvq0TpHV72yBq47k6Ry7fcMyR5",
	"tUhgaDT83RQpYrbzbuQnbFu9JcSEbl/aQkronn3fHI0rOhpXkzefy9DRm9tWQBQtb/828kEY6r8vryR0",
	"8WzlkoQOmPdvpNR7wLaxUKDv7gPwROo2oQtEDQD7zQe5og9SaDpcg8Ta/Kj+s4LrETZwCb+jOTrLSTAN",
	"2yoeRwDvb+puXIo62vsa5+94RUde83Z3PyunUr//7dTgJalmCWfifMKpexLvTjsPWTx/ae9hK/EMJ+Dv",
	"4jdck3DVTRjKaUurJKRW+lV47tdPsn5Co2SGyO2Eg5EDep/5TjYks+oeEw0pre0b4OepVGABQvea3ADM",
	"11yj7tCbJ1jJhF7VT/iVZM5+5hzYb/mf3/I/P5t5bxoJAa+pNbv540qRvL/Xzx9Xiryr+aOm4U01jVR/",
	"7WXLtp5sAxNucZUJHBPeZkKNPjxnNXIRzy0qqJeGLgqpd9Ce3gwlArafdZYvrL79zKmrrv74jGXVW8VR",
	"HHwtE0Ep78W3e4EtroIB6kp48x2jhb4073HoNHjS3N1dVkt3b3clCZ9CA16tawDIJU3iqulqRutbDyVC",
	"9Cv3pZ5bS7nd1iecF4D58G7K3pd/rNLarbU82KQM6rlg7fZa8Qr8JTvMh5ENIsK5O2n6BHkr1dthKpJj",
	"pcMC5FYMiXCS+Grvu8+rrDS/y/RRodB5F1Yzf7TyCYEP3AEX3peszyiLfr7tF2FugFisuxA0MIlPJTZR",
	"bo/pa/DcYtG1exprWkq9P2q1iWONKUBTekRjhxSVQmHqrZE41CXf9IS2Im5xTOLOapXa35YWUhrvm7xe",
	"LK8dslgotR1mt/CyVFu9N78v1KDpOheo7l9NLK6Yrnrf6QFKslwr89x3yrF7hzotl+xiIolIpcNBTHkI",
	"qXiB9vZJRzwdDtzKj3m5MyhpCwXQLHewcbzaJ/CqLL07wSKlOElmee3qvLZtXsvOlM72OovVEuz+r+7q",
	"XTeZnTuLBh+vAnP9uuC6wTavGni/8eJ2p1QTYa6NeI+phwfn1UkP4xPxhszWVlolL9RsNcxrMmsOyhaH",
	"Z7kASxn4ljFZS2DlSOzXUIju4Zd5mUuf4crqwCuStqa4VyS9P3Jbnxmdc8xmDvmVR4MV2TgbuzpPu0s7",
	"3bJ1gw64QNGIRNeV8vkIQ8+nsCgDDQadEyFjMiU4XqCq3qkLbpU6P3994XatxYo1LtW/0C3v/b+nKasp",
	"HF4j4dU61RTMb4QlSkeCEKQQKKsY2ilK05rGR6aSrello3RD9SEynoQZitX7Y8qIBPqFh+VB9VcZi4lI",
	"Zm7nGYAFujYo3OGUKlada9DuKYFRc6vell20beEekc6wE9rKGJUyvYyQWDotA7CUPKKFsm6+egyFgTfQ",
	"S73q8l7EZEAZMUgoRjJHV82OLoNdzOAUn52dIEU8agRN8ZdBRw19pj8vjZyQFKr36lY+CYdyyuVyktMR",
	"tQWJoXJyedYLqbt2UFnur/EO/YYkSdUn8jJAj9QE1YKVjwGsozrSTEeNsa7STFCEJZGhrqRsBkXZRFeb",
	"2tCNgzRY0LnPKgnqLbWxCblVVlVMUyRnUh31DkL72q23A7RhPVbQ1UhNuNXtdrvIFjaTKM6EbU6iSxUr",
	"suexIrQKqcA29tCQ3hCWi3Y1LLQTgmVxpvYOCvg/YpxtGH3ucbk6P8kbFr0hs6LKspjV+pq4n2m2X3yo",
	"izHb0tZQ5prZyZ3vwhI9g3k5wDSxFPq0+wJBH3xYne4Uw8qFomVek9R0h2I8RWMe08EMmqfA8vVKEU2b",
	"M4RdLrsWNWf96UsOiG36MpX4yJfJKC6JrjqUzuOvMI34gfd4Kp2jVYpet1MfSw071BsHOY/4tGwrEypl",
	"ZhuSsLqkdQlecT7oiqQEWGyb1PUVT5DGb+5wuaZu7JX2Dp9DxWzE1ir66cPs4/G5tWZdsn8J1dm06Pjf",
	"0E7DcxjurDRrWrfKH0Z9MsI3lIscNaAGgTriFGYra1JwImdwDEH3AH1IbSl0L4kyIfLWJoInCb8hQl8R",
	"UhoBZtegUU1HNBrlXR9zeKY0JkhgNgSF2yhgE5ymRDBpVQe3n0Wo1L8xl6lW6GDEmLN/pnkDNa1W0Qh8",
	"2kbJUSqObdbym4EBtAlgQyX8a73GgwZp1TLdKARWoJRyraYVnTOcliCGc5kAdJynbNbYnR4TOjWZNiOo",
	"T9IpIQyYnP5JwaXjkCzWP99OqFGwIYXZ9HMG+6TP0xH06sQsxikXM5jcwQO4jvS6TU+OiaBc0HSWq8ew",
	"hrJtRAUClqIXSjroJz4lAjHIlTIjjehQMWg7XKi3sYv6xOq/8IZM81dcYHIywy5xWZDyTlYpVwYKHyt8",
	"QBYsZhlOkCBqR9WbTnueUqsUjGJMk5k7OJWI/JlBCM8ZAFYP7f307pAbImYoxjP0iA4ZB2U+p3drpmgT",
	"7LT6syX4qW4UM5mYRDKtMY8xhYYyTlMU249GKd5IEEnSDnqpH7/vDVIi3p+qH9EP6Ojw+NERvrVT9oAO",
	"Q3TUe/fIfvCSDLgg+osQHVFWfvnx4zL6bY/FkTqWMeLQNUcLhJIOHptMaApLIUxC51C1QrsQKnPyoVLZ",
	"jYIMsYgTdcj5QLdz1e18lNii81qkrtarZa0y+/5NAVikYw80mQOaNr68IWCkcR1I3fXmW6/WZS8Vrty1",
	"Zg0KfJ6F49Xfy3ce5AiaOfWh9Z/R4rXsBgexbUo44CIyUq5Xdi4bz50cYaH59wjLnpH+1iun/TwUOnxl",
	"JG+Uprs/jbMkpZOEIJ5qYWOTgqC3iW2kVu4IXZ0/76MVcXZDGAVhIAiWnMnQerGnXFwbTQRkagmDsM75",
	"xscr4toevwCSv7TpUc0EolpzSelYX1xRe6ixvgOaxQY8oQydHuyiJ0+evFA7PsZpngENEoDxqUaAzxBR",
	"IwT+SycNFbT1FMFOkEMQrN/+aMno9La1cM4A0r6iqOq9XHME7y0oXwZhcIwMA1HKz5fxZyy+cq27/pU2",
	"XJAbfq24Tu47VqtzHPSGO3RQTxamTLNTt9l/G2p96TIY06GA9veXQbmfvrWAjIsUmkAlFac4lmhKkqRz",
	"yXo50DY4kuXs2xguIypTLpQpZRQ0GerBPYiY8EmWQMKSmtdoiL0UmIpM8XjSQb8q+I2mZ8xNYCx90E9B",
	"dQzr7QMlkilNErCiaAxWmTbSQtdNDGt3mjYa9RV2xIYbtA2qNNYx5OxpX3eobDdlMIAgSUdKXw8RzmKq",
	"ltmct7FOL/OSDL1lsofrk/3bXL1f1X/SeOveJUZ9afpeIuFlPeEhUNRykhQnSYsqWOUAeDWZO8EyBSvV",
	"p38SpB5rjmF6fWJpbOMgXFGfEATHJyyZ2UuxC/O3rxbEPv4GVQq+lHje1OKo+eL2KWj90hVb1hOhRFyW",
	"3+dsdsRZ6WSmAkEoJxDvjASXsrA7gPCKwpKX7GUmWMyn7LX5VBhoIBaeUsYzmQ/LB0iSIawSxLoxguxv",
	"YMNIAvxBGTEzM4/xKhrHjAmEFO13+waCwpNnlunGmwFWfS2axFVYp+Z3H65MuJowQaORzTzIPT1MHy/K",
	"Wd7jOim54DXsU7VU7Qh02huDpaeewvSLuaMB+/MzyZrtBF2CcttJO7JTDmQ0c6lrCTvqkqWW12nmBil+",
	"EqUiY9rp7nSTzhKsN1onETgJKk67Tp89Bt2L1m+PhXUdJF4veoyZCbdmUvWH7ho9XD+KUv45EHRG/yIW",
	"Nli/PgRqBdAAyzjM9TntzzpoN/fQyhEX0Pt0hE07bnfBzQtz+k/NLQthIoKmQ1UYvD65OA3CYK/32x2K",
	"AVYrMtynBW/ZnHGEW7bRYMePcmaowcm78H8z5OcY8lYCOKIN2zS3UqJY5zNqCsIqkf6oqI6djLG41taq",
	"tFxcJ0OV0rM8qoIOwEHLfGXvauFrQ0Ed1Eurg5qh9LhUor+I4DHimR7JyEfwW/IkITGC2JHruqSiHmrq",
	"oMPUNNVPZxMT71RcYcYi9xZP3nmrT5NEsT0DDcRswENrAKtMKLN+jjNQGi4s+CbwZqbUipBCky9oWh3V",
	"xa3t4+96luEyOfB5HdHLJ6A6GMZmwCWNMyHmakGSuwoKZtFIB7hTfyKJ1Z/oABIr/VEnIBGHTC9MX9Iv",
	"YZWtFnMqm1Z5CLnXYFyB7FE6GDhJdGBS4T3F18RGoEMUVwQxKM36xSJyaBI0B5l2fJ27V8m0QUw9snpM",
	"WZYSFGegIoz41NXjtXQDfRQcQlzYbVuLWFZYTjFlPaAdn/cvD4JPRyRXu0uMwtAdVTapGotAZpJBol6i",
	"swmaii/ZBjocIJC8bUa0HwxwIhd9MX/eAgcmR7rpsvIKV4v3S/5RsM+/ydEmOapl0ao2daWUT162x1/M",
	"Z5fza0pKdXyIuPGXv0l4BDXAMpEEO8EoTSc7m5tb2993up1uZ2vn+fPnzz32UKSmKX0ldzY3+YQwrWzr",
	"52pms0CPvQCCQFFwYtkDZUMijdM5RjHpZ8NhkbiU2+B//ESwYGjMBbl6VJ+b8s2YR3JzqAXoBghoEm/C",
	"KJtKtt5QMn0MZ8NoyqYbhNesqYMJ8W7Khvq6AWi7uZlxB/iMZPACaBovtgTQpM2Xqtm1BmvMGUnpX2Qz",
	"xnLU51jEpnTHRkxuSKKEzcYwozEpAWguwbcE0LnVviKy7AglIPI7Uy3BqGR9LYugkmrqp6s5p7oO415O",
	"8FZNkh10IckgS0DvKg4EuF70Uem488EIbVdfKr7Ye3toVAKjmWWSCKmjTJDSBJl+hZanb0fk/iqOJGFx",
	"aUh5yVKObrCgHAJOuusaejQl/RHn1yGSCY6uQ0TSSGdTrUgJpdrK3l2YV0ny09Wn/xcAAP//iDmTI8Z5",
	"AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
