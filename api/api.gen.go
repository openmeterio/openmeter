// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/cloudevents/sdk-go/v2/event"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	"github.com/openmeterio/openmeter/pkg/models"
)

const (
	PortalTokenAuthScopes = "PortalTokenAuth.Scopes"
)

// Defines values for AppCapabilityType.
const (
	AppCapabilityTypeCalculateTax     AppCapabilityType = "calculateTax"
	AppCapabilityTypeCollectPayments  AppCapabilityType = "collectPayments"
	AppCapabilityTypeInvoiceCustomers AppCapabilityType = "invoiceCustomers"
	AppCapabilityTypeReportEvents     AppCapabilityType = "reportEvents"
	AppCapabilityTypeReportUsage      AppCapabilityType = "reportUsage"
)

// Defines values for AppStatus.
const (
	AppStatusReady        AppStatus = "ready"
	AppStatusUnauthorized AppStatus = "unauthorized"
)

// Defines values for AppType.
const (
	AppTypeSandbox AppType = "sandbox"
	AppTypeStripe  AppType = "stripe"
)

// Defines values for BillingCustomerOverrideOrderBy.
const (
	BillingCustomerOverrideOrderById BillingCustomerOverrideOrderBy = "id"
)

// Defines values for BillingDocumentRefType.
const (
	BillingDocumentRefTypeCreditNodeOriginalInvoice BillingDocumentRefType = "credit_node_original_invoice"
)

// Defines values for BillingFlatFeeLineType.
const (
	BillingFlatFeeLineTypeFlatFee BillingFlatFeeLineType = "flat_fee"
)

// Defines values for BillingFlatFeeLineCreateItemType.
const (
	BillingFlatFeeLineCreateItemTypeFlatFee BillingFlatFeeLineCreateItemType = "flat_fee"
)

// Defines values for BillingFlatFeeLineCreateOrUpdateType.
const (
	BillingFlatFeeLineCreateOrUpdateTypeFlatFee BillingFlatFeeLineCreateOrUpdateType = "flat_fee"
)

// Defines values for BillingInvoiceAction.
const (
	BillingInvoiceActionAdvance BillingInvoiceAction = "advance"
	BillingInvoiceActionApprove BillingInvoiceAction = "approve"
	BillingInvoiceActionDelete  BillingInvoiceAction = "delete"
	BillingInvoiceActionRetry   BillingInvoiceAction = "retry"
	BillingInvoiceActionVoid    BillingInvoiceAction = "void"
)

// Defines values for BillingInvoiceExpand.
const (
	BillingInvoiceExpandAll          BillingInvoiceExpand = "*"
	BillingInvoiceExpandLines        BillingInvoiceExpand = "lines"
	BillingInvoiceExpandPreceding    BillingInvoiceExpand = "preceding"
	BillingInvoiceExpandWorkflow     BillingInvoiceExpand = "workflow"
	BillingInvoiceExpandWorkflowApps BillingInvoiceExpand = "workflow.apps"
)

// Defines values for BillingInvoiceExtendedStatus.
const (
	BillingInvoiceExtendedStatusDraft                     BillingInvoiceExtendedStatus = "draft"
	BillingInvoiceExtendedStatusDraftCreated              BillingInvoiceExtendedStatus = "draft_created"
	BillingInvoiceExtendedStatusDraftInvalid              BillingInvoiceExtendedStatus = "draft_invalid"
	BillingInvoiceExtendedStatusDraftManualApprovalNeeded BillingInvoiceExtendedStatus = "draft_manual_approval_needed"
	BillingInvoiceExtendedStatusDraftReadyToIssue         BillingInvoiceExtendedStatus = "draft_ready_to_issue"
	BillingInvoiceExtendedStatusDraftSyncFailed           BillingInvoiceExtendedStatus = "draft_sync_failed"
	BillingInvoiceExtendedStatusDraftSyncing              BillingInvoiceExtendedStatus = "draft_syncing"
	BillingInvoiceExtendedStatusDraftValidating           BillingInvoiceExtendedStatus = "draft_validating"
	BillingInvoiceExtendedStatusDraftWaitingAutoApproval  BillingInvoiceExtendedStatus = "draft_waiting_auto_approval"
	BillingInvoiceExtendedStatusGathering                 BillingInvoiceExtendedStatus = "gathering"
	BillingInvoiceExtendedStatusIssued                    BillingInvoiceExtendedStatus = "issued"
	BillingInvoiceExtendedStatusIssuing                   BillingInvoiceExtendedStatus = "issuing"
	BillingInvoiceExtendedStatusIssuingSyncFailed         BillingInvoiceExtendedStatus = "issuing_sync_failed"
	BillingInvoiceExtendedStatusIssuingSyncing            BillingInvoiceExtendedStatus = "issuing_syncing"
)

// Defines values for BillingInvoiceOrderBy.
const (
	BillingInvoiceOrderByCreatedAt    BillingInvoiceOrderBy = "createdAt"
	BillingInvoiceOrderByCustomerName BillingInvoiceOrderBy = "customer.name"
	BillingInvoiceOrderByIssuedAt     BillingInvoiceOrderBy = "issuedAt"
	BillingInvoiceOrderByStatus       BillingInvoiceOrderBy = "status"
	BillingInvoiceOrderByUpdatedAt    BillingInvoiceOrderBy = "updatedAt"
)

// Defines values for BillingInvoiceStatus.
const (
	BillingInvoiceStatusDraft     BillingInvoiceStatus = "draft"
	BillingInvoiceStatusGathering BillingInvoiceStatus = "gathering"
	BillingInvoiceStatusIssued    BillingInvoiceStatus = "issued"
	BillingInvoiceStatusIssuing   BillingInvoiceStatus = "issuing"
)

// Defines values for BillingInvoiceType.
const (
	BillingInvoiceTypeCreditNote BillingInvoiceType = "credit_note"
	BillingInvoiceTypeStandard   BillingInvoiceType = "standard"
)

// Defines values for BillingLineStatus.
const (
	BillingLineStatusDeleted BillingLineStatus = "deleted"
	BillingLineStatusSplit   BillingLineStatus = "split"
	BillingLineStatusValid   BillingLineStatus = "valid"
)

// Defines values for BillingPaymentTermDueDateType.
const (
	BillingPaymentTermDueDateTypeDueDate BillingPaymentTermDueDateType = "due_date"
)

// Defines values for BillingPaymentTermInstantType.
const (
	BillingPaymentTermInstantTypeInstant BillingPaymentTermInstantType = "instant"
)

// Defines values for BillingProfileExpand.
const (
	BillingProfileExpandAll  BillingProfileExpand = "*"
	BillingProfileExpandApps BillingProfileExpand = "apps"
)

// Defines values for BillingProfileOrderBy.
const (
	BillingProfileOrderByCreatedAt BillingProfileOrderBy = "createdAt"
	BillingProfileOrderByDefault   BillingProfileOrderBy = "default"
	BillingProfileOrderByName      BillingProfileOrderBy = "name"
	BillingProfileOrderByUpdatedAt BillingProfileOrderBy = "updatedAt"
)

// Defines values for BillingTaxBehavior.
const (
	BillingTaxBehaviorExclusive BillingTaxBehavior = "exclusive"
	BillingTaxBehaviorInclusive BillingTaxBehavior = "inclusive"
)

// Defines values for BillingUsageBasedLineType.
const (
	BillingUsageBasedLineTypeUsageBased BillingUsageBasedLineType = "usage_based"
)

// Defines values for BillingUsageBasedLineCreateItemType.
const (
	BillingUsageBasedLineCreateItemTypeUsageBased BillingUsageBasedLineCreateItemType = "usage_based"
)

// Defines values for BillingUsageBasedLineCreateOrUpdateType.
const (
	BillingUsageBasedLineCreateOrUpdateTypeUsageBased BillingUsageBasedLineCreateOrUpdateType = "usage_based"
)

// Defines values for BillingValidationIssueSeverity.
const (
	BillingValidationIssueSeverityCritical BillingValidationIssueSeverity = "critical"
	BillingValidationIssueSeverityWarning  BillingValidationIssueSeverity = "warning"
)

// Defines values for BillingVoidInvoiceLineAction.
const (
	BillingVoidInvoiceLineActionDiscard          BillingVoidInvoiceLineAction = "discard"
	BillingVoidInvoiceLineActionPending          BillingVoidInvoiceLineAction = "pending"
	BillingVoidInvoiceLineActionPendingNextCycle BillingVoidInvoiceLineAction = "pending_next_cycle"
)

// Defines values for BillingWorkflowCollectionAlignment.
const (
	BillingWorkflowCollectionAlignmentSubscription BillingWorkflowCollectionAlignment = "subscription"
)

// Defines values for BillingWorkflowCollectionMethod.
const (
	BillingWorkflowCollectionMethodChargeAutomatically BillingWorkflowCollectionMethod = "charge_automatically"
	BillingWorkflowCollectionMethodSendInvoice         BillingWorkflowCollectionMethod = "send_invoice"
)

// Defines values for CheckoutSessionUIMode.
const (
	CheckoutSessionUIModeEmbedded CheckoutSessionUIMode = "embedded"
	CheckoutSessionUIModeHosted   CheckoutSessionUIMode = "hosted"
)

// Defines values for CustomerOrderBy.
const (
	CustomerOrderByCreatedAt CustomerOrderBy = "createdAt"
	CustomerOrderById        CustomerOrderBy = "id"
	CustomerOrderByName      CustomerOrderBy = "name"
)

// Defines values for DiscountPercentageType.
const (
	DiscountPercentageTypePercentage DiscountPercentageType = "percentage"
)

// Defines values for EntitlementBooleanCreateInputsType.
const (
	EntitlementBooleanCreateInputsTypeBoolean EntitlementBooleanCreateInputsType = "boolean"
)

// Defines values for EntitlementMeteredType.
const (
	EntitlementMeteredTypeMetered EntitlementMeteredType = "metered"
)

// Defines values for EntitlementMeteredCreateInputsType.
const (
	EntitlementMeteredCreateInputsTypeMetered EntitlementMeteredCreateInputsType = "metered"
)

// Defines values for EntitlementOrderBy.
const (
	EntitlementOrderByCreatedAt EntitlementOrderBy = "createdAt"
	EntitlementOrderByUpdatedAt EntitlementOrderBy = "updatedAt"
)

// Defines values for EntitlementStaticType.
const (
	EntitlementStaticTypeStatic EntitlementStaticType = "static"
)

// Defines values for EntitlementStaticCreateInputsType.
const (
	EntitlementStaticCreateInputsTypeStatic EntitlementStaticCreateInputsType = "static"
)

// Defines values for ExpirationDuration.
const (
	ExpirationDurationDAY   ExpirationDuration = "DAY"
	ExpirationDurationHOUR  ExpirationDuration = "HOUR"
	ExpirationDurationMONTH ExpirationDuration = "MONTH"
	ExpirationDurationWEEK  ExpirationDuration = "WEEK"
	ExpirationDurationYEAR  ExpirationDuration = "YEAR"
)

// Defines values for FeatureOrderBy.
const (
	FeatureOrderByCreatedAt FeatureOrderBy = "createdAt"
	FeatureOrderById        FeatureOrderBy = "id"
	FeatureOrderByUpdatedAt FeatureOrderBy = "updatedAt"
)

// Defines values for FlatPriceType.
const (
	FlatPriceTypeFlat FlatPriceType = "flat"
)

// Defines values for FlatPriceWithPaymentTermType.
const (
	FlatPriceWithPaymentTermTypeFlat FlatPriceWithPaymentTermType = "flat"
)

// Defines values for GrantOrderBy.
const (
	GrantOrderByCreatedAt GrantOrderBy = "createdAt"
	GrantOrderById        GrantOrderBy = "id"
	GrantOrderByUpdatedAt GrantOrderBy = "updatedAt"
)

// Defines values for MeasureUsageFromPreset.
const (
	MeasureUsageFromPresetCurrentPeriodStart MeasureUsageFromPreset = "CURRENT_PERIOD_START"
	MeasureUsageFromPresetNow                MeasureUsageFromPreset = "NOW"
)

// Defines values for NotificationChannelOrderBy.
const (
	NotificationChannelOrderByCreatedAt NotificationChannelOrderBy = "createdAt"
	NotificationChannelOrderById        NotificationChannelOrderBy = "id"
	NotificationChannelOrderByType      NotificationChannelOrderBy = "type"
	NotificationChannelOrderByUpdatedAt NotificationChannelOrderBy = "updatedAt"
)

// Defines values for NotificationChannelType.
const (
	NotificationChannelTypeWebhook NotificationChannelType = "WEBHOOK"
)

// Defines values for NotificationChannelWebhookType.
const (
	NotificationChannelWebhookTypeWEBHOOK NotificationChannelWebhookType = "WEBHOOK"
)

// Defines values for NotificationChannelWebhookCreateRequestType.
const (
	NotificationChannelWebhookCreateRequestTypeWEBHOOK NotificationChannelWebhookCreateRequestType = "WEBHOOK"
)

// Defines values for NotificationEventBalanceThresholdPayloadType.
const (
	NotificationEventBalanceThresholdPayloadTypeEntitlementsBalanceThreshold NotificationEventBalanceThresholdPayloadType = "entitlements.balance.threshold"
)

// Defines values for NotificationEventDeliveryStatusState.
const (
	NotificationEventDeliveryStatusStateFailed  NotificationEventDeliveryStatusState = "FAILED"
	NotificationEventDeliveryStatusStatePending NotificationEventDeliveryStatusState = "PENDING"
	NotificationEventDeliveryStatusStateSending NotificationEventDeliveryStatusState = "SENDING"
	NotificationEventDeliveryStatusStateSuccess NotificationEventDeliveryStatusState = "SUCCESS"
)

// Defines values for NotificationEventOrderBy.
const (
	NotificationEventOrderByCreatedAt NotificationEventOrderBy = "createdAt"
	NotificationEventOrderById        NotificationEventOrderBy = "id"
)

// Defines values for NotificationEventType.
const (
	NotificationEventTypeEntitlementsBalanceThreshold NotificationEventType = "entitlements.balance.threshold"
)

// Defines values for NotificationRuleBalanceThresholdType.
const (
	NotificationRuleBalanceThresholdTypeEntitlementsBalanceThreshold NotificationRuleBalanceThresholdType = "entitlements.balance.threshold"
)

// Defines values for NotificationRuleBalanceThresholdCreateRequestType.
const (
	NotificationRuleBalanceThresholdCreateRequestTypeEntitlementsBalanceThreshold NotificationRuleBalanceThresholdCreateRequestType = "entitlements.balance.threshold"
)

// Defines values for NotificationRuleBalanceThresholdValueType.
const (
	NotificationRuleBalanceThresholdValueTypeNumber  NotificationRuleBalanceThresholdValueType = "NUMBER"
	NotificationRuleBalanceThresholdValueTypePercent NotificationRuleBalanceThresholdValueType = "PERCENT"
)

// Defines values for NotificationRuleOrderBy.
const (
	NotificationRuleOrderByCreatedAt NotificationRuleOrderBy = "createdAt"
	NotificationRuleOrderById        NotificationRuleOrderBy = "id"
	NotificationRuleOrderByType      NotificationRuleOrderBy = "type"
	NotificationRuleOrderByUpdatedAt NotificationRuleOrderBy = "updatedAt"
)

// Defines values for OAuth2AuthorizationCodeGrantErrorType.
const (
	OAuth2AuthorizationCodeGrantErrorTypeAccessDenied            OAuth2AuthorizationCodeGrantErrorType = "access_denied"
	OAuth2AuthorizationCodeGrantErrorTypeInvalidRequest          OAuth2AuthorizationCodeGrantErrorType = "invalid_request"
	OAuth2AuthorizationCodeGrantErrorTypeInvalidScope            OAuth2AuthorizationCodeGrantErrorType = "invalid_scope"
	OAuth2AuthorizationCodeGrantErrorTypeServerError             OAuth2AuthorizationCodeGrantErrorType = "server_error"
	OAuth2AuthorizationCodeGrantErrorTypeTemporarilyUnavailable  OAuth2AuthorizationCodeGrantErrorType = "temporarily_unavailable"
	OAuth2AuthorizationCodeGrantErrorTypeUnauthorizedClient      OAuth2AuthorizationCodeGrantErrorType = "unauthorized_client"
	OAuth2AuthorizationCodeGrantErrorTypeUnsupportedResponseType OAuth2AuthorizationCodeGrantErrorType = "unsupported_response_type"
)

// Defines values for PhasesOrderBy.
const (
	PhasesOrderByKey        PhasesOrderBy = "key"
	PhasesOrderByStartAfter PhasesOrderBy = "start_after"
)

// Defines values for PlanOrderBy.
const (
	PlanOrderByCreateAt  PlanOrderBy = "create_at"
	PlanOrderById        PlanOrderBy = "id"
	PlanOrderByKey       PlanOrderBy = "key"
	PlanOrderByUpdatedAt PlanOrderBy = "updated_at"
	PlanOrderByVersion   PlanOrderBy = "version"
)

// Defines values for PlanStatus.
const (
	PlanStatusActive    PlanStatus = "active"
	PlanStatusArchived  PlanStatus = "archived"
	PlanStatusDraft     PlanStatus = "draft"
	PlanStatusScheduled PlanStatus = "scheduled"
)

// Defines values for PricePaymentTerm.
const (
	PricePaymentTermInAdvance PricePaymentTerm = "in_advance"
	PricePaymentTermInArrears PricePaymentTerm = "in_arrears"
)

// Defines values for RateCardBooleanEntitlementType.
const (
	RateCardBooleanEntitlementTypeBoolean RateCardBooleanEntitlementType = "boolean"
)

// Defines values for RateCardFlatFeeType.
const (
	RateCardFlatFeeTypeFlatFee RateCardFlatFeeType = "flat_fee"
)

// Defines values for RateCardFlatFeeUpdateItemType.
const (
	RateCardFlatFeeUpdateItemTypeFlatFee RateCardFlatFeeUpdateItemType = "flat_fee"
)

// Defines values for RateCardMeteredEntitlementType.
const (
	RateCardMeteredEntitlementTypeMetered RateCardMeteredEntitlementType = "metered"
)

// Defines values for RateCardStaticEntitlementType.
const (
	RateCardStaticEntitlementTypeStatic RateCardStaticEntitlementType = "static"
)

// Defines values for RateCardUsageBasedType.
const (
	RateCardUsageBasedTypeUsageBased RateCardUsageBasedType = "usage_based"
)

// Defines values for RateCardUsageBasedUpdateItemType.
const (
	RateCardUsageBasedUpdateItemTypeUsageBased RateCardUsageBasedUpdateItemType = "usage_based"
)

// Defines values for RecurringPeriodInterval.
const (
	RecurringPeriodIntervalDAY   RecurringPeriodInterval = "DAY"
	RecurringPeriodIntervalMONTH RecurringPeriodInterval = "MONTH"
	RecurringPeriodIntervalWEEK  RecurringPeriodInterval = "WEEK"
	RecurringPeriodIntervalYEAR  RecurringPeriodInterval = "YEAR"
)

// Defines values for RemovePhaseShifting.
const (
	RemovePhaseShiftingNext RemovePhaseShifting = "Next"
	RemovePhaseShiftingPrev RemovePhaseShifting = "Prev"
)

// Defines values for SandboxAppType.
const (
	SandboxAppTypeSandbox SandboxAppType = "sandbox"
)

// Defines values for SortOrder.
const (
	SortOrderASC  SortOrder = "ASC"
	SortOrderDESC SortOrder = "DESC"
)

// Defines values for StripeAppType.
const (
	StripeAppTypeStripe StripeAppType = "stripe"
)

// Defines values for StripeCheckoutSessionMode.
const (
	StripeCheckoutSessionModeSetup StripeCheckoutSessionMode = "setup"
)

// Defines values for StripePaymentIntentStatus.
const (
	StripePaymentIntentStatusCanceled              StripePaymentIntentStatus = "canceled"
	StripePaymentIntentStatusProcessing            StripePaymentIntentStatus = "processing"
	StripePaymentIntentStatusRequiresAction        StripePaymentIntentStatus = "requires_action"
	StripePaymentIntentStatusRequiresConfirmation  StripePaymentIntentStatus = "requires_confirmation"
	StripePaymentIntentStatusRequiresPaymentMethod StripePaymentIntentStatus = "requires_payment_method"
	StripePaymentIntentStatusSucceeded             StripePaymentIntentStatus = "succeeded"
)

// Defines values for SubscriptionEditAddOp.
const (
	SubscriptionEditAddOpAdd SubscriptionEditAddOp = "add"
)

// Defines values for SubscriptionEditAddItemOp.
const (
	SubscriptionEditAddItemOpAdd SubscriptionEditAddItemOp = "add"
)

// Defines values for SubscriptionEditAddUpdateItemOp.
const (
	SubscriptionEditAddUpdateItemOpAdd SubscriptionEditAddUpdateItemOp = "add"
)

// Defines values for SubscriptionEditExtendOp.
const (
	SubscriptionEditExtendOpExtend SubscriptionEditExtendOp = "extend"
)

// Defines values for SubscriptionEditRemoveItemOp.
const (
	SubscriptionEditRemoveItemOpRemove SubscriptionEditRemoveItemOp = "remove"
)

// Defines values for SubscriptionEditRemoveUpdateItemOp.
const (
	SubscriptionEditRemoveUpdateItemOpRemove SubscriptionEditRemoveUpdateItemOp = "remove"
)

// Defines values for SubscriptionEditRemoveWithValueOp.
const (
	SubscriptionEditRemoveWithValueOpRemove SubscriptionEditRemoveWithValueOp = "remove"
)

// Defines values for SvixOperationalWebhookRequestType.
const (
	SvixOperationalWebhookRequestTypeEndpointCreated         SvixOperationalWebhookRequestType = "endpoint.created"
	SvixOperationalWebhookRequestTypeEndpointDeleted         SvixOperationalWebhookRequestType = "endpoint.deleted"
	SvixOperationalWebhookRequestTypeEndpointDisabled        SvixOperationalWebhookRequestType = "endpoint.disabled"
	SvixOperationalWebhookRequestTypeEndpointUpdated         SvixOperationalWebhookRequestType = "endpoint.updated"
	SvixOperationalWebhookRequestTypeMessageAttemptExhausted SvixOperationalWebhookRequestType = "message.attempt.exhausted"
	SvixOperationalWebhookRequestTypeMessageAttemptFailing   SvixOperationalWebhookRequestType = "message.attempt.failing"
	SvixOperationalWebhookRequestTypeMessageAttemptRecovered SvixOperationalWebhookRequestType = "message.attempt.recovered"
)

// Defines values for TieredPriceMode.
const (
	TieredPriceModeGraduated TieredPriceMode = "graduated"
	TieredPriceModeVolume    TieredPriceMode = "volume"
)

// Defines values for TieredPriceWithCommitmentsType.
const (
	TieredPriceWithCommitmentsTypeTiered TieredPriceWithCommitmentsType = "tiered"
)

// Defines values for UnitPriceType.
const (
	UnitPriceTypeUnit UnitPriceType = "unit"
)

// Defines values for UnitPriceWithCommitmentsType.
const (
	UnitPriceWithCommitmentsTypeUnit UnitPriceWithCommitmentsType = "unit"
)

// Defines values for GetSubscriptionParamsExpand.
const (
	GetSubscriptionParamsExpandFalse GetSubscriptionParamsExpand = false
	GetSubscriptionParamsExpandTrue  GetSubscriptionParamsExpand = true
)

// Address Address
type Address struct {
	City *string `json:"city,omitempty"`

	// Country [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.
	// Custom two-letter country codes are also supported for convenience.
	Country     *CountryCode `json:"country,omitempty"`
	Line1       *string      `json:"line1,omitempty"`
	Line2       *string      `json:"line2,omitempty"`
	PhoneNumber *string      `json:"phoneNumber,omitempty"`
	PostalCode  *string      `json:"postalCode,omitempty"`
	State       *string      `json:"state,omitempty"`
}

// Annotations Set of key-value pairs managed by the system. Cannot be modified by user.
type Annotations map[string]interface{}

// App App.
// One of: stripe
type App struct {
	union json.RawMessage
}

// AppBase Abstract base model for installed apps.
//
// Represent an app installed to the organization.
// This is an actual instance, with its own configuration and credentials.
type AppBase struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Listing The marketplace listing that this installed app is based on.
	Listing MarketplaceListing `json:"listing"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Status Status of the app connection.
	Status AppStatus `json:"status"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// AppCapability App capability.
//
// Capabilities only exist in config so they don't extend the Resource model.
type AppCapability struct {
	// Description The capability description.
	Description string `json:"description"`

	// Key Key
	Key string `json:"key"`

	// Name The capability name.
	Name string `json:"name"`

	// Type The capability type.
	Type AppCapabilityType `json:"type"`
}

// AppCapabilityType App capability type.
type AppCapabilityType string

// AppList A page of results.
type AppList struct {
	// Items The items in the page.
	Items []App `json:"items"`

	// Page The page number.
	Page int `json:"page"`

	// PageSize The number of items in the page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// AppReference App reference
//
// Can be used as a short reference to an app if the full app object is not needed.
type AppReference struct {
	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id string `json:"id"`
}

// AppStatus App installed status.
type AppStatus string

// AppType Type of the app.
type AppType string

// BadRequestProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type BadRequestProblemResponse = UnexpectedProblemResponse

// BalanceHistoryWindow The balance history window.
type BalanceHistoryWindow struct {
	// BalanceAtStart The entitlement balance at the start of the period.
	BalanceAtStart float64 `json:"balanceAtStart"`

	// Period A period with a start and end time.
	Period Period `json:"period"`

	// Usage The total usage of the feature in the period.
	Usage float64 `json:"usage"`
}

// BillingCreateLineResult Response for creating a pending charge
type BillingCreateLineResult struct {
	Lines []BillingInvoiceLine `json:"lines"`
}

// BillingCreateLinesRequest CreateLinesRequest is the request for creating manual line items.
type BillingCreateLinesRequest struct {
	Lines []BillingInvoiceLineCreateItem `json:"lines"`
}

// BillingCreditNoteOriginalInvoiceRef Omitted fields:
// period: Tax period in which the referred document had an effect required by some tax regimes and formats.
// stamps: Seals of approval from other organisations that may need to be listed.
// ext: 	Extensions for additional codes that may be required.
type BillingCreditNoteOriginalInvoiceRef = BillingGenericDocumentRef

// BillingCustomerOverride Customer specific workflow overrides.
type BillingCustomerOverride struct {
	// BillingProfile The billing profile this override is associated with.
	//
	// If not provided, the default billing profile is chosen if available.
	BillingProfile *string `json:"billingProfile,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// Workflow Customer specific workflow overrides.
	Workflow BillingCustomerWorkflowOverride `json:"workflow"`
}

// BillingCustomerOverrideOrderBy Order by options for customers.
type BillingCustomerOverrideOrderBy string

// BillingCustomerWorkflowOverride Customer specific workflow overrides.
type BillingCustomerWorkflowOverride struct {
	Collection *BillingWorkflowCollectionSettings `json:"collection,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Id A unique identifier for the resource.
	Id        string                            `json:"id"`
	Invoicing *BillingWorkflowInvoicingSettings `json:"invoicing,omitempty"`

	// InvoicingApp App.
	// One of: stripe
	InvoicingApp App                             `json:"invoicingApp"`
	Payment      *BillingWorkflowPaymentSettings `json:"payment,omitempty"`

	// PaymentApp App.
	// One of: stripe
	PaymentApp App `json:"paymentApp"`

	// TaxApp App.
	// One of: stripe
	TaxApp App `json:"taxApp"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// BillingCustomerWorkflowOverrideCreate Customer specific workflow overrides.
type BillingCustomerWorkflowOverrideCreate struct {
	Collection *BillingWorkflowCollectionSettings `json:"collection,omitempty"`
	Invoicing  *BillingWorkflowInvoicingSettings  `json:"invoicing,omitempty"`
	Payment    *BillingWorkflowPaymentSettings    `json:"payment,omitempty"`
}

// BillingDocumentRef CreditNoteOriginalInvoiceRef is used to reference the original invoice that a credit note is based on.
type BillingDocumentRef = BillingCreditNoteOriginalInvoiceRef

// BillingDocumentRefType DocumentRefType defines the type of document that is being referenced.
type BillingDocumentRefType string

// BillingDueDate DueDate contains an amount that should be paid by the given date.
type BillingDueDate struct {
	Amount   Numeric       `json:"amount"`
	Currency *CurrencyCode `json:"currency,omitempty"`

	// DueAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	DueAt   time.Time   `json:"dueAt"`
	Notes   *string     `json:"notes,omitempty"`
	Percent *Percentage `json:"percent,omitempty"`
}

// BillingFlatFeeLine BillingFlatFeeLine represents a line item that is sold to the customer as a manually added fee.
type BillingFlatFeeLine struct {
	Amount  Numeric              `json:"amount"`
	Charges *[]BillingLineCharge `json:"charges,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time    `json:"createdAt"`
	Currency  CurrencyCode `json:"currency"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string                `json:"description,omitempty"`
	Discounts   *[]BillingLineDiscount `json:"discounts,omitempty"`

	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id      string                   `json:"id"`
	Invoice *BillingInvoiceReference `json:"invoice,omitempty"`

	// InvoiceAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name        string            `json:"name"`
	PaymentTerm *PricePaymentTerm `json:"paymentTerm,omitempty"`
	Period      BillingPeriod     `json:"period"`
	Quantity    Numeric           `json:"quantity"`

	// Status Line status specifies the status of the line.
	Status    BillingLineStatus      `json:"status"`
	TaxConfig *TaxConfig             `json:"taxConfig"`
	Taxes     *[]BillingTaxItem      `json:"taxes,omitempty"`
	Total     Numeric                `json:"total"`
	Type      BillingFlatFeeLineType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// BillingFlatFeeLineType defines model for BillingFlatFeeLine.Type.
type BillingFlatFeeLineType string

// BillingFlatFeeLineCreateItem BillingFlatFeeLine represents a line item that is sold to the customer as a manually added fee.
type BillingFlatFeeLineCreateItem struct {
	Amount   Numeric              `json:"amount"`
	Charges  *[]BillingLineCharge `json:"charges,omitempty"`
	Currency CurrencyCode         `json:"currency"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string                  `json:"description,omitempty"`
	Discounts   *[]BillingLineDiscount   `json:"discounts,omitempty"`
	Invoice     *BillingInvoiceReference `json:"invoice,omitempty"`

	// InvoiceAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name        string                           `json:"name"`
	PaymentTerm *PricePaymentTerm                `json:"paymentTerm,omitempty"`
	Period      BillingPeriod                    `json:"period"`
	Quantity    Numeric                          `json:"quantity"`
	TaxConfig   *TaxConfig                       `json:"taxConfig"`
	Type        BillingFlatFeeLineCreateItemType `json:"type"`
}

// BillingFlatFeeLineCreateItemType defines model for BillingFlatFeeLineCreateItem.Type.
type BillingFlatFeeLineCreateItemType string

// BillingFlatFeeLineCreateOrUpdate BillingFlatFeeLine represents a line item that is sold to the customer as a manually added fee.
type BillingFlatFeeLineCreateOrUpdate struct {
	Amount   Numeric              `json:"amount"`
	Charges  *[]BillingLineCharge `json:"charges,omitempty"`
	Currency CurrencyCode         `json:"currency"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string                `json:"description,omitempty"`
	Discounts   *[]BillingLineDiscount `json:"discounts,omitempty"`

	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id      string                   `json:"id"`
	Invoice *BillingInvoiceReference `json:"invoice,omitempty"`

	// InvoiceAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name        string                               `json:"name"`
	PaymentTerm *PricePaymentTerm                    `json:"paymentTerm,omitempty"`
	Period      BillingPeriod                        `json:"period"`
	Quantity    Numeric                              `json:"quantity"`
	TaxConfig   *TaxConfig                           `json:"taxConfig"`
	Type        BillingFlatFeeLineCreateOrUpdateType `json:"type"`
}

// BillingFlatFeeLineCreateOrUpdateType defines model for BillingFlatFeeLineCreateOrUpdate.Type.
type BillingFlatFeeLineCreateOrUpdateType string

// BillingGenericDocumentRef Omitted fields:
// period: Tax period in which the referred document had an effect required by some tax regimes and formats.
// stamps: Seals of approval from other organisations that may need to be listed.
// ext: 	Extensions for additional codes that may be required.
type BillingGenericDocumentRef struct {
	Description *string                `json:"description,omitempty"`
	Reason      *string                `json:"reason,omitempty"`
	Type        BillingDocumentRefType `json:"type"`
}

// BillingInvoice Invoice represents an invoice in the system.
type BillingInvoice struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time    `json:"createdAt"`
	Currency  CurrencyCode `json:"currency"`
	Customer  BillingParty `json:"customer"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string                   `json:"description,omitempty"`
	Discounts   *[]BillingInvoiceDiscount `json:"discounts,omitempty"`

	// DraftUntil The time until the invoice is in draft status.
	//
	// On draft invoice creation it is calculated from the workflow settings.
	//
	// If manual approval is required, the draftUntil time is set.
	DraftUntil *time.Time `json:"draftUntil,omitempty"`

	// DueAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	DueAt *time.Time `json:"dueAt,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// IssuedAt The time the invoice was issued.
	//
	// Depending on the status of the invoice this can mean multiple things:
	// - draft, gathering: The time the invoice will be issued based on the workflow settings.
	// - issued: The time the invoice was issued.
	IssuedAt *time.Time            `json:"issuedAt,omitempty"`
	Lines    *[]BillingInvoiceLine `json:"lines,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Number Number specifies the human readable key used to reference this Invoice.
	//
	// The number only gets populated after the invoice had been issued.
	//
	// Please note that the number is (depending on the upstream settings) either unique for the
	// whole organization or unique for the customer, or in multi (stripe) account setups unique for the
	// account.
	Number        *BillingInvoiceNumber       `json:"number,omitempty"`
	Payment       *BillingInvoicePayment      `json:"payment,omitempty"`
	Period        *BillingPeriod              `json:"period,omitempty"`
	Preceding     *[]BillingDocumentRef       `json:"preceding,omitempty"`
	Status        BillingInvoiceStatus        `json:"status"`
	StatusDetails BillingInvoiceStatusDetails `json:"statusDetails"`
	Supplier      BillingParty                `json:"supplier"`
	Totals        BillingInvoiceTotals        `json:"totals"`

	// Type InvoiceType represents the type of invoice.
	//
	// The type of invoice determines the purpose of the invoice and how it should be handled.
	Type BillingInvoiceType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	//
	// For updates the updatedAt field is used to detect conflicts.
	UpdatedAt        time.Time                 `json:"updatedAt"`
	ValidationIssues *[]BillingValidationIssue `json:"validationIssues,omitempty"`

	// VoidedAt The time the invoice was voided.
	//
	// If the invoice was voided, this field will be set to the time the invoice was voided.
	VoidedAt *time.Time `json:"voidedAt,omitempty"`

	// Workflow The workflow associated with the invoice.
	//
	// It is always a snapshot of the workflow settings at the time of invoice creation. The
	// field is optional as it should be explicitly requested with expand options.
	Workflow *BillingInvoiceWorkflowSettings `json:"workflow,omitempty"`
}

// BillingInvoiceAction BillingInvoiceAction represents the actions that can be performed on an invoice.
type BillingInvoiceAction string

// BillingInvoiceCreateInput BillingInvoiceCreateInput is the input for creating an invoice.
//
// Invoice creation is always based on already pending line items created by the billingCreateLineByCustomer
// operation. Empty invoices are not allowed.
type BillingInvoiceCreateInput struct {
	// AsOf The time as of which the invoice is created.
	//
	// If not provided, the current time is used.
	AsOf *time.Time `json:"AsOf,omitempty"`

	// IncludePendingLines The pending line items to include in the invoice, if not provided:
	// - all line items that have invoice_at < asOf will be included
	// - all usage based line items will be included up to asOf, new usage-based line items will be staged for the rest
	// of the billing cycle
	IncludePendingLines *[]string `json:"IncludePendingLines,omitempty"`
}

// BillingInvoiceDiscount Discount represents an allowance applied to the complete document independent from the individual lines.
type BillingInvoiceDiscount struct {
	Amount  Numeric     `json:"amount"`
	Base    *Numeric    `json:"base,omitempty"`
	Percent *Percentage `json:"percent,omitempty"`
	Reason  *string     `json:"reason,omitempty"`
}

// BillingInvoiceExpand InvoiceExpand specifies the parts of the invoice to expand in the list output.
type BillingInvoiceExpand string

// BillingInvoiceExtendedStatus InvoiceExtendedStatus describes the extended status of an invoice.
//
// This is used to provide more detailed information about the status of the invoice. Useful for
// troubelshooting invoice workflow issues.
type BillingInvoiceExtendedStatus string

// BillingInvoiceLine BillingInvoiceLine represents a line item that is sold to the customer based on a specific (unit) price.
type BillingInvoiceLine struct {
	union json.RawMessage
}

// BillingInvoiceLineCreateItem BillingInvoiceLine represents a line item that is sold to the customer based on a specific (unit) price.
type BillingInvoiceLineCreateItem struct {
	union json.RawMessage
}

// BillingInvoiceLineCreateOrUpdate BillingInvoiceLine represents a line item that is sold to the customer based on a specific (unit) price.
type BillingInvoiceLineCreateOrUpdate struct {
	union json.RawMessage
}

// BillingInvoiceNumber InvoiceNumber is a unique identifier for the invoice, generated by the
// invoicing app.
//
// The uniqueness depends on a lot of factors:
// - app setting (unique per app or unique per customer)
// - multiple app scenarios (multiple apps generating invoices with the same prefix)
type BillingInvoiceNumber = string

// BillingInvoiceOrderBy InvoiceOrderBy specifies the ordering options for invoice listing.
type BillingInvoiceOrderBy string

// BillingInvoicePayment Payment contains details as to how the invoice should be paid.
type BillingInvoicePayment struct {
	// Terms PaymentTerms defines the terms for payment.
	Terms *BillingPaymentTerms `json:"terms,omitempty"`
}

// BillingInvoiceReference Reference to an invoice.
type BillingInvoiceReference struct {
	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id     string                `json:"id"`
	Number *BillingInvoiceNumber `json:"number,omitempty"`
}

// BillingInvoiceStatus InvoiceStatus describes the status of an invoice.
type BillingInvoiceStatus string

// BillingInvoiceStatusDetails InvoiceStatusDetails represents the details of the invoice status.
//
// API users are encouraged to rely on the immutable/failed/avaliableActions fields to determine
// the next steps of the invoice instead of the extendedStatus field.
type BillingInvoiceStatusDetails struct {
	AvailableActions []BillingInvoiceAction       `json:"availableActions"`
	ExtendedStatus   BillingInvoiceExtendedStatus `json:"extendedStatus"`
	Failed           bool                         `json:"failed"`
	Immutable        bool                         `json:"immutable"`
}

// BillingInvoiceTotals Totals contains the summaries of all calculations for the invoice.
type BillingInvoiceTotals struct {
	Advance      *Numeric `json:"advance,omitempty"`
	Charge       *Numeric `json:"charge,omitempty"`
	Discount     *Numeric `json:"discount,omitempty"`
	Due          *Numeric `json:"due,omitempty"`
	Payable      Numeric  `json:"payable"`
	Rounding     *Numeric `json:"rounding,omitempty"`
	Sum          Numeric  `json:"sum"`
	Tax          *Numeric `json:"tax,omitempty"`
	TaxIncluded  *Numeric `json:"taxIncluded,omitempty"`
	Total        Numeric  `json:"total"`
	TotalWithTax Numeric  `json:"totalWithTax"`
}

// BillingInvoiceType InvoiceType represents the type of invoice.
//
// The type of invoice determines the purpose of the invoice and how it should be handled.
type BillingInvoiceType string

// BillingInvoiceWorkflowSettings InvoiceWorkflowSettings represents the workflow settings used by the invoice.
//
// This is a clone of the billing profile's workflow settings at the time of invoice creation
// with customer overrides considered.
type BillingInvoiceWorkflowSettings struct {
	Apps *BillingProfileAppsOrReference `json:"apps,omitempty"`

	// SourceBillingProfileID sourceBillingProfileID is the billing profile on which the workflow was based on.
	//
	// The profile is snapshotted on invoice creation, after which it can be altered independently
	// of the profile itself.
	SourceBillingProfileID string                  `json:"sourceBillingProfileID"`
	Timezone               string                  `json:"timezone"`
	Workflow               BillingWorkflowSettings `json:"workflow"`
}

// BillingLineCharge LineCharge represents an amount added to the line, and will be applied before taxes.
type BillingLineCharge struct {
	// Amount Fixed discount amount to apply (calculated if percent present).
	Amount Numeric `json:"amount"`
	Code   *string `json:"code,omitempty"`

	// Percent Percentage if fixed amount not applied
	Percent *Percentage `json:"percent,omitempty"`
	Reason  *string     `json:"reason,omitempty"`
}

// BillingLineDiscount LineDiscount represents an amount deducted from the line, and will be applied before taxes.
type BillingLineDiscount struct {
	// Amount Fixed discount amount to apply (calculated if percent present).
	Amount Numeric `json:"amount"`
	Code   *string `json:"code,omitempty"`

	// Percent Percentage if fixed amount not applied
	Percent *Percentage `json:"percent,omitempty"`
	Reason  *string     `json:"reason,omitempty"`
}

// BillingLineStatus Line status specifies the status of the line.
type BillingLineStatus string

// BillingParty Party represents a person or business entity.
type BillingParty struct {
	Addresses *[]Address `json:"addresses,omitempty"`

	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id    *string             `json:"id,omitempty"`
	Name  *string             `json:"name,omitempty"`
	TaxId *BillingTaxIdentity `json:"taxId,omitempty"`
}

// BillingPartyCreate Party represents a person or business entity.
type BillingPartyCreate struct {
	Addresses *[]Address          `json:"addresses,omitempty"`
	Name      *string             `json:"name,omitempty"`
	TaxId     *BillingTaxIdentity `json:"taxId,omitempty"`
}

// BillingPaymentTermDueDate PaymentTermDueDate defines the terms for payment on a specific date.
type BillingPaymentTermDueDate struct {
	Detail *string                       `json:"detail,omitempty"`
	DueAt  []BillingDueDate              `json:"dueAt"`
	Notes  *string                       `json:"notes,omitempty"`
	Type   BillingPaymentTermDueDateType `json:"type"`
}

// BillingPaymentTermDueDateType defines model for BillingPaymentTermDueDate.Type.
type BillingPaymentTermDueDateType string

// BillingPaymentTermInstant PaymentTermInstant defines the terms for payment on receipt of invoice.
type BillingPaymentTermInstant struct {
	Detail *string                       `json:"detail,omitempty"`
	Notes  *string                       `json:"notes,omitempty"`
	Type   BillingPaymentTermInstantType `json:"type"`
}

// BillingPaymentTermInstantType defines model for BillingPaymentTermInstant.Type.
type BillingPaymentTermInstantType string

// BillingPaymentTerms PaymentTerms defines the terms for payment.
type BillingPaymentTerms struct {
	union json.RawMessage
}

// BillingPeriod Period represents a time range.
//
// Billing always treats periods as start being inclusive and end being exclusive.
type BillingPeriod struct {
	// End [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	End time.Time `json:"end"`

	// Start [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	Start time.Time `json:"start"`
}

// BillingProfile Profile represents a billing profile
type BillingProfile struct {
	Apps BillingProfileAppsOrReference `json:"apps"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`
	Default   bool      `json:"default"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name     string       `json:"name"`
	Supplier BillingParty `json:"supplier"`

	// UpdatedAt When the resource was last updated.
	//
	// For updates this field must be set to the last update time to detect conflicts.
	UpdatedAt time.Time       `json:"updatedAt"`
	Workflow  BillingWorkflow `json:"workflow"`
}

// BillingProfileAppReferences ProfileAppsReference represents the references (id, type) to the apps used by a billing profile
type BillingProfileAppReferences struct {
	Invoicing AppReference `json:"invoicing"`
	Payment   AppReference `json:"payment"`
	Tax       AppReference `json:"tax"`
}

// BillingProfileApps ProfileApps represents the applications used by a billing profile
type BillingProfileApps struct {
	// Invoicing App.
	// One of: stripe
	Invoicing App `json:"invoicing"`

	// Payment App.
	// One of: stripe
	Payment App `json:"payment"`

	// Tax App.
	// One of: stripe
	Tax App `json:"tax"`
}

// BillingProfileAppsOrReference ProfileAppsOrReference represents the union of ProfileApps and ProfileAppReferences
// for a billing profile.
type BillingProfileAppsOrReference struct {
	union json.RawMessage
}

// BillingProfileCreateAppsInput ProfileCreateAppsInput represents the input for creating a billing profile's apps
type BillingProfileCreateAppsInput struct {
	Invoicing BillingWorkflowAppIdOrType `json:"invoicing"`
	Payment   BillingWorkflowAppIdOrType `json:"payment"`
	Tax       BillingWorkflowAppIdOrType `json:"tax"`
}

// BillingProfileCreateInput ProfileCreateInput represents the input for creating a billing profile
type BillingProfileCreateInput struct {
	// Apps ProfileCreateAppsInput represents the input for creating a billing profile's apps
	Apps    BillingProfileCreateAppsInput `json:"apps"`
	Default bool                          `json:"default"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name     string             `json:"name"`
	Supplier BillingPartyCreate `json:"supplier"`
	Workflow BillingWorkflow    `json:"workflow"`
}

// BillingProfileCreateOrUpdate Profile represents a billing profile
type BillingProfileCreateOrUpdate struct {
	Default bool `json:"default"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name     string       `json:"name"`
	Supplier BillingParty `json:"supplier"`

	// UpdatedAt When the resource was last updated.
	//
	// For updates this field must be set to the last update time to detect conflicts.
	UpdatedAt time.Time       `json:"updatedAt"`
	Workflow  BillingWorkflow `json:"workflow"`
}

// BillingProfileExpand ProfileExpand details what profile fields to expand
type BillingProfileExpand string

// BillingProfileOrderBy ProfileOrderBy specifies the ordering options for profiles
type BillingProfileOrderBy string

// BillingTaxBehavior TaxBehavior details how the tax item is applied to the base amount.
//
// Inclusive means the tax is included in the base amount.
// Exclusive means the tax is added to the base amount.
type BillingTaxBehavior string

// BillingTaxIdentificationCode defines model for BillingTaxIdentificationCode.
type BillingTaxIdentificationCode = string

// BillingTaxIdentity Identity stores the details required to identify an entity for tax purposes in a specific country.
type BillingTaxIdentity struct {
	Code *BillingTaxIdentificationCode `json:"code,omitempty"`
}

// BillingTaxItem TaxConfig stores the configuration for a tax line relative to an invoice line.
type BillingTaxItem struct {
	Behavior  *BillingTaxBehavior `json:"behavior,omitempty"`
	Config    *TaxConfig          `json:"config,omitempty"`
	Percent   *Percentage         `json:"percent,omitempty"`
	Surcharge *Numeric            `json:"surcharge,omitempty"`
}

// BillingUsageBasedLine UsageBasedLine represents a line item that is sold to the customer based on usage.
type BillingUsageBasedLine struct {
	Charges *[]BillingLineCharge `json:"charges,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time    `json:"createdAt"`
	Currency  CurrencyCode `json:"currency"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string                `json:"description,omitempty"`
	Discounts   *[]BillingLineDiscount `json:"discounts,omitempty"`

	// FeatureKey A key is a unique string that is used to identify a resource.
	FeatureKey string `json:"featureKey"`

	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id      string                   `json:"id"`
	Invoice *BillingInvoiceReference `json:"invoice,omitempty"`

	// InvoiceAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name   string        `json:"name"`
	Period BillingPeriod `json:"period"`

	// Price The price of the usage based rate card.
	Price    RateCardUsageBasedPrice `json:"price"`
	Quantity *Numeric                `json:"quantity,omitempty"`

	// Status Line status specifies the status of the line.
	Status    BillingLineStatus         `json:"status"`
	TaxConfig *TaxConfig                `json:"taxConfig"`
	Taxes     *[]BillingTaxItem         `json:"taxes,omitempty"`
	Total     Numeric                   `json:"total"`
	Type      BillingUsageBasedLineType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// BillingUsageBasedLineType defines model for BillingUsageBasedLine.Type.
type BillingUsageBasedLineType string

// BillingUsageBasedLineCreateItem UsageBasedLine represents a line item that is sold to the customer based on usage.
type BillingUsageBasedLineCreateItem struct {
	Charges  *[]BillingLineCharge `json:"charges,omitempty"`
	Currency CurrencyCode         `json:"currency"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string                `json:"description,omitempty"`
	Discounts   *[]BillingLineDiscount `json:"discounts,omitempty"`

	// FeatureKey A key is a unique string that is used to identify a resource.
	FeatureKey string                   `json:"featureKey"`
	Invoice    *BillingInvoiceReference `json:"invoice,omitempty"`

	// InvoiceAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name   string        `json:"name"`
	Period BillingPeriod `json:"period"`

	// Price The price of the usage based rate card.
	Price     RateCardUsageBasedPrice             `json:"price"`
	TaxConfig *TaxConfig                          `json:"taxConfig"`
	Type      BillingUsageBasedLineCreateItemType `json:"type"`
}

// BillingUsageBasedLineCreateItemType defines model for BillingUsageBasedLineCreateItem.Type.
type BillingUsageBasedLineCreateItemType string

// BillingUsageBasedLineCreateOrUpdate UsageBasedLine represents a line item that is sold to the customer based on usage.
type BillingUsageBasedLineCreateOrUpdate struct {
	Charges  *[]BillingLineCharge `json:"charges,omitempty"`
	Currency CurrencyCode         `json:"currency"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string                `json:"description,omitempty"`
	Discounts   *[]BillingLineDiscount `json:"discounts,omitempty"`

	// FeatureKey A key is a unique string that is used to identify a resource.
	FeatureKey string `json:"featureKey"`

	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id      string                   `json:"id"`
	Invoice *BillingInvoiceReference `json:"invoice,omitempty"`

	// InvoiceAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	InvoiceAt time.Time `json:"invoiceAt"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name   string        `json:"name"`
	Period BillingPeriod `json:"period"`

	// Price The price of the usage based rate card.
	Price     RateCardUsageBasedPrice                 `json:"price"`
	TaxConfig *TaxConfig                              `json:"taxConfig"`
	Type      BillingUsageBasedLineCreateOrUpdateType `json:"type"`
}

// BillingUsageBasedLineCreateOrUpdateType defines model for BillingUsageBasedLineCreateOrUpdate.Type.
type BillingUsageBasedLineCreateOrUpdateType string

// BillingValidationIssue ValidationIssue captures any validation issues related to the invoice.
//
// Issues with severity "critical" will prevent the invoice from being issued.
type BillingValidationIssue struct {
	Code      *string                        `json:"code,omitempty"`
	Component string                         `json:"component"`
	Field     *string                        `json:"field,omitempty"`
	Message   string                         `json:"message"`
	Metadata  *Metadata                      `json:"metadata,omitempty"`
	Severity  BillingValidationIssueSeverity `json:"severity"`
}

// BillingValidationIssueSeverity ValidationIssueSeverity describes the severity of a validation issue.
//
// Issues with severity "critical" will prevent the invoice from being issued.
type BillingValidationIssueSeverity string

// BillingVoidInvoiceAction InvoiceVoidAction describes how to handle the voided line items.
type BillingVoidInvoiceAction struct {
	Action     BillingVoidInvoiceLineAction `json:"action"`
	Percentage Percentage                   `json:"percentage"`
}

// BillingVoidInvoiceInput Request to void an invoice
type BillingVoidInvoiceInput struct {
	// Action The action to take on the voided line items.
	Action BillingVoidInvoiceAction `json:"action"`

	// Overrides Per line item overrides for the action.
	//
	// If not specified, the `action` will be applied to all line items.
	Overrides *[]BillingVoidInvoiceLineOverride `json:"overrides"`

	// Reason The reason for voiding the invoice.
	Reason string `json:"reason"`
}

// BillingVoidInvoiceLineAction VoidInvoiceLineAction describes how to handle the voidied line item in the invoice.
type BillingVoidInvoiceLineAction string

// BillingVoidInvoiceLineOverride VoidInvoiceLineOverride describes how to handle a specific line item in the invoice when voiding.
type BillingVoidInvoiceLineOverride struct {
	Action BillingVoidInvoiceAction `json:"action"`

	// LineId ULID (Universally Unique Lexicographically Sortable Identifier).
	LineId string `json:"lineId"`
}

// BillingWorkflow Workflow represents a billing workflow
type BillingWorkflow struct {
	Collection *BillingWorkflowCollectionSettings `json:"collection,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Id A unique identifier for the resource.
	Id        string                            `json:"id"`
	Invoicing *BillingWorkflowInvoicingSettings `json:"invoicing,omitempty"`
	Payment   *BillingWorkflowPaymentSettings   `json:"payment,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// BillingWorkflowAppIdOrType AppIdOrType can be used to reference an app during creation only.
//
// This can be either an AppType or the ULID of an app.
type BillingWorkflowAppIdOrType = string

// BillingWorkflowCollectionAlignment CollectionAlignment specifies when the pending line items should be collected into
// an invoice.
type BillingWorkflowCollectionAlignment string

// BillingWorkflowCollectionMethod CollectionMethod specifies how the invoice should be collected (automatic vs manual)
type BillingWorkflowCollectionMethod string

// BillingWorkflowCollectionSettings Workflow collection specifies how to collect the pending line items for an invoice
type BillingWorkflowCollectionSettings struct {
	// Alignment When to collect the pending line items into an invoice.
	Alignment *BillingWorkflowCollectionAlignment `json:"alignment,omitempty"`

	// Interval The interval for collecting the pending line items into an invoice.
	Interval *string `json:"interval,omitempty"`
}

// BillingWorkflowInvoicingSettings WorkflowInvoice represents the invoice settings for a billing workflow
type BillingWorkflowInvoicingSettings struct {
	// AutoAdvance Whether to automatically issue the invoice after the draftPeriod has passed.
	AutoAdvance *bool `json:"autoAdvance,omitempty"`

	// DraftPeriod The period for the invoice to be kept in draft status for manual reviews.
	DraftPeriod *string `json:"draftPeriod,omitempty"`

	// DueAfter The period after which the invoice is due.
	DueAfter *string `json:"dueAfter,omitempty"`
}

// BillingWorkflowPaymentSettings WorkflowPaymentSettings represents the payment settings for a billing workflow
type BillingWorkflowPaymentSettings struct {
	CollectionMethod *BillingWorkflowCollectionMethod `json:"collectionMethod,omitempty"`
}

// BillingWorkflowSettings WorkflowSettings represents the settings for a billing workflow.
type BillingWorkflowSettings struct {
	Collection *BillingWorkflowCollectionSettings `json:"collection,omitempty"`
	Invoicing  *BillingWorkflowInvoicingSettings  `json:"invoicing,omitempty"`
	Payment    *BillingWorkflowPaymentSettings    `json:"payment,omitempty"`
}

// CheckoutSessionCustomTextAfterSubmitParams Stripe CheckoutSession.custom_text
type CheckoutSessionCustomTextAfterSubmitParams struct {
	AfterSubmit *struct {
		Message *string `json:"message,omitempty"`
	} `json:"afterSubmit,omitempty"`
	ShippingAddress *struct {
		Message *string `json:"message,omitempty"`
	} `json:"shippingAddress,omitempty"`
	Submit *struct {
		Message *string `json:"message,omitempty"`
	} `json:"submit,omitempty"`
	TermsOfServiceAcceptance *struct {
		Message *string `json:"message,omitempty"`
	} `json:"termsOfServiceAcceptance,omitempty"`
}

// CheckoutSessionUIMode Stripe CheckoutSession.ui_mode
type CheckoutSessionUIMode string

// ClientAppStartResponse Response from the client app (OpenMeter backend) to start the OAuth2 flow.
type ClientAppStartResponse struct {
	// Url The URL to start the OAuth2 authorization code grant flow.
	Url string `json:"url"`
}

// ConflictProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type ConflictProblemResponse = UnexpectedProblemResponse

// CountryCode [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-2 country code.
// Custom two-letter country codes are also supported for convenience.
type CountryCode = string

// CreateStripeCheckoutSessionRequest Create Stripe checkout session request.
type CreateStripeCheckoutSessionRequest struct {
	// AppId If not provided, the default Stripe app is used if any.
	AppId *string `json:"appId,omitempty"`

	// Customer Provide a customer ID to use an existing OpenMeter customer.
	// or provide a customer object to create a new customer.
	Customer CreateStripeCheckoutSessionRequest_Customer `json:"customer"`

	// Options Options passed to Stripe when creating the checkout session.
	Options CreateStripeCheckoutSessionRequestOptions `json:"options"`

	// StripeCustomerId Stripe customer ID.
	// If not provided OpenMeter creates a new Stripe customer or
	// uses the OpenMeter customer's default Stripe customer ID.
	StripeCustomerId *string `json:"stripeCustomerId,omitempty"`
}

// CreateStripeCheckoutSessionRequest_Customer Provide a customer ID to use an existing OpenMeter customer.
// or provide a customer object to create a new customer.
type CreateStripeCheckoutSessionRequest_Customer struct {
	union json.RawMessage
}

// CreateStripeCheckoutSessionRequestOptions Create Stripe checkout session options
type CreateStripeCheckoutSessionRequestOptions struct {
	CancelURL         *string `json:"cancelURL,omitempty"`
	ClientReferenceID *string `json:"clientReferenceID,omitempty"`

	// Currency Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.
	// Custom three-letter currency codes are also supported for convenience.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// CustomText Stripe CheckoutSession.custom_text
	CustomText         *CheckoutSessionCustomTextAfterSubmitParams `json:"customText,omitempty"`
	Metadata           *map[string]string                          `json:"metadata,omitempty"`
	PaymentMethodTypes *[]string                                   `json:"paymentMethodTypes,omitempty"`
	ReturnURL          *string                                     `json:"returnURL,omitempty"`
	SuccessURL         *string                                     `json:"successURL,omitempty"`

	// UiMode Stripe CheckoutSession.ui_mode
	UiMode *CheckoutSessionUIMode `json:"uiMode,omitempty"`
}

// CreateStripeCheckoutSessionResult Create Stripe Checkout Session response.
type CreateStripeCheckoutSessionResult struct {
	// CancelURL Cancel URL.
	CancelURL *string `json:"cancelURL,omitempty"`

	// CustomerId The OpenMeter customer ID.
	CustomerId string `json:"customerId"`

	// Mode Mode
	// Always `setup` for now.
	Mode StripeCheckoutSessionMode `json:"mode"`

	// ReturnURL Return URL.
	ReturnURL *string `json:"returnURL,omitempty"`

	// SessionId The checkout session ID.
	SessionId string `json:"sessionId"`

	// SetupIntentId The checkout session setup intent ID.
	SetupIntentId string `json:"setupIntentId"`

	// StripeCustomerId The Stripe customer ID.
	StripeCustomerId string `json:"stripeCustomerId"`

	// SuccessURL Success URL.
	SuccessURL *string `json:"successURL,omitempty"`

	// Url URL to show the checkout session.
	Url string `json:"url"`
}

// CreateSubscriptionRequestBody Create subscription request body.
type CreateSubscriptionRequestBody struct {
	// ActiveFrom [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	ActiveFrom time.Time `json:"activeFrom"`

	// Currency Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.
	// Custom three-letter currency codes are also supported for convenience.
	Currency CurrencyCode `json:"currency"`

	// CustomerId ULID (Universally Unique Lexicographically Sortable Identifier).
	CustomerId string `json:"customerId"`

	// Customizations Batch processing commands for customizing the susbcription.
	// The key format is `/phases/{phaseKey}/items/{itemKey}`.
	//
	// Add operations insert a new member based on the creation input without altering the existing members.
	//
	// Remove operations remove the member from the document.
	Customizations []CreateSubscriptionRequestBody_Customizations_Item `json:"customizations"`
	Plan           struct {
		// Key A key is a unique string that is used to identify a resource.
		Key     string `json:"key"`
		Version int    `json:"version"`
	} `json:"plan"`
}

// CreateSubscriptionRequestBody_Customizations_Item defines model for CreateSubscriptionRequestBody.customizations.Item.
type CreateSubscriptionRequestBody_Customizations_Item struct {
	union json.RawMessage
}

// CurrencyCode Three-letter [ISO4217](https://www.iso.org/iso-4217-currency-codes.html) currency code.
// Custom three-letter currency codes are also supported for convenience.
type CurrencyCode = string

// Customer A customer object.
type Customer struct {
	// BillingAddress The billing address of the customer.
	// Used for tax and invoicing.
	BillingAddress *Address `json:"billingAddress,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency Currency of the customer.
	// Used for billing, tax and invoicing.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// External External mappings for the customer.
	External *CustomerExternalMapping `json:"external,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PrimaryEmail The primary email address of the customer.
	PrimaryEmail *string `json:"primaryEmail,omitempty"`

	// Timezone Timezone of the customer.
	Timezone *string `json:"timezone,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// UsageAttribution Mapping to attribute metered usage to the customer
	UsageAttribution CustomerUsageAttribution `json:"usageAttribution"`
}

// CustomerCreate Resource create operation model.
type CustomerCreate struct {
	// BillingAddress The billing address of the customer.
	// Used for tax and invoicing.
	BillingAddress *Address `json:"billingAddress,omitempty"`

	// Currency Currency of the customer.
	// Used for billing, tax and invoicing.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// External External mappings for the customer.
	External *CustomerExternalMapping `json:"external,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PrimaryEmail The primary email address of the customer.
	PrimaryEmail *string `json:"primaryEmail,omitempty"`

	// Timezone Timezone of the customer.
	Timezone *string `json:"timezone,omitempty"`

	// UsageAttribution Mapping to attribute metered usage to the customer
	UsageAttribution CustomerUsageAttribution `json:"usageAttribution"`
}

// CustomerExternalMapping External mappings for the customer.
type CustomerExternalMapping struct {
	// StripeCustomerId The Stripe customer ID.
	// Mapping to a Stripe Customer object.
	// Required to use Stripe as an invocing provider.
	StripeCustomerId *string `json:"stripeCustomerId,omitempty"`
}

// CustomerId Create Stripe checkout session customer ID.
type CustomerId struct {
	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id string `json:"id"`
}

// CustomerOrderBy Order by options for customers.
type CustomerOrderBy string

// CustomerOverridePaginatedResponse Paginated response
type CustomerOverridePaginatedResponse struct {
	// Items The items in the current page.
	Items []BillingCustomerOverride `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// CustomerPaginatedResponse Paginated response
type CustomerPaginatedResponse struct {
	// Items The items in the current page.
	Items []Customer `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// CustomerReplaceUpdate Resource update operation model.
type CustomerReplaceUpdate struct {
	// BillingAddress The billing address of the customer.
	// Used for tax and invoicing.
	BillingAddress *Address `json:"billingAddress,omitempty"`

	// Currency Currency of the customer.
	// Used for billing, tax and invoicing.
	Currency *CurrencyCode `json:"currency,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// External External mappings for the customer.
	External *CustomerExternalMapping `json:"external,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// PrimaryEmail The primary email address of the customer.
	PrimaryEmail *string `json:"primaryEmail,omitempty"`

	// Timezone Timezone of the customer.
	Timezone *string `json:"timezone,omitempty"`

	// UsageAttribution Mapping to attribute metered usage to the customer
	UsageAttribution CustomerUsageAttribution `json:"usageAttribution"`
}

// CustomerUsageAttribution Mapping to attribute metered usage to the customer.
// One customer can have multiple subjects,
// but one subject can only belong to one customer.
type CustomerUsageAttribution struct {
	// SubjectKeys The subjects that are attributed to the customer.
	SubjectKeys []string `json:"subjectKeys"`
}

// Discount Percentage discount.
type Discount = DiscountPercentage

// DiscountPercentage Percentage discount.
type DiscountPercentage struct {
	// Percentage The percentage of the discount.
	Percentage float32 `json:"percentage"`

	// RateCards The rate cards that the discount applies to.
	// When not specified, the discount applies to all rate cards.
	RateCards *[]string `json:"rateCards,omitempty"`

	// Type The type of the discount.
	Type DiscountPercentageType `json:"type"`
}

// DiscountPercentageType The type of the discount.
type DiscountPercentageType string

// DiscountPercentageUpdateItem Percentage discount.
type DiscountPercentageUpdateItem struct {
	// Percentage The percentage of the discount.
	Percentage float32 `json:"percentage"`

	// RateCards The rate cards that the discount applies to.
	// When not specified, the discount applies to all rate cards.
	RateCards *[]string `json:"rateCards,omitempty"`
}

// DiscountUpdateItem Percentage discount.
type DiscountUpdateItem = DiscountPercentageUpdateItem

// Entitlement Entitlement templates are used to define the entitlements of a plan.
// Features are omitted from the entitlement template, as they are defined in the rate card.
type Entitlement struct {
	union json.RawMessage
}

// EntitlementBaseTemplate Shared fields of the entitlement templates.
type EntitlementBaseTemplate struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// CurrentUsagePeriod The current usage period.
	CurrentUsagePeriod *Period `json:"currentUsagePeriod,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id string `json:"id"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string `json:"subjectKey"`

	// Type The type of the entitlement.
	Type EntitlementType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// UsagePeriod The defined usage period of the entitlement
	UsagePeriod *RecurringPeriod `json:"usagePeriod,omitempty"`
}

// EntitlementBoolean Shared fields of the entitlement templates.
type EntitlementBoolean = EntitlementBaseTemplate

// EntitlementBooleanCreateInputs Create inputs for boolean entitlement
type EntitlementBooleanCreateInputs struct {
	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata                          `json:"metadata,omitempty"`
	Type     EntitlementBooleanCreateInputsType `json:"type"`

	// UsagePeriod The usage period associated with the entitlement.
	UsagePeriod *RecurringPeriodCreateInput `json:"usagePeriod,omitempty"`
}

// EntitlementBooleanCreateInputsType defines model for EntitlementBooleanCreateInputs.Type.
type EntitlementBooleanCreateInputsType string

// EntitlementCreateInputs Create inputs for entitlement
type EntitlementCreateInputs struct {
	union json.RawMessage
}

// EntitlementGrant The grant.
type EntitlementGrant struct {
	// Amount The amount to grant. Should be a positive number.
	Amount float64 `json:"amount"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// EffectiveAt Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
	EffectiveAt time.Time `json:"effectiveAt"`

	// EntitlementId The unique entitlement ULID that the grant is associated with.
	EntitlementId string `json:"entitlementId"`

	// Expiration The grant expiration definition
	Expiration ExpirationPeriod `json:"expiration"`

	// ExpiresAt The time the grant expires.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Id Readonly unique ULID identifier.
	Id string `json:"id"`

	// MaxRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MaxRolloverAmount *float64 `json:"maxRolloverAmount,omitempty"`

	// Metadata The grant metadata.
	Metadata *Metadata `json:"metadata,omitempty"`

	// MinRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MinRolloverAmount *float64 `json:"minRolloverAmount,omitempty"`

	// NextRecurrence The next time the grant will recurr.
	NextRecurrence *time.Time `json:"nextRecurrence,omitempty"`

	// Priority The priority of the grant. Grants with higher priority are applied first.
	// Priority is a positive decimal numbers. With lower numbers indicating higher importance.
	// For example, a priority of 1 is more urgent than a priority of 2.
	// When there are several grants available for the same subject, the system selects the grant with the highest priority.
	// In cases where grants share the same priority level, the grant closest to its expiration will be used first.
	// In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
	Priority *uint8 `json:"priority,omitempty"`

	// Recurrence The recurrence period of the grant.
	Recurrence *RecurringPeriod `json:"recurrence,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// VoidedAt The time the grant was voided.
	VoidedAt *time.Time `json:"voidedAt,omitempty"`
}

// EntitlementGrantCreateInput The grant creation input.
type EntitlementGrantCreateInput struct {
	// Amount The amount to grant. Should be a positive number.
	Amount float64 `json:"amount"`

	// EffectiveAt Effective date for grants and anchor for recurring grants. Provided value will be ceiled to metering windowSize (minute).
	EffectiveAt time.Time `json:"effectiveAt"`

	// Expiration The grant expiration definition
	Expiration ExpirationPeriod `json:"expiration"`

	// MaxRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MaxRolloverAmount *float64 `json:"maxRolloverAmount,omitempty"`

	// Metadata The grant metadata.
	Metadata *Metadata `json:"metadata,omitempty"`

	// MinRolloverAmount Grants are rolled over at reset, after which they can have a different balance compared to what they had before the reset.
	// Balance after the reset is calculated as: Balance_After_Reset = MIN(MaxRolloverAmount, MAX(Balance_Before_Reset, MinRolloverAmount))
	MinRolloverAmount *float64 `json:"minRolloverAmount,omitempty"`

	// Priority The priority of the grant. Grants with higher priority are applied first.
	// Priority is a positive decimal numbers. With lower numbers indicating higher importance.
	// For example, a priority of 1 is more urgent than a priority of 2.
	// When there are several grants available for the same subject, the system selects the grant with the highest priority.
	// In cases where grants share the same priority level, the grant closest to its expiration will be used first.
	// In the case of two grants have identical priorities and expiration dates, the system will use the grant that was created first.
	Priority *uint8 `json:"priority,omitempty"`

	// Recurrence The subject of the grant.
	Recurrence *RecurringPeriodCreateInput `json:"recurrence,omitempty"`
}

// EntitlementMetered Metered entitlements are useful for many different use cases, from setting up usage based access to implementing complex credit systems.
// Access is determined based on feature usage using a balance calculation (the "usage allowance" provided by the issued grants is "burnt down" by the usage).
type EntitlementMetered struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// CurrentUsagePeriod The current usage period.
	CurrentUsagePeriod Period `json:"currentUsagePeriod"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id string `json:"id"`

	// IsSoftLimit If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
	IsSoftLimit *bool `json:"isSoftLimit,omitempty"`

	// IsUnlimited Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
	// Deprecated:
	IsUnlimited *bool `json:"isUnlimited,omitempty"`

	// IssueAfterReset You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
	// If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
	// That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
	// Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
	IssueAfterReset *float64 `json:"issueAfterReset,omitempty"`

	// IssueAfterResetPriority Defines the grant priority for the default grant.
	IssueAfterResetPriority *uint8 `json:"issueAfterResetPriority,omitempty"`

	// LastReset The time the last reset happened.
	LastReset time.Time `json:"lastReset"`

	// MeasureUsageFrom The time from which usage is measured. If not specified on creation, defaults to entitlement creation time.
	MeasureUsageFrom time.Time `json:"measureUsageFrom"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// PreserveOverageAtReset If true, the overage is preserved at reset. If false, the usage is reset to 0.
	PreserveOverageAtReset *bool `json:"preserveOverageAtReset,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string                 `json:"subjectKey"`
	Type       EntitlementMeteredType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// UsagePeriod THe usage period of the entitlement.
	UsagePeriod RecurringPeriod `json:"usagePeriod"`
}

// EntitlementMeteredType defines model for EntitlementMetered.Type.
type EntitlementMeteredType string

// EntitlementMeteredCreateInputs Create inpurs for metered entitlement
type EntitlementMeteredCreateInputs struct {
	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// IsSoftLimit If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
	IsSoftLimit *bool `json:"isSoftLimit,omitempty"`

	// IsUnlimited Deprecated, ignored by the backend. Please use isSoftLimit instead; this field will be removed in the future.
	// Deprecated:
	IsUnlimited *bool `json:"isUnlimited,omitempty"`

	// IssueAfterReset You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
	// If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
	// That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
	// Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
	IssueAfterReset *float64 `json:"issueAfterReset,omitempty"`

	// IssueAfterResetPriority Defines the grant priority for the default grant.
	IssueAfterResetPriority *uint8 `json:"issueAfterResetPriority,omitempty"`

	// MeasureUsageFrom Defines the time from which usage is measured. If not specified on creation, defaults to entitlement creation time.
	MeasureUsageFrom *MeasureUsageFrom `json:"measureUsageFrom,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// PreserveOverageAtReset If true, the overage is preserved at reset. If false, the usage is reset to 0.
	PreserveOverageAtReset *bool                              `json:"preserveOverageAtReset,omitempty"`
	Type                   EntitlementMeteredCreateInputsType `json:"type"`

	// UsagePeriod The usage period associated with the entitlement.
	UsagePeriod RecurringPeriodCreateInput `json:"usagePeriod"`
}

// EntitlementMeteredCreateInputsType defines model for EntitlementMeteredCreateInputs.Type.
type EntitlementMeteredCreateInputsType string

// EntitlementOrderBy Order by options for entitlements.
type EntitlementOrderBy string

// EntitlementPaginatedResponse Paginated response
type EntitlementPaginatedResponse struct {
	// Items The items in the current page.
	Items []Entitlement `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// EntitlementStatic A static entitlement.
type EntitlementStatic struct {
	// Config The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
	Config json.RawMessage `json:"config"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// CurrentUsagePeriod The current usage period.
	CurrentUsagePeriod *Period `json:"currentUsagePeriod,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// FeatureId The feature the subject is entitled to use.
	FeatureId string `json:"featureId"`

	// FeatureKey The feature the subject is entitled to use.
	FeatureKey string `json:"featureKey"`

	// Id Readonly unique ULID identifier.
	Id string `json:"id"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// SubjectKey The identifier key unique to the subject
	SubjectKey string                `json:"subjectKey"`
	Type       EntitlementStaticType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// UsagePeriod The defined usage period of the entitlement
	UsagePeriod *RecurringPeriod `json:"usagePeriod,omitempty"`
}

// EntitlementStaticType defines model for EntitlementStatic.Type.
type EntitlementStaticType string

// EntitlementStaticCreateInputs Create inputs for static entitlement
type EntitlementStaticCreateInputs struct {
	// Config The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
	Config json.RawMessage `json:"config"`

	// FeatureId The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureId *string `json:"featureId,omitempty"`

	// FeatureKey The feature the subject is entitled to use.
	// Either featureKey or featureId is required.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata                         `json:"metadata,omitempty"`
	Type     EntitlementStaticCreateInputsType `json:"type"`

	// UsagePeriod The usage period associated with the entitlement.
	UsagePeriod *RecurringPeriodCreateInput `json:"usagePeriod,omitempty"`
}

// EntitlementStaticCreateInputsType defines model for EntitlementStaticCreateInputs.Type.
type EntitlementStaticCreateInputsType string

// EntitlementType Type of the entitlement.
type EntitlementType = string

// EntitlementValue Entitlements are the core of OpenMeter access management. They define access to features for subjects. Entitlements can be metered, boolean, or static.
type EntitlementValue struct {
	// Balance Only available for metered entitlements. Metered entitlements are built around a balance calculation where feature usage is deducted from the issued grants. Balance represents the remaining balance of the entitlement, it's value never turns negative.
	Balance *float64 `json:"balance,omitempty"`

	// Config Only available for static entitlements. The JSON parsable config of the entitlement.
	Config *string `json:"config,omitempty"`

	// HasAccess Whether the subject has access to the feature. Shared accross all entitlement types.
	HasAccess bool `json:"hasAccess"`

	// Overage Only available for metered entitlements. Overage represents the usage that wasn't covered by grants, e.g. if the subject had a total feature usage of 100 in the period but they were only granted 80, there would be 20 overage.
	Overage *float64 `json:"overage,omitempty"`

	// Usage Only available for metered entitlements. Returns the total feature usage in the current period.
	Usage *float64 `json:"usage,omitempty"`
}

// Event CloudEvents Specification JSON Schema
//
// Optional properties are nullable according to the CloudEvents specification:
// OPTIONAL not omitted attributes MAY be represented as a null JSON value.
type Event = event.Event

// ExpirationDuration The expiration duration enum
type ExpirationDuration string

// ExpirationPeriod The grant expiration definition
type ExpirationPeriod struct {
	// Count The number of time units in the expiration period.
	Count int `json:"count"`

	// Duration The unit of time for the expiration period.
	Duration ExpirationDuration `json:"duration"`
}

// Feature Represents a feature that can be enabled or disabled for a plan.
// Used both for product catalog and entitlements.
type Feature struct {
	// ArchivedAt Timestamp of when the resource was archived.
	ArchivedAt *time.Time `json:"archivedAt,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Id Readonly unique ULID identifier.
	Id string `json:"id"`

	// Key A key is a unique string that is used to identify a resource.
	Key      string    `json:"key"`
	Metadata *Metadata `json:"metadata,omitempty"`

	// MeterGroupByFilters Optional meter group by filters.
	// Useful if the meter scope is broader than what feature tracks.
	// Example scenario would be a meter tracking all token use with groupBy fields for the model,
	// then the feature could filter for model=gpt-4.
	MeterGroupByFilters *map[string]string `json:"meterGroupByFilters,omitempty"`

	// MeterSlug A key is a unique string that is used to identify a resource.
	MeterSlug *string `json:"meterSlug,omitempty"`
	Name      string  `json:"name"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// FeatureCreateInputs Represents a feature that can be enabled or disabled for a plan.
// Used both for product catalog and entitlements.
type FeatureCreateInputs struct {
	// Key A key is a unique string that is used to identify a resource.
	Key      string    `json:"key"`
	Metadata *Metadata `json:"metadata,omitempty"`

	// MeterGroupByFilters Optional meter group by filters.
	// Useful if the meter scope is broader than what feature tracks.
	// Example scenario would be a meter tracking all token use with groupBy fields for the model,
	// then the feature could filter for model=gpt-4.
	MeterGroupByFilters *map[string]string `json:"meterGroupByFilters,omitempty"`

	// MeterSlug A key is a unique string that is used to identify a resource.
	MeterSlug *string `json:"meterSlug,omitempty"`
	Name      string  `json:"name"`
}

// FeatureMeta Limited representation of a feature resource which includes only its unique identifiers (id, key).
type FeatureMeta struct {
	// Id Unique identifier of a feature.
	Id string `json:"id"`

	// Key The key is an immutable unique identifier of the feature used throughout the API,
	// for example when interacting with a subject's entitlements.
	Key string `json:"key"`
}

// FeatureOrderBy Order by options for features.
type FeatureOrderBy string

// FeaturePaginatedResponse Paginated response
type FeaturePaginatedResponse struct {
	// Items The items in the current page.
	Items []Feature `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// FlatPrice Flat price.
type FlatPrice struct {
	// Amount The amount of the flat price.
	Amount Numeric       `json:"amount"`
	Type   FlatPriceType `json:"type"`
}

// FlatPriceType defines model for FlatPrice.Type.
type FlatPriceType string

// FlatPriceWithPaymentTerm Flat price with payment term.
type FlatPriceWithPaymentTerm struct {
	// Amount The amount of the flat price.
	Amount Numeric `json:"amount"`

	// PaymentTerm The payment term of the flat price.
	// Defaults to in advance.
	PaymentTerm *PricePaymentTerm            `json:"paymentTerm,omitempty"`
	Type        FlatPriceWithPaymentTermType `json:"type"`
}

// FlatPriceWithPaymentTermType defines model for FlatPriceWithPaymentTerm.Type.
type FlatPriceWithPaymentTermType string

// ForbiddenProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type ForbiddenProblemResponse = UnexpectedProblemResponse

// GrantBurnDownHistorySegment A segment of the grant burn down history.
//
// A given segment represents the usage of a grant between events that changed either the grant burn down priority order or the usag period.
type GrantBurnDownHistorySegment struct {
	// BalanceAtEnd The entitlement balance at the end of the period.
	BalanceAtEnd float64 `json:"balanceAtEnd"`

	// BalanceAtStart entitlement balance at the start of the period.
	BalanceAtStart float64 `json:"balanceAtStart"`

	// GrantBalancesAtEnd The balance breakdown of each active grant at the end of the period: GrantID: Balance
	GrantBalancesAtEnd map[string]float64 `json:"grantBalancesAtEnd"`

	// GrantBalancesAtStart The balance breakdown of each active grant at the start of the period: GrantID: Balance
	GrantBalancesAtStart map[string]float64 `json:"grantBalancesAtStart"`

	// GrantUsages Which grants were actually burnt down in the period and by what amount.
	GrantUsages []GrantUsageRecord `json:"grantUsages"`

	// Overage Overuse that wasn't covered by grants.
	Overage float64 `json:"overage"`

	// Period The period of the segment.
	Period Period `json:"period"`

	// Usage The total usage of the grant in the period.
	Usage float64 `json:"usage"`
}

// GrantOrderBy Order by options for grants.
type GrantOrderBy string

// GrantPaginatedResponse Paginated response
type GrantPaginatedResponse struct {
	// Items The items in the current page.
	Items []EntitlementGrant `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// GrantUsageRecord Usage Record
type GrantUsageRecord struct {
	// GrantId The id of the grant
	GrantId string `json:"grantId"`

	// Usage The usage in the period
	Usage float64 `json:"usage"`
}

// IngestEventsBody The body of the events request.
// Either a single event or a batch of events.
type IngestEventsBody struct {
	union json.RawMessage
}

// IngestEventsBody1 defines model for .
type IngestEventsBody1 = []Event

// IngestedEvent An ingested event with optional validation error.
type IngestedEvent struct {
	// Event CloudEvents Specification JSON Schema
	//
	// Optional properties are nullable according to the CloudEvents specification:
	// OPTIONAL not omitted attributes MAY be represented as a null JSON value.
	Event Event `json:"event"`

	// IngestedAt The date and time the event was ingested.
	IngestedAt time.Time `json:"ingestedAt"`

	// StoredAt The date and time the event was stored.
	StoredAt time.Time `json:"storedAt"`

	// ValidationError The validation error if the event failed validation.
	ValidationError *string `json:"validationError,omitempty"`
}

// InternalServerErrorProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type InternalServerErrorProblemResponse = UnexpectedProblemResponse

// InvoicePaginatedResponse Paginated response
type InvoicePaginatedResponse struct {
	// Items The items in the current page.
	Items []BillingInvoice `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// ListEntitlementsResult List entitlements result
type ListEntitlementsResult struct {
	union json.RawMessage
}

// ListEntitlementsResult0 defines model for .
type ListEntitlementsResult0 = []Entitlement

// ListFeaturesResult List features result
type ListFeaturesResult struct {
	union json.RawMessage
}

// ListFeaturesResult0 defines model for .
type ListFeaturesResult0 = []Feature

// MarketplaceListing A marketplace listing.
// Represent an available app in the app marketplace that can be installed to the organization.
//
// Marketplace apps only exist in config so they don't extend the Resource model.
type MarketplaceListing struct {
	// Capabilities The app's capabilities.
	Capabilities []AppCapability `json:"capabilities"`

	// Description The app's description.
	Description string `json:"description"`

	// IconUrl The app's icon URL.
	IconUrl string `json:"iconUrl"`

	// Name The app's name.
	Name string `json:"name"`

	// Type The app's type
	Type AppType `json:"type"`
}

// MarketplaceListingList A page of results.
type MarketplaceListingList struct {
	// Items The items in the page.
	Items []MarketplaceListing `json:"items"`

	// Page The page number.
	Page int `json:"page"`

	// PageSize The number of items in the page.
	PageSize int `json:"pageSize"`

	// TotalCount The total number of items.
	TotalCount int `json:"totalCount"`
}

// MeasureUsageFrom Measure usage from
type MeasureUsageFrom struct {
	union json.RawMessage
}

// MeasureUsageFromPreset Start of measurement options
type MeasureUsageFromPreset string

// MeasureUsageFromTime [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
type MeasureUsageFromTime = time.Time

// Metadata Set of key-value pairs.
// Metadata can be used to store additional information about a resource.
type Metadata = map[string]string

// Meter A meter is a configuration that defines how to match and aggregate events.
type Meter = models.Meter

// MeterAggregation The aggregation type to use for the meter.
type MeterAggregation = models.MeterAggregation

// MeterQueryResult The result of a meter query.
type MeterQueryResult struct {
	Data []MeterQueryRow `json:"data"`

	// From [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	From *time.Time `json:"from,omitempty"`

	// To [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	To *time.Time `json:"to,omitempty"`

	// WindowSize Aggregation window size.
	WindowSize *WindowSize `json:"windowSize,omitempty"`
}

// MeterQueryRow A row in the result of a meter query.
type MeterQueryRow = models.MeterQueryRow

// NotFoundProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type NotFoundProblemResponse = UnexpectedProblemResponse

// NotificationChannel Notification channel with webhook type.
type NotificationChannel = NotificationChannelWebhook

// NotificationChannelCreateRequest Request with input parameters for creating new notification channel with webhook type.
type NotificationChannelCreateRequest = NotificationChannelWebhookCreateRequest

// NotificationChannelMeta Metadata only fields of a notification channel.
type NotificationChannelMeta struct {
	// Id Identifies the notification channel.
	Id string `json:"id"`

	// Type Notification channel type.
	Type NotificationChannelType `json:"type"`
}

// NotificationChannelOrderBy Order by options for notification channels.
type NotificationChannelOrderBy string

// NotificationChannelPaginatedResponse Paginated response
type NotificationChannelPaginatedResponse struct {
	// Items The items in the current page.
	Items []NotificationChannel `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// NotificationChannelType Type of the notification channel.
type NotificationChannelType string

// NotificationChannelWebhook Notification channel with webhook type.
type NotificationChannelWebhook struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// CustomHeaders Custom HTTP headers sent as part of the webhook request.
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Disabled Whether the channel is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Id Identifies the notification channel.
	Id string `json:"id"`

	// Name User friendly name of the channel.
	Name string `json:"name"`

	// SigningSecret Signing secret used for webhook request validation on the receiving end.
	//
	// Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
	SigningSecret *string `json:"signingSecret,omitempty"`

	// Type Notification channel type.
	Type NotificationChannelWebhookType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// Url Webhook URL where the notification is sent.
	Url string `json:"url"`
}

// NotificationChannelWebhookType Notification channel type.
type NotificationChannelWebhookType string

// NotificationChannelWebhookCreateRequest Request with input parameters for creating new notification channel with webhook type.
type NotificationChannelWebhookCreateRequest struct {
	// CustomHeaders Custom HTTP headers sent as part of the webhook request.
	CustomHeaders *map[string]string `json:"customHeaders,omitempty"`

	// Disabled Whether the channel is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Name User friendly name of the channel.
	Name string `json:"name"`

	// SigningSecret Signing secret used for webhook request validation on the receiving end.
	//
	// Format: `base64` encoded random bytes optionally prefixed with `whsec_`. Recommended size: 24
	SigningSecret *string `json:"signingSecret,omitempty"`

	// Type Notification channel type.
	Type NotificationChannelWebhookCreateRequestType `json:"type"`

	// Url Webhook URL where the notification is sent.
	Url string `json:"url"`
}

// NotificationChannelWebhookCreateRequestType Notification channel type.
type NotificationChannelWebhookCreateRequestType string

// NotificationEvent Type of the notification event.
type NotificationEvent struct {
	// Annotations Set of key-value pairs managed by the system. Cannot be modified by user.
	Annotations *Annotations `json:"annotations,omitempty"`

	// CreatedAt Timestamp when the notification event was created in RFC 3339 format.
	CreatedAt time.Time `json:"createdAt"`

	// DeliveryStatus The delivery status of the notification event.
	DeliveryStatus []NotificationEventDeliveryStatus `json:"deliveryStatus"`

	// Id A unique identifier of the notification event.
	Id      string                   `json:"id"`
	Payload NotificationEventPayload `json:"payload"`
	Rule    NotificationRule         `json:"rule"`

	// Type Type of the notification event.
	Type NotificationEventType `json:"type"`
}

// NotificationEventBalanceThresholdPayload Payload for notification event with `entitlements.balance.threshold` type.
type NotificationEventBalanceThresholdPayload struct {
	// Data The data of the payload.
	Data NotificationEventBalanceThresholdPayloadData `json:"data"`

	// Id A unique identifier for the notification event the payload belongs to.
	Id string `json:"id"`

	// Timestamp Timestamp when the notification event was created in RFC 3339 format.
	Timestamp time.Time `json:"timestamp"`

	// Type Type of the notification event.
	Type NotificationEventBalanceThresholdPayloadType `json:"type"`
}

// NotificationEventBalanceThresholdPayloadType Type of the notification event.
type NotificationEventBalanceThresholdPayloadType string

// NotificationEventBalanceThresholdPayloadData Data of the payload for notification event with `entitlements.balance.threshold` type.
type NotificationEventBalanceThresholdPayloadData struct {
	Entitlement EntitlementMetered                    `json:"entitlement"`
	Feature     Feature                               `json:"feature"`
	Subject     Subject                               `json:"subject"`
	Threshold   NotificationRuleBalanceThresholdValue `json:"threshold"`
	Value       EntitlementValue                      `json:"value"`
}

// NotificationEventDeliveryStatus The delivery status of the notification event.
type NotificationEventDeliveryStatus struct {
	// Channel Notification channel the delivery sattus associated with.
	Channel NotificationChannelMeta `json:"channel"`

	// Reason The reason of the last deliverry state update.
	Reason string `json:"reason"`

	// State Delivery state of the notification event to the channel.
	State NotificationEventDeliveryStatusState `json:"state"`

	// UpdatedAt Timestamp of when the status was last updated in RFC 3339 format.
	UpdatedAt time.Time `json:"updatedAt"`
}

// NotificationEventDeliveryStatusState The delivery state of the notification event to the channel.
type NotificationEventDeliveryStatusState string

// NotificationEventOrderBy Order by options for notification channels.
type NotificationEventOrderBy string

// NotificationEventPaginatedResponse Paginated response
type NotificationEventPaginatedResponse struct {
	// Items The items in the current page.
	Items []NotificationEvent `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// NotificationEventPayload Payload for notification event with `entitlements.balance.threshold` type.
type NotificationEventPayload = NotificationEventBalanceThresholdPayload

// NotificationEventType Type of the notification event.
type NotificationEventType string

// NotificationRule Notification rule with entitlements.balance.threshold type.
type NotificationRule = NotificationRuleBalanceThreshold

// NotificationRuleBalanceThreshold Notification rule with entitlements.balance.threshold type.
type NotificationRuleBalanceThreshold struct {
	// Channels List of notification channels the rule applies to.
	Channels []NotificationChannelMeta `json:"channels"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Features Optional field containing list of features the rule applies to.
	Features *[]FeatureMeta `json:"features,omitempty"`

	// Id Identifies the notification rule.
	Id string `json:"id"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Thresholds List of thresholds the rule suppose to be triggered.
	Thresholds []NotificationRuleBalanceThresholdValue `json:"thresholds"`

	// Type Notification rule type.
	Type NotificationRuleBalanceThresholdType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// NotificationRuleBalanceThresholdType Notification rule type.
type NotificationRuleBalanceThresholdType string

// NotificationRuleBalanceThresholdCreateRequest Request with input parameters for creating new notification rule with entitlements.balance.threashold type.
type NotificationRuleBalanceThresholdCreateRequest struct {
	// Channels List of notification channels the rule is applied to.
	Channels []string `json:"channels"`

	// Disabled Whether the rule is disabled or not.
	Disabled *bool `json:"disabled,omitempty"`

	// Features Optional field for defining the scope of notification by feature. It may contain features by id or key.
	Features *[]string `json:"features,omitempty"`

	// Name The user friendly name of the notification rule.
	Name string `json:"name"`

	// Thresholds List of thresholds the rule suppose to be triggered.
	Thresholds []NotificationRuleBalanceThresholdValue `json:"thresholds"`

	// Type Notification rule type.
	Type NotificationRuleBalanceThresholdCreateRequestType `json:"type"`
}

// NotificationRuleBalanceThresholdCreateRequestType Notification rule type.
type NotificationRuleBalanceThresholdCreateRequestType string

// NotificationRuleBalanceThresholdValue Threshold value with multiple supported types.
type NotificationRuleBalanceThresholdValue struct {
	// Type Type of the threshold.
	Type NotificationRuleBalanceThresholdValueType `json:"type"`

	// Value Value of the threshold.
	Value float64 `json:"value"`
}

// NotificationRuleBalanceThresholdValueType Type of the rule in the balance threshold specification.
type NotificationRuleBalanceThresholdValueType string

// NotificationRuleCreateRequest Request with input parameters for creating new notification rule with entitlements.balance.threashold type.
type NotificationRuleCreateRequest = NotificationRuleBalanceThresholdCreateRequest

// NotificationRuleOrderBy Order by options for notification channels.
type NotificationRuleOrderBy string

// NotificationRulePaginatedResponse Paginated response
type NotificationRulePaginatedResponse struct {
	// Items The items in the current page.
	Items []NotificationRule `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// Numeric Numeric represents an arbitrary precision number.
type Numeric = string

// OAuth2AuthorizationCodeGrantErrorType OAuth2 authorization code grant error types.
type OAuth2AuthorizationCodeGrantErrorType string

// Percentage Numeric representation of a percentage
type Percentage = string

// Period A period with a start and end time.
type Period struct {
	// From Period start time.
	From time.Time `json:"from"`

	// To Period end time.
	To time.Time `json:"to"`
}

// PhasesOrderBy Order by options for plan phases.
type PhasesOrderBy string

// Plan Plans provide a template for subscriptions.
type Plan struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency The currency code of the plan.
	Currency CurrencyCode `json:"currency"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EffectiveFrom The date and time when the plan becomes effective. When not specified, the plan is a draft.
	EffectiveFrom *time.Time `json:"effectiveFrom,omitempty"`

	// EffectiveTo The date and time when the plan is no longer effective. When not specified, the plan is effective indefinitely.
	EffectiveTo *time.Time `json:"effectiveTo,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Phases The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
	// A phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.
	Phases []PlanPhase `json:"phases"`

	// Status The status of the plan.
	// Computed based on the effective start and end dates:
	// - draft = no effectiveFrom
	// - active = effectiveFrom <= now < effectiveTo
	// - archived / inactive = effectiveTo <= now
	// - scheduled = now < effectiveFrom < effectiveTo
	Status PlanStatus `json:"status"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`

	// Version Version of the plan. Incremented when the plan is updated.
	Version int `json:"version"`
}

// PlanCreate Resource create operation model.
type PlanCreate struct {
	// Currency The currency code of the plan.
	Currency CurrencyCode `json:"currency"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Phases The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
	// A phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.
	Phases []PlanPhase `json:"phases"`
}

// PlanOrderBy Order by options for plans.
type PlanOrderBy string

// PlanPaginatedResponse Paginated response
type PlanPaginatedResponse struct {
	// Items The items in the current page.
	Items []Plan `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// PlanPhase The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
type PlanPhase struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Discounts The discounts on the plan.
	Discounts *[]Discount `json:"discounts,omitempty"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// RateCards The rate cards of the plan.
	RateCards []RateCard `json:"rateCards"`

	// StartAfter The time after which the plan starts compared to subscription start
	StartAfter *string `json:"startAfter"`
}

// PlanPhaseCreate Resource create operation model.
type PlanPhaseCreate struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Discounts The discounts on the plan.
	Discounts *[]Discount `json:"discounts,omitempty"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// RateCards The rate cards of the plan.
	RateCards []RateCard `json:"rateCards"`

	// StartAfter The time after which the plan starts compared to subscription start
	StartAfter *string `json:"startAfter"`
}

// PlanPhasePaginatedResponse Paginated response
type PlanPhasePaginatedResponse struct {
	// Items The items in the current page.
	Items []PlanPhase `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// PlanPhaseUpdate Resource create or update operation model.
type PlanPhaseUpdate struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Discounts The discounts on the plan.
	Discounts *[]Discount `json:"discounts,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name *string `json:"name,omitempty"`

	// RateCards The rate cards of the plan.
	RateCards *[]RateCard `json:"rateCards,omitempty"`

	// StartAfter The time after which the plan starts compared to subscription start
	StartAfter *string `json:"startAfter"`
}

// PlanReference References an exact plan.
type PlanReference struct {
	// Key The plan key.
	Key string `json:"key"`

	// Version The plan version.
	Version int `json:"version"`
}

// PlanReplaceUpdate Resource update operation model.
type PlanReplaceUpdate struct {
	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Phases The plan phase or pricing ramp allows changing a plan's rate cards over time as a subscription progresses.
	// A phase switch occurs only at the end of a billing period, ensuring that a single subscription invoice will not include charges from different phase prices.
	Phases []PlanPhase `json:"phases"`
}

// PlanStatus The status of a plan.
type PlanStatus string

// PortalToken A consumer portal token.
//
// Validator doesn't obey required for readOnly properties
// See: https://github.com/stoplightio/spectral/issues/1274
type PortalToken struct {
	// AllowedMeterSlugs Optional, if defined only the specified meters will be allowed.
	AllowedMeterSlugs *[]string `json:"allowedMeterSlugs,omitempty"`

	// CreatedAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Expired   *bool      `json:"expired,omitempty"`

	// ExpiresAt [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Id ULID (Universally Unique Lexicographically Sortable Identifier).
	Id      *string `json:"id,omitempty"`
	Subject string  `json:"subject"`

	// Token The token is only returned at creation.
	Token *string `json:"token,omitempty"`
}

// PricePaymentTerm The payment term of a flat price.
// One of: in_advance or in_arrears.
type PricePaymentTerm string

// PriceTier A price tier.
// At least one price component is required in each tier.
type PriceTier struct {
	// FlatPrice The flat price component of the tier.
	FlatPrice *FlatPrice `json:"flatPrice"`

	// UnitPrice The unit price component of the tier.
	UnitPrice *UnitPrice `json:"unitPrice"`

	// UpToAmount Up to and including to this quantity will be contained in the tier.
	// If null, the tier is open-ended.
	UpToAmount *float64 `json:"upToAmount"`
}

// ProfilePaginatedResponse Paginated response
type ProfilePaginatedResponse struct {
	// Items The items in the current page.
	Items []BillingProfile `json:"items"`

	// Page The items in the current page.
	Page int `json:"page"`

	// PageSize The items in the current page.
	PageSize int `json:"pageSize"`

	// TotalCount The items in the current page.
	TotalCount int `json:"totalCount"`
}

// RateCard A rate card defines the pricing and entitlement of a feature or service.
type RateCard struct {
	union json.RawMessage
}

// RateCardBooleanEntitlement Entitlement template of a boolean entitlement.
type RateCardBooleanEntitlement struct {
	// Metadata Additional metadata for the feature.
	Metadata *Metadata                      `json:"metadata,omitempty"`
	Type     RateCardBooleanEntitlementType `json:"type"`
}

// RateCardBooleanEntitlementType defines model for RateCardBooleanEntitlement.Type.
type RateCardBooleanEntitlementType string

// RateCardEntitlement Entitlement templates are used to define the entitlements of a plan.
// Features are omitted from the entitlement template, as they are defined in the rate card.
type RateCardEntitlement struct {
	union json.RawMessage
}

// RateCardFlatFee A flat fee rate card defines a one-time purchase or a recurring fee.
type RateCardFlatFee struct {
	// BillingCadence The billing cadence of the rate card.
	// When null it means it is a one time fee.
	BillingCadence *string `json:"billingCadence"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EntitlementTemplate Entitlement templates are used to define the entitlements of a plan.
	// Features are omitted from the entitlement template, as they are defined in the rate card.
	EntitlementTemplate *RateCardEntitlement `json:"entitlementTemplate,omitempty"`

	// FeatureKey The feature the customer is entitled to use.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Price The price of the rate card.
	// When null, the feature or service is free.
	Price *FlatPriceWithPaymentTerm `json:"price"`

	// TaxConfig The tax config of the rate card.
	// When undefined, the tax config of the feature or the default tax config of the plan is used.
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type The type of the RateCard.
	Type RateCardFlatFeeType `json:"type"`
}

// RateCardFlatFeeType The type of the RateCard.
type RateCardFlatFeeType string

// RateCardFlatFeeUpdateItem A flat fee rate card defines a one-time purchase or a recurring fee.
type RateCardFlatFeeUpdateItem struct {
	// BillingCadence The billing cadence of the rate card.
	// When null it means it is a one time fee.
	BillingCadence *string `json:"billingCadence"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EntitlementTemplate Entitlement templates are used to define the entitlements of a plan.
	// Features are omitted from the entitlement template, as they are defined in the rate card.
	EntitlementTemplate *RateCardEntitlement `json:"entitlementTemplate,omitempty"`

	// FeatureKey The feature the customer is entitled to use.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Price The price of the rate card.
	// When null, the feature or service is free.
	Price *FlatPriceWithPaymentTerm `json:"price"`

	// TaxConfig The tax config of the rate card.
	// When undefined, the tax config of the feature or the default tax config of the plan is used.
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type The type of the RateCard.
	Type RateCardFlatFeeUpdateItemType `json:"type"`
}

// RateCardFlatFeeUpdateItemType The type of the RateCard.
type RateCardFlatFeeUpdateItemType string

// RateCardMeteredEntitlement The entitlement template with a metered entitlement.
type RateCardMeteredEntitlement struct {
	// IsSoftLimit If softLimit=true the subject can use the feature even if the entitlement is exhausted, hasAccess will always be true.
	IsSoftLimit *bool `json:"isSoftLimit,omitempty"`

	// IssueAfterReset You can grant usage automatically alongside the entitlement, the example scenario would be creating a starting balance.
	// If an amount is specified here, a grant will be created alongside the entitlement with the specified amount.
	// That grant will have it's rollover settings configured in a way that after each reset operation, the balance will return the original amount specified here.
	// Manually creating such a grant would mean having the "amount", "minRolloverAmount", and "maxRolloverAmount" fields all be the same.
	IssueAfterReset *float64 `json:"issueAfterReset,omitempty"`

	// IssueAfterResetPriority Defines the grant priority for the default grant.
	IssueAfterResetPriority *uint8 `json:"issueAfterResetPriority,omitempty"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata `json:"metadata,omitempty"`

	// PreserveOverageAtReset If true, the overage is preserved at reset. If false, the usage is reset to 0.
	PreserveOverageAtReset *bool                          `json:"preserveOverageAtReset,omitempty"`
	Type                   RateCardMeteredEntitlementType `json:"type"`

	// UsagePeriod The interval of the metered entitlement.
	// Defaults to the billing cadence of the rate card.
	UsagePeriod *string `json:"usagePeriod,omitempty"`
}

// RateCardMeteredEntitlementType defines model for RateCardMeteredEntitlement.Type.
type RateCardMeteredEntitlementType string

// RateCardStaticEntitlement Entitlement template of a static entitlement.
type RateCardStaticEntitlement struct {
	// Config The JSON parsable config of the entitlement. This value is also returned when checking entitlement access and it is useful for configuring fine-grained access settings to the feature, implemented in your own system. Has to be an object.
	Config json.RawMessage `json:"config"`

	// Metadata Additional metadata for the feature.
	Metadata *Metadata                     `json:"metadata,omitempty"`
	Type     RateCardStaticEntitlementType `json:"type"`
}

// RateCardStaticEntitlementType defines model for RateCardStaticEntitlement.Type.
type RateCardStaticEntitlementType string

// RateCardUpdateItem A rate card defines the pricing and entitlement of a feature or service.
type RateCardUpdateItem struct {
	union json.RawMessage
}

// RateCardUsageBased A usage-based rate card defines a price based on usage.
type RateCardUsageBased struct {
	// BillingCadence The billing cadence of the rate card.
	BillingCadence string `json:"billingCadence"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EntitlementTemplate Entitlement templates are used to define the entitlements of a plan.
	// Features are omitted from the entitlement template, as they are defined in the rate card.
	EntitlementTemplate *RateCardEntitlement `json:"entitlementTemplate,omitempty"`

	// FeatureKey The feature the customer is entitled to use.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Key A semi-unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name  string                   `json:"name"`
	Price *RateCardUsageBasedPrice `json:"price"`

	// TaxConfig The tax config of the rate card.
	// When undefined, the tax config of the feature or the default tax config of the plan is used.
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type The type of the RateCard.
	Type RateCardUsageBasedType `json:"type"`
}

// RateCardUsageBasedType The type of the RateCard.
type RateCardUsageBasedType string

// RateCardUsageBasedPrice The price of the usage based rate card.
type RateCardUsageBasedPrice struct {
	union json.RawMessage
}

// RateCardUsageBasedUpdateItem A usage-based rate card defines a price based on usage.
type RateCardUsageBasedUpdateItem struct {
	// BillingCadence The billing cadence of the rate card.
	BillingCadence string `json:"billingCadence"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// EntitlementTemplate Entitlement templates are used to define the entitlements of a plan.
	// Features are omitted from the entitlement template, as they are defined in the rate card.
	EntitlementTemplate *RateCardEntitlement `json:"entitlementTemplate,omitempty"`

	// FeatureKey The feature the customer is entitled to use.
	FeatureKey *string `json:"featureKey,omitempty"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name  string                   `json:"name"`
	Price *RateCardUsageBasedPrice `json:"price"`

	// TaxConfig The tax config of the rate card.
	// When undefined, the tax config of the feature or the default tax config of the plan is used.
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// Type The type of the RateCard.
	Type RateCardUsageBasedUpdateItemType `json:"type"`
}

// RateCardUsageBasedUpdateItemType The type of the RateCard.
type RateCardUsageBasedUpdateItemType string

// RecurringPeriod Recurring period with an interval and an anchor.
type RecurringPeriod struct {
	// Anchor A date-time anchor to base the recurring period on.
	Anchor time.Time `json:"anchor"`

	// Interval The unit of time for the interval.
	Interval RecurringPeriodInterval `json:"interval"`
}

// RecurringPeriodCreateInput Recurring period with an interval and an anchor.
type RecurringPeriodCreateInput struct {
	// Anchor A date-time anchor to base the recurring period on.
	Anchor *time.Time `json:"anchor,omitempty"`

	// Interval The unit of time for the interval.
	Interval RecurringPeriodInterval `json:"interval"`
}

// RecurringPeriodInterval The unit of time for the interval.
// One of: `day`, `week`, `month`, or `year`.
type RecurringPeriodInterval string

// RemovePhaseShifting The direction of the phase shift when a phase is removed.
type RemovePhaseShifting string

// ResetEntitlementUsageInput Reset parameters
type ResetEntitlementUsageInput struct {
	// EffectiveAt The time at which the reset takes effect, defaults to now. The reset cannot be in the future. The provided value is truncated to the minute due to how historical meter data is stored.
	EffectiveAt *time.Time `json:"effectiveAt,omitempty"`

	// PreserveOverage Determines whether the overage is preserved or forgiven, overriding the entitlement's default behavior.
	// - If true, the overage is preserved.
	// - If false, the overage is forgiven.
	PreserveOverage *bool `json:"preserveOverage,omitempty"`

	// RetainAnchor Determines whether the usage period anchor is retained or reset to the effectiveAt time.
	// - If true, the usage period anchor is retained.
	// - If false, the usage period anchor is reset to the effectiveAt time.
	RetainAnchor *bool `json:"retainAnchor,omitempty"`
}

// SandboxApp Sandbox app can be used for testing OpenMeter features.
//
// The app is not creating anything in external systems, thus it is safe to use for
// verifying OpenMeter features.
type SandboxApp struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Listing The marketplace listing that this installed app is based on.
	Listing MarketplaceListing `json:"listing"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Status Status of the app connection.
	Status AppStatus `json:"status"`

	// Type The app's type is Sandbox.
	Type SandboxAppType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SandboxAppType The app's type is Sandbox.
type SandboxAppType string

// ServiceUnavailableProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type ServiceUnavailableProblemResponse = UnexpectedProblemResponse

// SortOrder The order direction.
type SortOrder string

// StripeApp A installed Stripe app object.
type StripeApp struct {
	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Listing The marketplace listing that this installed app is based on.
	Listing MarketplaceListing `json:"listing"`

	// Livemode Livemode, true if the app is in production mode.
	Livemode bool `json:"livemode"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Status Status of the app connection.
	Status AppStatus `json:"status"`

	// StripeAccountId The Stripe account ID.
	StripeAccountId string `json:"stripeAccountId"`

	// Type The app's type is Stripe.
	Type StripeAppType `json:"type"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// StripeAppType The app's type is Stripe.
type StripeAppType string

// StripeCheckoutSessionMode Stripe CheckoutSession.mode
type StripeCheckoutSessionMode string

// StripePaymentIntentStatus Stripe payment intent status.
type StripePaymentIntentStatus string

// StripeSetupIntent Stripe setup intent.
type StripeSetupIntent struct {
	// Customer The setup intent customer.
	Customer string `json:"customer"`

	// Id The setup intent id.
	Id string `json:"id"`

	// Metadata The setup intent metadata.
	Metadata map[string]string `json:"metadata"`

	// PaymentMethod The setup intent payment method.
	PaymentMethod *string `json:"payment_method,omitempty"`

	// PaymentMethodTypes The setup intent payment method types.
	PaymentMethodTypes *[]string `json:"payment_method_types,omitempty"`

	// Status The setup intent status.
	Status StripePaymentIntentStatus `json:"status"`
}

// StripeTaxConfig The tax config for Stripe.
type StripeTaxConfig struct {
	// Code Product tax code.
	//
	// See: https://docs.stripe.com/tax/tax-codes
	Code string `json:"code"`
}

// StripeWebhookEvent Stripe webhook event.
type StripeWebhookEvent struct {
	// Created The event created timestamp.
	Created int32 `json:"created"`

	// Data The event data.
	Data struct {
		// Object Stripe setup intent.
		Object StripeSetupIntent `json:"object"`
	} `json:"data"`

	// Id The event ID.
	Id string `json:"id"`

	// Livemode Live mode.
	Livemode bool `json:"livemode"`

	// Type The event type.
	Type string `json:"type"`
}

// StripeWebhookResponse Stripe webhook response.
type StripeWebhookResponse struct {
	// AppId ULID (Universally Unique Lexicographically Sortable Identifier).
	AppId string `json:"appId"`

	// CustomerId ULID (Universally Unique Lexicographically Sortable Identifier).
	CustomerId *string `json:"customerId,omitempty"`

	// NamespaceId ULID (Universally Unique Lexicographically Sortable Identifier).
	NamespaceId string `json:"namespaceId"`
}

// Subject A subject is a unique identifier for a user or entity.
type Subject struct {
	// CurrentPeriodEnd [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CurrentPeriodEnd *time.Time `json:"currentPeriodEnd,omitempty"`

	// CurrentPeriodStart [RFC3339](https://tools.ietf.org/html/rfc3339) formatted date-time string in UTC.
	CurrentPeriodStart *time.Time `json:"currentPeriodStart,omitempty"`

	// DisplayName A human-readable display name for the subject.
	DisplayName *string `json:"displayName"`

	// Id A unique identifier for the subject.
	Id string `json:"id"`

	// Key A unique, human-readable identifier for the subject.
	Key              string                  `json:"key"`
	Metadata         *map[string]interface{} `json:"metadata"`
	StripeCustomerId *string                 `json:"stripeCustomerId"`
}

// Subscription Subscription is an exact subscription instance.
type Subscription struct {
	// ActiveTo If the subscription is canceled or otherwise have to end activeTo denotes the end date.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency The currency code of the subscription.
	// Will be revised once we add multi currency support.
	Currency CurrencyCode `json:"currency"`

	// CustomerId The customer ID of the subscription.
	CustomerId string `json:"customerId"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Plan The base plan of the subscription.
	Plan PlanReference `json:"plan"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SubscriptionEditAdd Subscription item add operation.
type SubscriptionEditAdd struct {
	Op   SubscriptionEditAddOp `json:"op"`
	Path string                `json:"path"`

	// Value Subscription phase create input.
	Value SubscriptionPhaseCreate `json:"value"`
}

// SubscriptionEditAddOp defines model for SubscriptionEditAdd.Op.
type SubscriptionEditAddOp string

// SubscriptionEditAddItem Subscription item add operation.
type SubscriptionEditAddItem struct {
	Op   SubscriptionEditAddItemOp `json:"op"`
	Path string                    `json:"path"`

	// Value A rate card defines the pricing and entitlement of a feature or service.
	Value RateCard `json:"value"`
}

// SubscriptionEditAddItemOp defines model for SubscriptionEditAddItem.Op.
type SubscriptionEditAddItemOp string

// SubscriptionEditAddUpdateItem Subscription item add operation.
type SubscriptionEditAddUpdateItem struct {
	Op   SubscriptionEditAddUpdateItemOp `json:"op"`
	Path string                          `json:"path"`

	// Value A rate card defines the pricing and entitlement of a feature or service.
	Value RateCardUpdateItem `json:"value"`
}

// SubscriptionEditAddUpdateItemOp defines model for SubscriptionEditAddUpdateItem.Op.
type SubscriptionEditAddUpdateItemOp string

// SubscriptionEditExtend Subscription phase extend operation.
type SubscriptionEditExtend struct {
	Op    SubscriptionEditExtendOp `json:"op"`
	Path  string                   `json:"path"`
	Value struct {
		ExtendBy string `json:"extendBy"`
	} `json:"value"`
}

// SubscriptionEditExtendOp defines model for SubscriptionEditExtend.Op.
type SubscriptionEditExtendOp string

// SubscriptionEditRemoveItem Subscription phase remove operation.
type SubscriptionEditRemoveItem struct {
	Op   SubscriptionEditRemoveItemOp `json:"op"`
	Path string                       `json:"path"`
}

// SubscriptionEditRemoveItemOp defines model for SubscriptionEditRemoveItem.Op.
type SubscriptionEditRemoveItemOp string

// SubscriptionEditRemoveUpdateItem Subscription phase remove operation.
type SubscriptionEditRemoveUpdateItem struct {
	Op   SubscriptionEditRemoveUpdateItemOp `json:"op"`
	Path string                             `json:"path"`
}

// SubscriptionEditRemoveUpdateItemOp defines model for SubscriptionEditRemoveUpdateItem.Op.
type SubscriptionEditRemoveUpdateItemOp string

// SubscriptionEditRemoveWithValue Subscription item remove operation with a value.
type SubscriptionEditRemoveWithValue struct {
	Op    SubscriptionEditRemoveWithValueOp `json:"op"`
	Path  string                            `json:"path"`
	Value struct {
		// Shift The direction of the phase shift when a phase is removed.
		Shift RemovePhaseShifting `json:"shift"`
	} `json:"value"`
}

// SubscriptionEditRemoveWithValueOp defines model for SubscriptionEditRemoveWithValue.Op.
type SubscriptionEditRemoveWithValueOp string

// SubscriptionExpanded Expanded subscription
type SubscriptionExpanded struct {
	// ActiveTo If the subscription is canceled or otherwise have to end activeTo denotes the end date.
	ActiveTo *time.Time `json:"activeTo,omitempty"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// Currency The currency code of the subscription.
	// Will be revised once we add multi currency support.
	Currency CurrencyCode `json:"currency"`

	// CustomerId The customer ID of the subscription.
	CustomerId string `json:"customerId"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Id A unique identifier for the resource.
	Id string `json:"id"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name   string                      `json:"name"`
	Phases []SubscriptionPhaseExpanded `json:"phases"`

	// Plan The base plan of the subscription.
	Plan PlanReference `json:"plan"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SubscriptionItem The actual contents of the Subscription, what the user gets, what they pay, etc...
type SubscriptionItem struct {
	// BillingCandence The billing cadence of the rate card.
	// When null, the rate card is a one-time purchase.
	BillingCandence *string `json:"billingCandence"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Included Describes what access is gained via the SubscriptionItem
	Included *struct {
		// Entitlement Entitlement templates are used to define the entitlements of a plan.
		// Features are omitted from the entitlement template, as they are defined in the rate card.
		Entitlement *Entitlement `json:"entitlement,omitempty"`

		// Feature The feature the customer is entitled to use.
		Feature Feature `json:"feature"`
	} `json:"included,omitempty"`

	// Key The identifier of the RateCard.
	// SubscriptionItem/RateCard can be identified, it has a reference:
	//
	// 1. If a Feature is associated with the SubscriptionItem, it is identified by the Feature
	// 1.1 It can be an ID reference, for an exact version of the Feature (Features can change across versions)
	// 1.2 It can be a Key reference, which always refers to the latest (active or inactive) version of a Feature
	//
	// 2. If a Feature is not associated with the SubscriptionItem, it is referenced by the Price
	//
	// We say referenced by the Price regardless of how a price itself is referenced, it colloquially makes sense to say paying the same price for the same thing. In practice this should be derived from what's printed on the invoice line-item.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// Price The price of the rate card.
	// When null, the feature or service is free.
	Price SubscriptionItem_Price `json:"price"`

	// TaxConfig The tax config of the Subscription Item.
	// When undefined, the tax config of the feature or the default tax config of the plan is used.
	TaxConfig *TaxConfig `json:"taxConfig,omitempty"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SubscriptionItemPrice0 Flat price with payment term.
type SubscriptionItemPrice0 = FlatPriceWithPaymentTerm

// SubscriptionItemPrice1 Unit price with spend commitments.
type SubscriptionItemPrice1 = UnitPriceWithCommitments

// SubscriptionItemPrice2 Tiered price with spend commitments.
type SubscriptionItemPrice2 = TieredPriceWithCommitments

// SubscriptionItemPrice3 Flat price with payment term.
type SubscriptionItemPrice3 = FlatPriceWithPaymentTerm

// SubscriptionItem_Price The price of the rate card.
// When null, the feature or service is free.
type SubscriptionItem_Price struct {
	union json.RawMessage
}

// SubscriptionPhaseCreate Subscription phase create input.
type SubscriptionPhaseCreate struct {
	// Discounts The discounts on the plan.
	Discounts *[]DiscountUpdateItem `json:"discounts,omitempty"`

	// Duration The intended duration of the new phase.
	Duration string `json:"duration"`

	// StartAfter Interval after the subscription starts to transition to the phase.
	// When null, the phase starts immediately after the subscription starts.
	StartAfter *string `json:"startAfter"`
}

// SubscriptionPhaseExpanded Expanded subscription phase
type SubscriptionPhaseExpanded struct {
	// ActiveFrom The time from which the phase is active.
	ActiveFrom time.Time `json:"activeFrom"`

	// CreatedAt Timestamp of when the resource was created.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt Timestamp of when the resource was permanently deleted.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Description Optional description of the resource. Maximum 1024 characters.
	Description *string `json:"description,omitempty"`

	// Discounts The discounts on the plan.
	Discounts *[]Discount `json:"discounts,omitempty"`

	// Duration The intended duration of the new phase.
	Duration string             `json:"duration"`
	Items    []SubscriptionItem `json:"items"`

	// Key A locally unique identifier for the resource.
	Key string `json:"key"`

	// Metadata Additional metadata for the resource.
	Metadata *Metadata `json:"metadata"`

	// Name Human-readable name for the resource. Between 1 and 256 characters.
	Name string `json:"name"`

	// UpdatedAt Timestamp of when the resource was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// SvixOperationalWebhookRequest Operational webhook reqeuest sent by Svix.
type SvixOperationalWebhookRequest struct {
	// Data The payload of the Svix operational webhook request.
	Data map[string]string `json:"data"`

	// Type The type of the Svix operational webhook request.
	Type SvixOperationalWebhookRequestType `json:"type"`
}

// SvixOperationalWebhookRequestType The type of the Svix operational webhook request.
type SvixOperationalWebhookRequestType string

// TaxConfig Set of provider specific tax configs.
type TaxConfig struct {
	// Stripe Stripe tax config.
	Stripe *StripeTaxConfig `json:"stripe,omitempty"`
}

// TieredPriceMode The mode of the tiered price.
type TieredPriceMode string

// TieredPriceWithCommitments Tiered price with spend commitments.
type TieredPriceWithCommitments struct {
	// MaximumAmount The customer is limited to spend at most the amount.
	MaximumAmount *Numeric `json:"maximumAmount,omitempty"`

	// MinimumAmount The customer is committed to spend at least the amount.
	MinimumAmount *Numeric `json:"minimumAmount,omitempty"`

	// Mode Defines if the tiering mode is volume-based or graduated:
	// - In `volume`-based tiering, the maximum quantity within a period determines the per unit price.
	// - In `graduated` tiering, pricing can change as the quantity grows.
	Mode TieredPriceMode `json:"mode"`

	// Tiers The tiers of the tiered price.
	// At least one price component is required in each tier.
	Tiers []PriceTier                    `json:"tiers"`
	Type  TieredPriceWithCommitmentsType `json:"type"`
}

// TieredPriceWithCommitmentsType defines model for TieredPriceWithCommitments.Type.
type TieredPriceWithCommitmentsType string

// UnauthorizedProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type UnauthorizedProblemResponse = UnexpectedProblemResponse

// UnexpectedProblemResponse A Problem Details object (RFC 7807).
// Additional properties specific to the problem type may be present.
type UnexpectedProblemResponse = models.StatusProblem

// UnitPrice Unit price.
type UnitPrice struct {
	// Amount The amount of the unit price.
	Amount Numeric       `json:"amount"`
	Type   UnitPriceType `json:"type"`
}

// UnitPriceType defines model for UnitPrice.Type.
type UnitPriceType string

// UnitPriceWithCommitments Unit price with spend commitments.
type UnitPriceWithCommitments struct {
	// Amount The amount of the unit price.
	Amount Numeric `json:"amount"`

	// MaximumAmount The customer is limited to spend at most the amount.
	MaximumAmount *Numeric `json:"maximumAmount,omitempty"`

	// MinimumAmount The customer is committed to spend at least the amount.
	MinimumAmount *Numeric                     `json:"minimumAmount,omitempty"`
	Type          UnitPriceWithCommitmentsType `json:"type"`
}

// UnitPriceWithCommitmentsType defines model for UnitPriceWithCommitments.Type.
type UnitPriceWithCommitmentsType string

// WindowSize Aggregation window size.
type WindowSize = models.WindowSize

// WindowedBalanceHistory The windowed balance history.
type WindowedBalanceHistory struct {
	// BurndownHistory Grant burndown history.
	BurndownHistory []GrantBurnDownHistorySegment `json:"burndownHistory"`

	// WindowedHistory The windowed balance history.
	// - It only returns rows for windows where there was usage.
	// - The windows are inclusive at their start and exclusive at their end.
	// - The last window may be smaller than the window size and is inclusive at both ends.
	WindowedHistory []BalanceHistoryWindow `json:"windowedHistory"`
}

// BillingInvoiceListParamsExpand defines model for BillingInvoiceListParams.expand.
type BillingInvoiceListParamsExpand = []BillingInvoiceExpand

// BillingInvoiceListParamsExtendedStatuses defines model for BillingInvoiceListParams.extendedStatuses.
type BillingInvoiceListParamsExtendedStatuses = []BillingInvoiceExtendedStatus

// BillingInvoiceListParamsIssuedAfter defines model for BillingInvoiceListParams.issuedAfter.
type BillingInvoiceListParamsIssuedAfter = time.Time

// BillingInvoiceListParamsIssuedBefore defines model for BillingInvoiceListParams.issuedBefore.
type BillingInvoiceListParamsIssuedBefore = time.Time

// BillingInvoiceListParamsStatuses defines model for BillingInvoiceListParams.statuses.
type BillingInvoiceListParamsStatuses = []BillingInvoiceStatus

// CustomerOrderByOrderingOrder The order direction.
type CustomerOrderByOrderingOrder = SortOrder

// CustomerOrderByOrderingOrderBy Order by options for customers.
type CustomerOrderByOrderingOrderBy = CustomerOrderBy

// CustomerOverrideOrderByOrderingOrder The order direction.
type CustomerOverrideOrderByOrderingOrder = SortOrder

// CustomerOverrideOrderByOrderingOrderBy Order by options for customers.
type CustomerOverrideOrderByOrderingOrderBy = BillingCustomerOverrideOrderBy

// EntitlementOrderByOrderingOrder The order direction.
type EntitlementOrderByOrderingOrder = SortOrder

// EntitlementOrderByOrderingOrderBy Order by options for entitlements.
type EntitlementOrderByOrderingOrderBy = EntitlementOrderBy

// FeatureOrderByOrderingOrder The order direction.
type FeatureOrderByOrderingOrder = SortOrder

// FeatureOrderByOrderingOrderBy Order by options for features.
type FeatureOrderByOrderingOrderBy = FeatureOrderBy

// GrantOrderByOrderingOrder The order direction.
type GrantOrderByOrderingOrder = SortOrder

// GrantOrderByOrderingOrderBy Order by options for grants.
type GrantOrderByOrderingOrderBy = GrantOrderBy

// InvoiceOrderByOrderingOrder The order direction.
type InvoiceOrderByOrderingOrder = SortOrder

// InvoiceOrderByOrderingOrderBy InvoiceOrderBy specifies the ordering options for invoice listing.
type InvoiceOrderByOrderingOrderBy = BillingInvoiceOrderBy

// LimitOffsetLimit defines model for LimitOffset.limit.
type LimitOffsetLimit = int

// LimitOffsetOffset defines model for LimitOffset.offset.
type LimitOffsetOffset = int

// MarketplaceApiKeyInstallRequestType Type of the app.
type MarketplaceApiKeyInstallRequestType = AppType

// MarketplaceOAuth2InstallAuthorizeRequestType Type of the app.
type MarketplaceOAuth2InstallAuthorizeRequestType = AppType

// MeterQueryFilterGroupBy defines model for MeterQuery.filterGroupBy.
type MeterQueryFilterGroupBy map[string]string

// MeterQueryFrom defines model for MeterQuery.from.
type MeterQueryFrom = time.Time

// MeterQueryGroupBy defines model for MeterQuery.groupBy.
type MeterQueryGroupBy = []string

// MeterQuerySubject defines model for MeterQuery.subject.
type MeterQuerySubject = []string

// MeterQueryTo defines model for MeterQuery.to.
type MeterQueryTo = time.Time

// MeterQueryWindowSize Aggregation window size.
type MeterQueryWindowSize = WindowSize

// MeterQueryWindowTimeZone defines model for MeterQuery.windowTimeZone.
type MeterQueryWindowTimeZone = string

// NotificationChannelOrderByOrderingOrder The order direction.
type NotificationChannelOrderByOrderingOrder = SortOrder

// NotificationChannelOrderByOrderingOrderBy Order by options for notification channels.
type NotificationChannelOrderByOrderingOrderBy = NotificationChannelOrderBy

// NotificationEventOrderByOrderingOrder The order direction.
type NotificationEventOrderByOrderingOrder = SortOrder

// NotificationEventOrderByOrderingOrderBy Order by options for notification channels.
type NotificationEventOrderByOrderingOrderBy = NotificationEventOrderBy

// NotificationRuleOrderByOrderingOrder The order direction.
type NotificationRuleOrderByOrderingOrder = SortOrder

// NotificationRuleOrderByOrderingOrderBy Order by options for notification channels.
type NotificationRuleOrderByOrderingOrderBy = NotificationRuleOrderBy

// OAuth2AuthorizationCodeGrantErrorParamsError OAuth2 authorization code grant error types.
type OAuth2AuthorizationCodeGrantErrorParamsError = OAuth2AuthorizationCodeGrantErrorType

// OAuth2AuthorizationCodeGrantErrorParamsErrorDescription defines model for OAuth2AuthorizationCodeGrantErrorParams.error_description.
type OAuth2AuthorizationCodeGrantErrorParamsErrorDescription = string

// OAuth2AuthorizationCodeGrantErrorParamsErrorUri defines model for OAuth2AuthorizationCodeGrantErrorParams.error_uri.
type OAuth2AuthorizationCodeGrantErrorParamsErrorUri = string

// OAuth2AuthorizationCodeGrantSuccessParamsCode defines model for OAuth2AuthorizationCodeGrantSuccessParams.code.
type OAuth2AuthorizationCodeGrantSuccessParamsCode = string

// OAuth2AuthorizationCodeGrantSuccessParamsState defines model for OAuth2AuthorizationCodeGrantSuccessParams.state.
type OAuth2AuthorizationCodeGrantSuccessParamsState = string

// PaginatedQueryPage defines model for PaginatedQuery.page.
type PaginatedQueryPage = int

// PaginatedQueryPageSize defines model for PaginatedQuery.pageSize.
type PaginatedQueryPageSize = int

// PaginationPage defines model for Pagination.page.
type PaginationPage = int

// PaginationPageSize defines model for Pagination.pageSize.
type PaginationPageSize = int

// PhasesOrderByOrderingOrder The order direction.
type PhasesOrderByOrderingOrder = SortOrder

// PhasesOrderByOrderingOrderBy Order by options for plan phases.
type PhasesOrderByOrderingOrderBy = PhasesOrderBy

// PlanOrderByOrderingOrder The order direction.
type PlanOrderByOrderingOrder = SortOrder

// PlanOrderByOrderingOrderBy Order by options for plans.
type PlanOrderByOrderingOrderBy = PlanOrderBy

// ProfileOrderByOrderingOrder The order direction.
type ProfileOrderByOrderingOrder = SortOrder

// ProfileOrderByOrderingOrderBy ProfileOrderBy specifies the ordering options for profiles
type ProfileOrderByOrderingOrderBy = BillingProfileOrderBy

// QueryCustomerListIncludeDeleted defines model for queryCustomerList.includeDeleted.
type QueryCustomerListIncludeDeleted = bool

// QueryCustomerListName defines model for queryCustomerList.name.
type QueryCustomerListName = string

// QueryCustomerListPrimaryEmail defines model for queryCustomerList.primaryEmail.
type QueryCustomerListPrimaryEmail = string

// QueryCustomerListSubject defines model for queryCustomerList.subject.
type QueryCustomerListSubject = string

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
	// Page The page number.
	Page *PaginatedQueryPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items in the page.
	PageSize *PaginatedQueryPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// BillingListCustomerOverridesParams defines parameters for BillingListCustomerOverrides.
type BillingListCustomerOverridesParams struct {
	BillingProfile *[]string `form:"billingProfile,omitempty" json:"billingProfile,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *CustomerOverrideOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *CustomerOverrideOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// BillingListInvoicesParams defines parameters for BillingListInvoices.
type BillingListInvoicesParams struct {
	Customers        *[]string                                 `form:"customers,omitempty" json:"customers,omitempty"`
	Statuses         *BillingInvoiceListParamsStatuses         `form:"statuses,omitempty" json:"statuses,omitempty"`
	ExtendedStatuses *BillingInvoiceListParamsExtendedStatuses `form:"extendedStatuses,omitempty" json:"extendedStatuses,omitempty"`
	IssuedAfter      *BillingInvoiceListParamsIssuedAfter      `form:"issuedAfter,omitempty" json:"issuedAfter,omitempty"`
	IssuedBefore     *BillingInvoiceListParamsIssuedBefore     `form:"issuedBefore,omitempty" json:"issuedBefore,omitempty"`
	Expand           *BillingInvoiceListParamsExpand           `form:"expand,omitempty" json:"expand,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *InvoiceOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *InvoiceOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// BillingListInvoicesByCustomerParams defines parameters for BillingListInvoicesByCustomer.
type BillingListInvoicesByCustomerParams struct {
	Statuses         *BillingInvoiceListParamsStatuses         `form:"statuses,omitempty" json:"statuses,omitempty"`
	ExtendedStatuses *BillingInvoiceListParamsExtendedStatuses `form:"extendedStatuses,omitempty" json:"extendedStatuses,omitempty"`
	IssuedAfter      *BillingInvoiceListParamsIssuedAfter      `form:"issuedAfter,omitempty" json:"issuedAfter,omitempty"`
	IssuedBefore     *BillingInvoiceListParamsIssuedBefore     `form:"issuedBefore,omitempty" json:"issuedBefore,omitempty"`
	Expand           *BillingInvoiceListParamsExpand           `form:"expand,omitempty" json:"expand,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *InvoiceOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *InvoiceOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// BillingGetInvoiceByCustomerInvoiceIdParams defines parameters for BillingGetInvoiceByCustomerInvoiceId.
type BillingGetInvoiceByCustomerInvoiceIdParams struct {
	Expand []BillingInvoiceExpand `form:"expand" json:"expand"`
}

// BillingListProfilesParams defines parameters for BillingListProfiles.
type BillingListProfilesParams struct {
	IncludeArchived *bool                   `form:"includeArchived,omitempty" json:"includeArchived,omitempty"`
	Expand          *[]BillingProfileExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *ProfileOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *ProfileOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// BillingGetProfileParams defines parameters for BillingGetProfile.
type BillingGetProfileParams struct {
	Expand *[]BillingProfileExpand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListCustomersParams defines parameters for ListCustomers.
type ListCustomersParams struct {
	// Page The page number.
	Page *PaginatedQueryPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items in the page.
	PageSize *PaginatedQueryPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *CustomerOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *CustomerOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`

	// IncludeDeleted Include deleted customers.
	IncludeDeleted *QueryCustomerListIncludeDeleted `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Name Filter customers by name.
	// Case-insensitive partial match.
	Name *QueryCustomerListName `form:"name,omitempty" json:"name,omitempty"`

	// PrimaryEmail Filter customers by primary email.
	// Case-insensitive partial match.
	PrimaryEmail *QueryCustomerListPrimaryEmail `form:"primaryEmail,omitempty" json:"primaryEmail,omitempty"`

	// Subject Filter customers by usage attribution subject.
	// Case-insensitive partial match.
	Subject *QueryCustomerListSubject `form:"subject,omitempty" json:"subject,omitempty"`
}

// ListEntitlementsParams defines parameters for ListEntitlements.
type ListEntitlementsParams struct {
	// Feature Filtering by multiple features.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Subject Filtering by multiple subjects.
	//
	// Usage: `?subject=customer-1&subject=customer-2`
	Subject *[]string `form:"subject,omitempty" json:"subject,omitempty"`

	// EntitlementType Filtering by multiple entitlement types.
	//
	// Usage: `?entitlementType=metered&entitlementType=boolean`
	EntitlementType *[]EntitlementType `form:"entitlementType,omitempty" json:"entitlementType,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *EntitlementOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *EntitlementOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListEventsParams defines parameters for ListEvents.
type ListEventsParams struct {
	// IngestedAtFrom Start date-time in RFC 3339 format.
	//
	// Inclusive.
	IngestedAtFrom *time.Time `form:"ingestedAtFrom,omitempty" json:"ingestedAtFrom,omitempty"`

	// IngestedAtTo End date-time in RFC 3339 format.
	//
	// Inclusive.
	IngestedAtTo *time.Time `form:"ingestedAtTo,omitempty" json:"ingestedAtTo,omitempty"`

	// HasError If not provided lists all events.
	//
	// If provided with true, only list events with processing error.
	//
	// If provided with false, only list events without processing error.
	HasError *bool `form:"hasError,omitempty" json:"hasError,omitempty"`

	// Id The event ID.
	//
	// Accepts partial ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Subject The event subject.
	//
	// Accepts partial subject.
	Subject *string `form:"subject,omitempty" json:"subject,omitempty"`

	// From Start date-time in RFC 3339 format.
	//
	// Inclusive.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	//
	// Inclusive.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Limit Number of events to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// IngestEventsApplicationCloudeventsBatchPlusJSONBody defines parameters for IngestEvents.
type IngestEventsApplicationCloudeventsBatchPlusJSONBody = []Event

// ListFeaturesParams defines parameters for ListFeatures.
type ListFeaturesParams struct {
	// MeterSlug Filter by meterSlug
	MeterSlug *[]string `form:"meterSlug,omitempty" json:"meterSlug,omitempty"`

	// IncludeArchived Filter by meterGroupByFilters
	IncludeArchived *bool `form:"includeArchived,omitempty" json:"includeArchived,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *FeatureOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *FeatureOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListGrantsParams defines parameters for ListGrants.
type ListGrantsParams struct {
	// Feature Filtering by multiple features.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Subject Filtering by multiple subjects.
	//
	// Usage: `?subject=customer-1&subject=customer-2`
	Subject *[]string `form:"subject,omitempty" json:"subject,omitempty"`

	// IncludeDeleted Include deleted
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Offset Number of items to skip.
	//
	// Default is 0.
	Offset *LimitOffsetOffset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of items to return.
	//
	// Default is 100.
	Limit *LimitOffsetLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The order direction.
	Order *GrantOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *GrantOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListMarketplaceListingsParams defines parameters for ListMarketplaceListings.
type ListMarketplaceListingsParams struct {
	// Page The page number.
	Page *PaginatedQueryPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items in the page.
	PageSize *PaginatedQueryPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// MarketplaceAppAPIKeyInstallJSONBody defines parameters for MarketplaceAppAPIKeyInstall.
type MarketplaceAppAPIKeyInstallJSONBody struct {
	// ApiKey The API key for the provider.
	// For example, the Stripe API key.
	ApiKey string `json:"apiKey"`

	// Name Name of the application to install.
	//
	// If not set defaults to the marketplace item's description.
	Name *string `json:"name,omitempty"`
}

// MarketplaceOAuth2InstallAuthorizeParams defines parameters for MarketplaceOAuth2InstallAuthorize.
type MarketplaceOAuth2InstallAuthorizeParams struct {
	// State Required if the "state" parameter was present in the client authorization request.
	// The exact value received from the client:
	//
	// Unique, randomly generated, opaque, and non-guessable string that is sent
	// when starting an authentication request and validated when processing the response.
	State *OAuth2AuthorizationCodeGrantSuccessParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Code Authorization code which the client will later exchange for an access token.
	// Required with the success response.
	Code *OAuth2AuthorizationCodeGrantSuccessParamsCode `form:"code,omitempty" json:"code,omitempty"`

	// Error Error code.
	// Required with the error response.
	Error *OAuth2AuthorizationCodeGrantErrorParamsError `form:"error,omitempty" json:"error,omitempty"`

	// ErrorDescription Optional human-readable text providing additional information,
	// used to assist the client developer in understanding the error that occurred.
	ErrorDescription *OAuth2AuthorizationCodeGrantErrorParamsErrorDescription `form:"error_description,omitempty" json:"error_description,omitempty"`

	// ErrorUri Optional uri identifying a human-readable web page with
	// information about the error, used to provide the client
	// developer with additional information about the error
	ErrorUri *OAuth2AuthorizationCodeGrantErrorParamsErrorUri `form:"error_uri,omitempty" json:"error_uri,omitempty"`
}

// QueryMeterParams defines parameters for QueryMeter.
type QueryMeterParams struct {
	// From Start date-time in RFC 3339 format.
	//
	// Inclusive.
	From *MeterQueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	//
	// Inclusive.
	To *MeterQueryTo `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.
	WindowSize *MeterQueryWindowSize `form:"windowSize,omitempty" json:"windowSize,omitempty"`

	// WindowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
	// If not specified, the UTC timezone will be used.
	WindowTimeZone *MeterQueryWindowTimeZone `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`

	// Subject Filtering by multiple subjects.
	Subject *MeterQuerySubject `form:"subject,omitempty" json:"subject,omitempty"`

	// FilterGroupBy Simple filter for group bys with exact match.
	FilterGroupBy *MeterQueryFilterGroupBy `json:"filterGroupBy,omitempty"`

	// GroupBy If not specified a single aggregate will be returned for each subject and time window.
	// `subject` is a reserved group by value.
	GroupBy *MeterQueryGroupBy `form:"groupBy,omitempty" json:"groupBy,omitempty"`
}

// ListNotificationChannelsParams defines parameters for ListNotificationChannels.
type ListNotificationChannelsParams struct {
	// IncludeDeleted Include deleted notification channels in response.
	//
	// Usage: `?includeDeleted=true`
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// IncludeDisabled Include disabled notification channels in response.
	//
	// Usage: `?includeDisabled=false`
	IncludeDisabled *bool `form:"includeDisabled,omitempty" json:"includeDisabled,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *NotificationChannelOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *NotificationChannelOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListNotificationEventsParams defines parameters for ListNotificationEvents.
type ListNotificationEventsParams struct {
	// From Start date-time in RFC 3339 format.
	// Inclusive.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	// Inclusive.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Feature Filtering by multiple feature ids or keys.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Subject Filtering by multiple subject ids or keys.
	//
	// Usage: `?subject=subject-1&subject=subject-2`
	Subject *[]string `form:"subject,omitempty" json:"subject,omitempty"`

	// Rule Filtering by multiple rule ids.
	//
	// Usage: `?rule=01J8J2XYZ2N5WBYK09EDZFBSZM&rule=01J8J4R4VZH180KRKQ63NB2VA5`
	Rule *[]string `form:"rule,omitempty" json:"rule,omitempty"`

	// Channel Filtering by multiple channel ids.
	//
	// Usage: `?channel=01J8J4RXH778XB056JS088PCYT&channel=01J8J4S1R1G9EVN62RG23A9M6J`
	Channel *[]string `form:"channel,omitempty" json:"channel,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *NotificationEventOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *NotificationEventOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListNotificationRulesParams defines parameters for ListNotificationRules.
type ListNotificationRulesParams struct {
	// IncludeDeleted Include deleted notification rules in response.
	//
	// Usage: `?includeDeleted=true`
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// IncludeDisabled Include disabled notification rules in response.
	//
	// Usage: `?includeDisabled=false`
	IncludeDisabled *bool `form:"includeDisabled,omitempty" json:"includeDisabled,omitempty"`

	// Feature Filtering by multiple feature ids/keys.
	//
	// Usage: `?feature=feature-1&feature=feature-2`
	Feature *[]string `form:"feature,omitempty" json:"feature,omitempty"`

	// Channel Filtering by multiple notifiaction channel ids.
	//
	// Usage: `?channel=01ARZ3NDEKTSV4RRFFQ69G5FAV&channel=01J8J2Y5X4NNGQS32CF81W95E3`
	Channel *[]string `form:"channel,omitempty" json:"channel,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *NotificationRuleOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *NotificationRuleOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// ListPlansParams defines parameters for ListPlans.
type ListPlansParams struct {
	// IncludeDeleted Include deleted plans in response.
	//
	// Usage: `?includeDeleted=true`
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`

	// Id Filter by plan.id attribute
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Key Filter by plan.key attribute
	Key *[]string `form:"key,omitempty" json:"key,omitempty"`

	// KeyVersion Filter by plan.key and plan.version attributes
	KeyVersion *map[string][]int `json:"keyVersion,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *PlanOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *PlanOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// GetPlanParams defines parameters for GetPlan.
type GetPlanParams struct {
	// IncludeLatest Include latest version of the Plan instead of the version in active state.
	//
	// Usage: `?includeLatest=true`
	IncludeLatest *bool `form:"includeLatest,omitempty" json:"includeLatest,omitempty"`
}

// ListPlanPhasesParams defines parameters for ListPlanPhases.
type ListPlanPhasesParams struct {
	// Key Filter by phase.key attribute
	Key *[]string `form:"key,omitempty" json:"key,omitempty"`

	// Page Start date-time in RFC 3339 format.
	//
	// Inclusive.
	Page *PaginationPage `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page.
	//
	// Default is 100.
	PageSize *PaginationPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Order The order direction.
	Order *PhasesOrderByOrderingOrder `form:"order,omitempty" json:"order,omitempty"`

	// OrderBy The order by field.
	OrderBy *PhasesOrderByOrderingOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// QueryPortalMeterParams defines parameters for QueryPortalMeter.
type QueryPortalMeterParams struct {
	// From Start date-time in RFC 3339 format.
	//
	// Inclusive.
	From *MeterQueryFrom `form:"from,omitempty" json:"from,omitempty"`

	// To End date-time in RFC 3339 format.
	//
	// Inclusive.
	To *MeterQueryTo `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group.
	WindowSize *MeterQueryWindowSize `form:"windowSize,omitempty" json:"windowSize,omitempty"`

	// WindowTimeZone The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
	// If not specified, the UTC timezone will be used.
	WindowTimeZone *MeterQueryWindowTimeZone `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`

	// FilterGroupBy Simple filter for group bys with exact match.
	FilterGroupBy *MeterQueryFilterGroupBy `json:"filterGroupBy,omitempty"`

	// GroupBy If not specified a single aggregate will be returned for each subject and time window.
	// `subject` is a reserved group by value.
	GroupBy *MeterQueryGroupBy `form:"groupBy,omitempty" json:"groupBy,omitempty"`
}

// ListPortalTokensParams defines parameters for ListPortalTokens.
type ListPortalTokensParams struct {
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListSubjectEntitlementsParams defines parameters for ListSubjectEntitlements.
type ListSubjectEntitlementsParams struct {
	IncludeDeleted *bool `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`
}

// ListEntitlementGrantsParams defines parameters for ListEntitlementGrants.
type ListEntitlementGrantsParams struct {
	IncludeDeleted *bool         `form:"includeDeleted,omitempty" json:"includeDeleted,omitempty"`
	OrderBy        *GrantOrderBy `form:"orderBy,omitempty" json:"orderBy,omitempty"`
}

// GetEntitlementValueParams defines parameters for GetEntitlementValue.
type GetEntitlementValueParams struct {
	Time *time.Time `form:"time,omitempty" json:"time,omitempty"`
}

// GetEntitlementHistoryParams defines parameters for GetEntitlementHistory.
type GetEntitlementHistoryParams struct {
	// From Start of time range to query entitlement: date-time in RFC 3339 format. Defaults to the last reset. Gets truncated to the granularity of the underlying meter.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To End of time range to query entitlement: date-time in RFC 3339 format. Defaults to now.
	// If not now then gets truncated to the granularity of the underlying meter.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// WindowSize Windowsize
	WindowSize WindowSize `form:"windowSize" json:"windowSize"`

	// WindowTimeZone The timezone used when calculating the windows.
	WindowTimeZone *string `form:"windowTimeZone,omitempty" json:"windowTimeZone,omitempty"`
}

// GetSubscriptionParams defines parameters for GetSubscription.
type GetSubscriptionParams struct {
	Expand *GetSubscriptionParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`

	// At The time at which the subscription should be queried. If not provided the current time is used.
	At *time.Time `form:"at,omitempty" json:"at,omitempty"`
}

// GetSubscriptionParamsExpand defines parameters for GetSubscription.
type GetSubscriptionParamsExpand bool

// EditSubscriptionJSONBody defines parameters for EditSubscription.
type EditSubscriptionJSONBody = []EditSubscriptionJSONBody_Item

// EditSubscriptionJSONBody_Item defines parameters for EditSubscription.
type EditSubscriptionJSONBody_Item struct {
	union json.RawMessage
}

// CancelSubscriptionJSONBody defines parameters for CancelSubscription.
type CancelSubscriptionJSONBody struct {
	// EffectiveDate If not provided the subscription is canceled immediately.
	EffectiveDate *time.Time `json:"effectiveDate,omitempty"`
}

// MigrateSubscriptionJSONBody defines parameters for MigrateSubscription.
type MigrateSubscriptionJSONBody struct {
	TargetVersion int `json:"targetVersion"`
}

// AppStripeWebhookJSONRequestBody defines body for AppStripeWebhook for application/json ContentType.
type AppStripeWebhookJSONRequestBody = StripeWebhookEvent

// BillingUpsertCustomerOverrideJSONRequestBody defines body for BillingUpsertCustomerOverride for application/json ContentType.
type BillingUpsertCustomerOverrideJSONRequestBody = BillingCustomerWorkflowOverrideCreate

// BillingCreateInvoiceJSONRequestBody defines body for BillingCreateInvoice for application/json ContentType.
type BillingCreateInvoiceJSONRequestBody = BillingInvoiceCreateInput

// BillingUpdateInvoiceLineJSONRequestBody defines body for BillingUpdateInvoiceLine for application/json ContentType.
type BillingUpdateInvoiceLineJSONRequestBody = BillingInvoiceLineCreateOrUpdate

// BillingVoidInvoiceJSONRequestBody defines body for BillingVoidInvoice for application/json ContentType.
type BillingVoidInvoiceJSONRequestBody = BillingVoidInvoiceInput

// BillingCreateLineByCustomerJSONRequestBody defines body for BillingCreateLineByCustomer for application/json ContentType.
type BillingCreateLineByCustomerJSONRequestBody = BillingCreateLinesRequest

// BillingCreateProfileJSONRequestBody defines body for BillingCreateProfile for application/json ContentType.
type BillingCreateProfileJSONRequestBody = BillingProfileCreateInput

// BillingUpdateProfileJSONRequestBody defines body for BillingUpdateProfile for application/json ContentType.
type BillingUpdateProfileJSONRequestBody = BillingProfileCreateOrUpdate

// CreateCustomerJSONRequestBody defines body for CreateCustomer for application/json ContentType.
type CreateCustomerJSONRequestBody = CustomerCreate

// UpdateCustomerJSONRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody = CustomerReplaceUpdate

// IngestEventsApplicationCloudeventsPlusJSONRequestBody defines body for IngestEvents for application/cloudevents+json ContentType.
type IngestEventsApplicationCloudeventsPlusJSONRequestBody = Event

// IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody defines body for IngestEvents for application/cloudevents-batch+json ContentType.
type IngestEventsApplicationCloudeventsBatchPlusJSONRequestBody = IngestEventsApplicationCloudeventsBatchPlusJSONBody

// IngestEventsJSONRequestBody defines body for IngestEvents for application/json ContentType.
type IngestEventsJSONRequestBody = IngestEventsBody

// CreateFeatureJSONRequestBody defines body for CreateFeature for application/json ContentType.
type CreateFeatureJSONRequestBody = FeatureCreateInputs

// CreateStripeCheckoutSessionJSONRequestBody defines body for CreateStripeCheckoutSession for application/json ContentType.
type CreateStripeCheckoutSessionJSONRequestBody = CreateStripeCheckoutSessionRequest

// MarketplaceAppAPIKeyInstallJSONRequestBody defines body for MarketplaceAppAPIKeyInstall for application/json ContentType.
type MarketplaceAppAPIKeyInstallJSONRequestBody MarketplaceAppAPIKeyInstallJSONBody

// CreateNotificationChannelJSONRequestBody defines body for CreateNotificationChannel for application/json ContentType.
type CreateNotificationChannelJSONRequestBody = NotificationChannelCreateRequest

// UpdateNotificationChannelJSONRequestBody defines body for UpdateNotificationChannel for application/json ContentType.
type UpdateNotificationChannelJSONRequestBody = NotificationChannelCreateRequest

// CreateNotificationRuleJSONRequestBody defines body for CreateNotificationRule for application/json ContentType.
type CreateNotificationRuleJSONRequestBody = NotificationRuleCreateRequest

// UpdateNotificationRuleJSONRequestBody defines body for UpdateNotificationRule for application/json ContentType.
type UpdateNotificationRuleJSONRequestBody = NotificationRuleCreateRequest

// ReceiveSvixOperationalEventJSONRequestBody defines body for ReceiveSvixOperationalEvent for application/json ContentType.
type ReceiveSvixOperationalEventJSONRequestBody = SvixOperationalWebhookRequest

// CreatePlanJSONRequestBody defines body for CreatePlan for application/json ContentType.
type CreatePlanJSONRequestBody = PlanCreate

// UpdatePlanJSONRequestBody defines body for UpdatePlan for application/json ContentType.
type UpdatePlanJSONRequestBody = PlanReplaceUpdate

// CreatePlanPhaseJSONRequestBody defines body for CreatePlanPhase for application/json ContentType.
type CreatePlanPhaseJSONRequestBody = PlanPhaseCreate

// UpdatePlanPhaseJSONRequestBody defines body for UpdatePlanPhase for application/json ContentType.
type UpdatePlanPhaseJSONRequestBody = PlanPhaseUpdate

// CreatePortalTokenJSONRequestBody defines body for CreatePortalToken for application/json ContentType.
type CreatePortalTokenJSONRequestBody = PortalToken

// CreateEntitlementJSONRequestBody defines body for CreateEntitlement for application/json ContentType.
type CreateEntitlementJSONRequestBody = EntitlementCreateInputs

// CreateGrantJSONRequestBody defines body for CreateGrant for application/json ContentType.
type CreateGrantJSONRequestBody = EntitlementGrantCreateInput

// OverrideEntitlementJSONRequestBody defines body for OverrideEntitlement for application/json ContentType.
type OverrideEntitlementJSONRequestBody = EntitlementCreateInputs

// ResetEntitlementUsageJSONRequestBody defines body for ResetEntitlementUsage for application/json ContentType.
type ResetEntitlementUsageJSONRequestBody = ResetEntitlementUsageInput

// CreateSubscriptionJSONRequestBody defines body for CreateSubscription for application/json ContentType.
type CreateSubscriptionJSONRequestBody = CreateSubscriptionRequestBody

// EditSubscriptionJSONRequestBody defines body for EditSubscription for application/json ContentType.
type EditSubscriptionJSONRequestBody = EditSubscriptionJSONBody

// CancelSubscriptionJSONRequestBody defines body for CancelSubscription for application/json ContentType.
type CancelSubscriptionJSONRequestBody CancelSubscriptionJSONBody

// MigrateSubscriptionJSONRequestBody defines body for MigrateSubscription for application/json ContentType.
type MigrateSubscriptionJSONRequestBody MigrateSubscriptionJSONBody

// AsStripeApp returns the union data inside the App as a StripeApp
func (t App) AsStripeApp() (StripeApp, error) {
	var body StripeApp
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStripeApp overwrites any union data inside the App as the provided StripeApp
func (t *App) FromStripeApp(v StripeApp) error {
	v.Type = "stripe"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStripeApp performs a merge with any union data inside the App, using the provided StripeApp
func (t *App) MergeStripeApp(v StripeApp) error {
	v.Type = "stripe"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxApp returns the union data inside the App as a SandboxApp
func (t App) AsSandboxApp() (SandboxApp, error) {
	var body SandboxApp
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxApp overwrites any union data inside the App as the provided SandboxApp
func (t *App) FromSandboxApp(v SandboxApp) error {
	v.Type = "sandbox"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxApp performs a merge with any union data inside the App, using the provided SandboxApp
func (t *App) MergeSandboxApp(v SandboxApp) error {
	v.Type = "sandbox"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t App) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t App) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "sandbox":
		return t.AsSandboxApp()
	case "stripe":
		return t.AsStripeApp()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t App) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *App) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingUsageBasedLine returns the union data inside the BillingInvoiceLine as a BillingUsageBasedLine
func (t BillingInvoiceLine) AsBillingUsageBasedLine() (BillingUsageBasedLine, error) {
	var body BillingUsageBasedLine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingUsageBasedLine overwrites any union data inside the BillingInvoiceLine as the provided BillingUsageBasedLine
func (t *BillingInvoiceLine) FromBillingUsageBasedLine(v BillingUsageBasedLine) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingUsageBasedLine performs a merge with any union data inside the BillingInvoiceLine, using the provided BillingUsageBasedLine
func (t *BillingInvoiceLine) MergeBillingUsageBasedLine(v BillingUsageBasedLine) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingFlatFeeLine returns the union data inside the BillingInvoiceLine as a BillingFlatFeeLine
func (t BillingInvoiceLine) AsBillingFlatFeeLine() (BillingFlatFeeLine, error) {
	var body BillingFlatFeeLine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingFlatFeeLine overwrites any union data inside the BillingInvoiceLine as the provided BillingFlatFeeLine
func (t *BillingInvoiceLine) FromBillingFlatFeeLine(v BillingFlatFeeLine) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingFlatFeeLine performs a merge with any union data inside the BillingInvoiceLine, using the provided BillingFlatFeeLine
func (t *BillingInvoiceLine) MergeBillingFlatFeeLine(v BillingFlatFeeLine) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BillingInvoiceLine) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BillingInvoiceLine) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat_fee":
		return t.AsBillingFlatFeeLine()
	case "usage_based":
		return t.AsBillingUsageBasedLine()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BillingInvoiceLine) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BillingInvoiceLine) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingUsageBasedLineCreateItem returns the union data inside the BillingInvoiceLineCreateItem as a BillingUsageBasedLineCreateItem
func (t BillingInvoiceLineCreateItem) AsBillingUsageBasedLineCreateItem() (BillingUsageBasedLineCreateItem, error) {
	var body BillingUsageBasedLineCreateItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingUsageBasedLineCreateItem overwrites any union data inside the BillingInvoiceLineCreateItem as the provided BillingUsageBasedLineCreateItem
func (t *BillingInvoiceLineCreateItem) FromBillingUsageBasedLineCreateItem(v BillingUsageBasedLineCreateItem) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingUsageBasedLineCreateItem performs a merge with any union data inside the BillingInvoiceLineCreateItem, using the provided BillingUsageBasedLineCreateItem
func (t *BillingInvoiceLineCreateItem) MergeBillingUsageBasedLineCreateItem(v BillingUsageBasedLineCreateItem) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingFlatFeeLineCreateItem returns the union data inside the BillingInvoiceLineCreateItem as a BillingFlatFeeLineCreateItem
func (t BillingInvoiceLineCreateItem) AsBillingFlatFeeLineCreateItem() (BillingFlatFeeLineCreateItem, error) {
	var body BillingFlatFeeLineCreateItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingFlatFeeLineCreateItem overwrites any union data inside the BillingInvoiceLineCreateItem as the provided BillingFlatFeeLineCreateItem
func (t *BillingInvoiceLineCreateItem) FromBillingFlatFeeLineCreateItem(v BillingFlatFeeLineCreateItem) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingFlatFeeLineCreateItem performs a merge with any union data inside the BillingInvoiceLineCreateItem, using the provided BillingFlatFeeLineCreateItem
func (t *BillingInvoiceLineCreateItem) MergeBillingFlatFeeLineCreateItem(v BillingFlatFeeLineCreateItem) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BillingInvoiceLineCreateItem) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BillingInvoiceLineCreateItem) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat_fee":
		return t.AsBillingFlatFeeLineCreateItem()
	case "usage_based":
		return t.AsBillingUsageBasedLineCreateItem()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BillingInvoiceLineCreateItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BillingInvoiceLineCreateItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingUsageBasedLineCreateOrUpdate returns the union data inside the BillingInvoiceLineCreateOrUpdate as a BillingUsageBasedLineCreateOrUpdate
func (t BillingInvoiceLineCreateOrUpdate) AsBillingUsageBasedLineCreateOrUpdate() (BillingUsageBasedLineCreateOrUpdate, error) {
	var body BillingUsageBasedLineCreateOrUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingUsageBasedLineCreateOrUpdate overwrites any union data inside the BillingInvoiceLineCreateOrUpdate as the provided BillingUsageBasedLineCreateOrUpdate
func (t *BillingInvoiceLineCreateOrUpdate) FromBillingUsageBasedLineCreateOrUpdate(v BillingUsageBasedLineCreateOrUpdate) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingUsageBasedLineCreateOrUpdate performs a merge with any union data inside the BillingInvoiceLineCreateOrUpdate, using the provided BillingUsageBasedLineCreateOrUpdate
func (t *BillingInvoiceLineCreateOrUpdate) MergeBillingUsageBasedLineCreateOrUpdate(v BillingUsageBasedLineCreateOrUpdate) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingFlatFeeLineCreateOrUpdate returns the union data inside the BillingInvoiceLineCreateOrUpdate as a BillingFlatFeeLineCreateOrUpdate
func (t BillingInvoiceLineCreateOrUpdate) AsBillingFlatFeeLineCreateOrUpdate() (BillingFlatFeeLineCreateOrUpdate, error) {
	var body BillingFlatFeeLineCreateOrUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingFlatFeeLineCreateOrUpdate overwrites any union data inside the BillingInvoiceLineCreateOrUpdate as the provided BillingFlatFeeLineCreateOrUpdate
func (t *BillingInvoiceLineCreateOrUpdate) FromBillingFlatFeeLineCreateOrUpdate(v BillingFlatFeeLineCreateOrUpdate) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingFlatFeeLineCreateOrUpdate performs a merge with any union data inside the BillingInvoiceLineCreateOrUpdate, using the provided BillingFlatFeeLineCreateOrUpdate
func (t *BillingInvoiceLineCreateOrUpdate) MergeBillingFlatFeeLineCreateOrUpdate(v BillingFlatFeeLineCreateOrUpdate) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BillingInvoiceLineCreateOrUpdate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BillingInvoiceLineCreateOrUpdate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat_fee":
		return t.AsBillingFlatFeeLineCreateOrUpdate()
	case "usage_based":
		return t.AsBillingUsageBasedLineCreateOrUpdate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BillingInvoiceLineCreateOrUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BillingInvoiceLineCreateOrUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingPaymentTermInstant returns the union data inside the BillingPaymentTerms as a BillingPaymentTermInstant
func (t BillingPaymentTerms) AsBillingPaymentTermInstant() (BillingPaymentTermInstant, error) {
	var body BillingPaymentTermInstant
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingPaymentTermInstant overwrites any union data inside the BillingPaymentTerms as the provided BillingPaymentTermInstant
func (t *BillingPaymentTerms) FromBillingPaymentTermInstant(v BillingPaymentTermInstant) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingPaymentTermInstant performs a merge with any union data inside the BillingPaymentTerms, using the provided BillingPaymentTermInstant
func (t *BillingPaymentTerms) MergeBillingPaymentTermInstant(v BillingPaymentTermInstant) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingPaymentTermDueDate returns the union data inside the BillingPaymentTerms as a BillingPaymentTermDueDate
func (t BillingPaymentTerms) AsBillingPaymentTermDueDate() (BillingPaymentTermDueDate, error) {
	var body BillingPaymentTermDueDate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingPaymentTermDueDate overwrites any union data inside the BillingPaymentTerms as the provided BillingPaymentTermDueDate
func (t *BillingPaymentTerms) FromBillingPaymentTermDueDate(v BillingPaymentTermDueDate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingPaymentTermDueDate performs a merge with any union data inside the BillingPaymentTerms, using the provided BillingPaymentTermDueDate
func (t *BillingPaymentTerms) MergeBillingPaymentTermDueDate(v BillingPaymentTermDueDate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BillingPaymentTerms) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BillingPaymentTerms) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingProfileApps returns the union data inside the BillingProfileAppsOrReference as a BillingProfileApps
func (t BillingProfileAppsOrReference) AsBillingProfileApps() (BillingProfileApps, error) {
	var body BillingProfileApps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingProfileApps overwrites any union data inside the BillingProfileAppsOrReference as the provided BillingProfileApps
func (t *BillingProfileAppsOrReference) FromBillingProfileApps(v BillingProfileApps) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingProfileApps performs a merge with any union data inside the BillingProfileAppsOrReference, using the provided BillingProfileApps
func (t *BillingProfileAppsOrReference) MergeBillingProfileApps(v BillingProfileApps) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingProfileAppReferences returns the union data inside the BillingProfileAppsOrReference as a BillingProfileAppReferences
func (t BillingProfileAppsOrReference) AsBillingProfileAppReferences() (BillingProfileAppReferences, error) {
	var body BillingProfileAppReferences
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingProfileAppReferences overwrites any union data inside the BillingProfileAppsOrReference as the provided BillingProfileAppReferences
func (t *BillingProfileAppsOrReference) FromBillingProfileAppReferences(v BillingProfileAppReferences) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingProfileAppReferences performs a merge with any union data inside the BillingProfileAppsOrReference, using the provided BillingProfileAppReferences
func (t *BillingProfileAppsOrReference) MergeBillingProfileAppReferences(v BillingProfileAppReferences) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BillingProfileAppsOrReference) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BillingProfileAppsOrReference) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCustomerId returns the union data inside the CreateStripeCheckoutSessionRequest_Customer as a CustomerId
func (t CreateStripeCheckoutSessionRequest_Customer) AsCustomerId() (CustomerId, error) {
	var body CustomerId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerId overwrites any union data inside the CreateStripeCheckoutSessionRequest_Customer as the provided CustomerId
func (t *CreateStripeCheckoutSessionRequest_Customer) FromCustomerId(v CustomerId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerId performs a merge with any union data inside the CreateStripeCheckoutSessionRequest_Customer, using the provided CustomerId
func (t *CreateStripeCheckoutSessionRequest_Customer) MergeCustomerId(v CustomerId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerCreate returns the union data inside the CreateStripeCheckoutSessionRequest_Customer as a CustomerCreate
func (t CreateStripeCheckoutSessionRequest_Customer) AsCustomerCreate() (CustomerCreate, error) {
	var body CustomerCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerCreate overwrites any union data inside the CreateStripeCheckoutSessionRequest_Customer as the provided CustomerCreate
func (t *CreateStripeCheckoutSessionRequest_Customer) FromCustomerCreate(v CustomerCreate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerCreate performs a merge with any union data inside the CreateStripeCheckoutSessionRequest_Customer, using the provided CustomerCreate
func (t *CreateStripeCheckoutSessionRequest_Customer) MergeCustomerCreate(v CustomerCreate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateStripeCheckoutSessionRequest_Customer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateStripeCheckoutSessionRequest_Customer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSubscriptionEditAddItem returns the union data inside the CreateSubscriptionRequestBody_Customizations_Item as a SubscriptionEditAddItem
func (t CreateSubscriptionRequestBody_Customizations_Item) AsSubscriptionEditAddItem() (SubscriptionEditAddItem, error) {
	var body SubscriptionEditAddItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubscriptionEditAddItem overwrites any union data inside the CreateSubscriptionRequestBody_Customizations_Item as the provided SubscriptionEditAddItem
func (t *CreateSubscriptionRequestBody_Customizations_Item) FromSubscriptionEditAddItem(v SubscriptionEditAddItem) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubscriptionEditAddItem performs a merge with any union data inside the CreateSubscriptionRequestBody_Customizations_Item, using the provided SubscriptionEditAddItem
func (t *CreateSubscriptionRequestBody_Customizations_Item) MergeSubscriptionEditAddItem(v SubscriptionEditAddItem) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubscriptionEditRemoveItem returns the union data inside the CreateSubscriptionRequestBody_Customizations_Item as a SubscriptionEditRemoveItem
func (t CreateSubscriptionRequestBody_Customizations_Item) AsSubscriptionEditRemoveItem() (SubscriptionEditRemoveItem, error) {
	var body SubscriptionEditRemoveItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubscriptionEditRemoveItem overwrites any union data inside the CreateSubscriptionRequestBody_Customizations_Item as the provided SubscriptionEditRemoveItem
func (t *CreateSubscriptionRequestBody_Customizations_Item) FromSubscriptionEditRemoveItem(v SubscriptionEditRemoveItem) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubscriptionEditRemoveItem performs a merge with any union data inside the CreateSubscriptionRequestBody_Customizations_Item, using the provided SubscriptionEditRemoveItem
func (t *CreateSubscriptionRequestBody_Customizations_Item) MergeSubscriptionEditRemoveItem(v SubscriptionEditRemoveItem) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateSubscriptionRequestBody_Customizations_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateSubscriptionRequestBody_Customizations_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEntitlementMetered returns the union data inside the Entitlement as a EntitlementMetered
func (t Entitlement) AsEntitlementMetered() (EntitlementMetered, error) {
	var body EntitlementMetered
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementMetered overwrites any union data inside the Entitlement as the provided EntitlementMetered
func (t *Entitlement) FromEntitlementMetered(v EntitlementMetered) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementMetered performs a merge with any union data inside the Entitlement, using the provided EntitlementMetered
func (t *Entitlement) MergeEntitlementMetered(v EntitlementMetered) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementStatic returns the union data inside the Entitlement as a EntitlementStatic
func (t Entitlement) AsEntitlementStatic() (EntitlementStatic, error) {
	var body EntitlementStatic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementStatic overwrites any union data inside the Entitlement as the provided EntitlementStatic
func (t *Entitlement) FromEntitlementStatic(v EntitlementStatic) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementStatic performs a merge with any union data inside the Entitlement, using the provided EntitlementStatic
func (t *Entitlement) MergeEntitlementStatic(v EntitlementStatic) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementBoolean returns the union data inside the Entitlement as a EntitlementBoolean
func (t Entitlement) AsEntitlementBoolean() (EntitlementBoolean, error) {
	var body EntitlementBoolean
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementBoolean overwrites any union data inside the Entitlement as the provided EntitlementBoolean
func (t *Entitlement) FromEntitlementBoolean(v EntitlementBoolean) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementBoolean performs a merge with any union data inside the Entitlement, using the provided EntitlementBoolean
func (t *Entitlement) MergeEntitlementBoolean(v EntitlementBoolean) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Entitlement) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Entitlement) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsEntitlementBoolean()
	case "metered":
		return t.AsEntitlementMetered()
	case "static":
		return t.AsEntitlementStatic()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Entitlement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Entitlement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEntitlementMeteredCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementMeteredCreateInputs
func (t EntitlementCreateInputs) AsEntitlementMeteredCreateInputs() (EntitlementMeteredCreateInputs, error) {
	var body EntitlementMeteredCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementMeteredCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementMeteredCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementMeteredCreateInputs(v EntitlementMeteredCreateInputs) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementMeteredCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementMeteredCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementMeteredCreateInputs(v EntitlementMeteredCreateInputs) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementStaticCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementStaticCreateInputs
func (t EntitlementCreateInputs) AsEntitlementStaticCreateInputs() (EntitlementStaticCreateInputs, error) {
	var body EntitlementStaticCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementStaticCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementStaticCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementStaticCreateInputs(v EntitlementStaticCreateInputs) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementStaticCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementStaticCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementStaticCreateInputs(v EntitlementStaticCreateInputs) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementBooleanCreateInputs returns the union data inside the EntitlementCreateInputs as a EntitlementBooleanCreateInputs
func (t EntitlementCreateInputs) AsEntitlementBooleanCreateInputs() (EntitlementBooleanCreateInputs, error) {
	var body EntitlementBooleanCreateInputs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementBooleanCreateInputs overwrites any union data inside the EntitlementCreateInputs as the provided EntitlementBooleanCreateInputs
func (t *EntitlementCreateInputs) FromEntitlementBooleanCreateInputs(v EntitlementBooleanCreateInputs) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementBooleanCreateInputs performs a merge with any union data inside the EntitlementCreateInputs, using the provided EntitlementBooleanCreateInputs
func (t *EntitlementCreateInputs) MergeEntitlementBooleanCreateInputs(v EntitlementBooleanCreateInputs) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntitlementCreateInputs) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EntitlementCreateInputs) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsEntitlementBooleanCreateInputs()
	case "metered":
		return t.AsEntitlementMeteredCreateInputs()
	case "static":
		return t.AsEntitlementStaticCreateInputs()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EntitlementCreateInputs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntitlementCreateInputs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEvent returns the union data inside the IngestEventsBody as a Event
func (t IngestEventsBody) AsEvent() (Event, error) {
	var body Event
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEvent overwrites any union data inside the IngestEventsBody as the provided Event
func (t *IngestEventsBody) FromEvent(v Event) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEvent performs a merge with any union data inside the IngestEventsBody, using the provided Event
func (t *IngestEventsBody) MergeEvent(v Event) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIngestEventsBody1 returns the union data inside the IngestEventsBody as a IngestEventsBody1
func (t IngestEventsBody) AsIngestEventsBody1() (IngestEventsBody1, error) {
	var body IngestEventsBody1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIngestEventsBody1 overwrites any union data inside the IngestEventsBody as the provided IngestEventsBody1
func (t *IngestEventsBody) FromIngestEventsBody1(v IngestEventsBody1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIngestEventsBody1 performs a merge with any union data inside the IngestEventsBody, using the provided IngestEventsBody1
func (t *IngestEventsBody) MergeIngestEventsBody1(v IngestEventsBody1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IngestEventsBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IngestEventsBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsListEntitlementsResult0 returns the union data inside the ListEntitlementsResult as a ListEntitlementsResult0
func (t ListEntitlementsResult) AsListEntitlementsResult0() (ListEntitlementsResult0, error) {
	var body ListEntitlementsResult0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListEntitlementsResult0 overwrites any union data inside the ListEntitlementsResult as the provided ListEntitlementsResult0
func (t *ListEntitlementsResult) FromListEntitlementsResult0(v ListEntitlementsResult0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListEntitlementsResult0 performs a merge with any union data inside the ListEntitlementsResult, using the provided ListEntitlementsResult0
func (t *ListEntitlementsResult) MergeListEntitlementsResult0(v ListEntitlementsResult0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitlementPaginatedResponse returns the union data inside the ListEntitlementsResult as a EntitlementPaginatedResponse
func (t ListEntitlementsResult) AsEntitlementPaginatedResponse() (EntitlementPaginatedResponse, error) {
	var body EntitlementPaginatedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitlementPaginatedResponse overwrites any union data inside the ListEntitlementsResult as the provided EntitlementPaginatedResponse
func (t *ListEntitlementsResult) FromEntitlementPaginatedResponse(v EntitlementPaginatedResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitlementPaginatedResponse performs a merge with any union data inside the ListEntitlementsResult, using the provided EntitlementPaginatedResponse
func (t *ListEntitlementsResult) MergeEntitlementPaginatedResponse(v EntitlementPaginatedResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ListEntitlementsResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ListEntitlementsResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsListFeaturesResult0 returns the union data inside the ListFeaturesResult as a ListFeaturesResult0
func (t ListFeaturesResult) AsListFeaturesResult0() (ListFeaturesResult0, error) {
	var body ListFeaturesResult0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromListFeaturesResult0 overwrites any union data inside the ListFeaturesResult as the provided ListFeaturesResult0
func (t *ListFeaturesResult) FromListFeaturesResult0(v ListFeaturesResult0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeListFeaturesResult0 performs a merge with any union data inside the ListFeaturesResult, using the provided ListFeaturesResult0
func (t *ListFeaturesResult) MergeListFeaturesResult0(v ListFeaturesResult0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeaturePaginatedResponse returns the union data inside the ListFeaturesResult as a FeaturePaginatedResponse
func (t ListFeaturesResult) AsFeaturePaginatedResponse() (FeaturePaginatedResponse, error) {
	var body FeaturePaginatedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeaturePaginatedResponse overwrites any union data inside the ListFeaturesResult as the provided FeaturePaginatedResponse
func (t *ListFeaturesResult) FromFeaturePaginatedResponse(v FeaturePaginatedResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeaturePaginatedResponse performs a merge with any union data inside the ListFeaturesResult, using the provided FeaturePaginatedResponse
func (t *ListFeaturesResult) MergeFeaturePaginatedResponse(v FeaturePaginatedResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ListFeaturesResult) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ListFeaturesResult) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMeasureUsageFromPreset returns the union data inside the MeasureUsageFrom as a MeasureUsageFromPreset
func (t MeasureUsageFrom) AsMeasureUsageFromPreset() (MeasureUsageFromPreset, error) {
	var body MeasureUsageFromPreset
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeasureUsageFromPreset overwrites any union data inside the MeasureUsageFrom as the provided MeasureUsageFromPreset
func (t *MeasureUsageFrom) FromMeasureUsageFromPreset(v MeasureUsageFromPreset) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeasureUsageFromPreset performs a merge with any union data inside the MeasureUsageFrom, using the provided MeasureUsageFromPreset
func (t *MeasureUsageFrom) MergeMeasureUsageFromPreset(v MeasureUsageFromPreset) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMeasureUsageFromTime returns the union data inside the MeasureUsageFrom as a MeasureUsageFromTime
func (t MeasureUsageFrom) AsMeasureUsageFromTime() (MeasureUsageFromTime, error) {
	var body MeasureUsageFromTime
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeasureUsageFromTime overwrites any union data inside the MeasureUsageFrom as the provided MeasureUsageFromTime
func (t *MeasureUsageFrom) FromMeasureUsageFromTime(v MeasureUsageFromTime) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeasureUsageFromTime performs a merge with any union data inside the MeasureUsageFrom, using the provided MeasureUsageFromTime
func (t *MeasureUsageFrom) MergeMeasureUsageFromTime(v MeasureUsageFromTime) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MeasureUsageFrom) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MeasureUsageFrom) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRateCardFlatFee returns the union data inside the RateCard as a RateCardFlatFee
func (t RateCard) AsRateCardFlatFee() (RateCardFlatFee, error) {
	var body RateCardFlatFee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardFlatFee overwrites any union data inside the RateCard as the provided RateCardFlatFee
func (t *RateCard) FromRateCardFlatFee(v RateCardFlatFee) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardFlatFee performs a merge with any union data inside the RateCard, using the provided RateCardFlatFee
func (t *RateCard) MergeRateCardFlatFee(v RateCardFlatFee) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRateCardUsageBased returns the union data inside the RateCard as a RateCardUsageBased
func (t RateCard) AsRateCardUsageBased() (RateCardUsageBased, error) {
	var body RateCardUsageBased
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardUsageBased overwrites any union data inside the RateCard as the provided RateCardUsageBased
func (t *RateCard) FromRateCardUsageBased(v RateCardUsageBased) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardUsageBased performs a merge with any union data inside the RateCard, using the provided RateCardUsageBased
func (t *RateCard) MergeRateCardUsageBased(v RateCardUsageBased) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RateCard) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RateCard) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat_fee":
		return t.AsRateCardFlatFee()
	case "usage_based":
		return t.AsRateCardUsageBased()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RateCard) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RateCard) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRateCardMeteredEntitlement returns the union data inside the RateCardEntitlement as a RateCardMeteredEntitlement
func (t RateCardEntitlement) AsRateCardMeteredEntitlement() (RateCardMeteredEntitlement, error) {
	var body RateCardMeteredEntitlement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardMeteredEntitlement overwrites any union data inside the RateCardEntitlement as the provided RateCardMeteredEntitlement
func (t *RateCardEntitlement) FromRateCardMeteredEntitlement(v RateCardMeteredEntitlement) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardMeteredEntitlement performs a merge with any union data inside the RateCardEntitlement, using the provided RateCardMeteredEntitlement
func (t *RateCardEntitlement) MergeRateCardMeteredEntitlement(v RateCardMeteredEntitlement) error {
	v.Type = "metered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRateCardStaticEntitlement returns the union data inside the RateCardEntitlement as a RateCardStaticEntitlement
func (t RateCardEntitlement) AsRateCardStaticEntitlement() (RateCardStaticEntitlement, error) {
	var body RateCardStaticEntitlement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardStaticEntitlement overwrites any union data inside the RateCardEntitlement as the provided RateCardStaticEntitlement
func (t *RateCardEntitlement) FromRateCardStaticEntitlement(v RateCardStaticEntitlement) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardStaticEntitlement performs a merge with any union data inside the RateCardEntitlement, using the provided RateCardStaticEntitlement
func (t *RateCardEntitlement) MergeRateCardStaticEntitlement(v RateCardStaticEntitlement) error {
	v.Type = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRateCardBooleanEntitlement returns the union data inside the RateCardEntitlement as a RateCardBooleanEntitlement
func (t RateCardEntitlement) AsRateCardBooleanEntitlement() (RateCardBooleanEntitlement, error) {
	var body RateCardBooleanEntitlement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardBooleanEntitlement overwrites any union data inside the RateCardEntitlement as the provided RateCardBooleanEntitlement
func (t *RateCardEntitlement) FromRateCardBooleanEntitlement(v RateCardBooleanEntitlement) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardBooleanEntitlement performs a merge with any union data inside the RateCardEntitlement, using the provided RateCardBooleanEntitlement
func (t *RateCardEntitlement) MergeRateCardBooleanEntitlement(v RateCardBooleanEntitlement) error {
	v.Type = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RateCardEntitlement) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RateCardEntitlement) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsRateCardBooleanEntitlement()
	case "metered":
		return t.AsRateCardMeteredEntitlement()
	case "static":
		return t.AsRateCardStaticEntitlement()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RateCardEntitlement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RateCardEntitlement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRateCardFlatFeeUpdateItem returns the union data inside the RateCardUpdateItem as a RateCardFlatFeeUpdateItem
func (t RateCardUpdateItem) AsRateCardFlatFeeUpdateItem() (RateCardFlatFeeUpdateItem, error) {
	var body RateCardFlatFeeUpdateItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardFlatFeeUpdateItem overwrites any union data inside the RateCardUpdateItem as the provided RateCardFlatFeeUpdateItem
func (t *RateCardUpdateItem) FromRateCardFlatFeeUpdateItem(v RateCardFlatFeeUpdateItem) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardFlatFeeUpdateItem performs a merge with any union data inside the RateCardUpdateItem, using the provided RateCardFlatFeeUpdateItem
func (t *RateCardUpdateItem) MergeRateCardFlatFeeUpdateItem(v RateCardFlatFeeUpdateItem) error {
	v.Type = "flat_fee"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRateCardUsageBasedUpdateItem returns the union data inside the RateCardUpdateItem as a RateCardUsageBasedUpdateItem
func (t RateCardUpdateItem) AsRateCardUsageBasedUpdateItem() (RateCardUsageBasedUpdateItem, error) {
	var body RateCardUsageBasedUpdateItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRateCardUsageBasedUpdateItem overwrites any union data inside the RateCardUpdateItem as the provided RateCardUsageBasedUpdateItem
func (t *RateCardUpdateItem) FromRateCardUsageBasedUpdateItem(v RateCardUsageBasedUpdateItem) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRateCardUsageBasedUpdateItem performs a merge with any union data inside the RateCardUpdateItem, using the provided RateCardUsageBasedUpdateItem
func (t *RateCardUpdateItem) MergeRateCardUsageBasedUpdateItem(v RateCardUsageBasedUpdateItem) error {
	v.Type = "usage_based"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RateCardUpdateItem) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RateCardUpdateItem) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat_fee":
		return t.AsRateCardFlatFeeUpdateItem()
	case "usage_based":
		return t.AsRateCardUsageBasedUpdateItem()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RateCardUpdateItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RateCardUpdateItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFlatPriceWithPaymentTerm returns the union data inside the RateCardUsageBasedPrice as a FlatPriceWithPaymentTerm
func (t RateCardUsageBasedPrice) AsFlatPriceWithPaymentTerm() (FlatPriceWithPaymentTerm, error) {
	var body FlatPriceWithPaymentTerm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFlatPriceWithPaymentTerm overwrites any union data inside the RateCardUsageBasedPrice as the provided FlatPriceWithPaymentTerm
func (t *RateCardUsageBasedPrice) FromFlatPriceWithPaymentTerm(v FlatPriceWithPaymentTerm) error {
	v.Type = "flat"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFlatPriceWithPaymentTerm performs a merge with any union data inside the RateCardUsageBasedPrice, using the provided FlatPriceWithPaymentTerm
func (t *RateCardUsageBasedPrice) MergeFlatPriceWithPaymentTerm(v FlatPriceWithPaymentTerm) error {
	v.Type = "flat"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnitPriceWithCommitments returns the union data inside the RateCardUsageBasedPrice as a UnitPriceWithCommitments
func (t RateCardUsageBasedPrice) AsUnitPriceWithCommitments() (UnitPriceWithCommitments, error) {
	var body UnitPriceWithCommitments
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnitPriceWithCommitments overwrites any union data inside the RateCardUsageBasedPrice as the provided UnitPriceWithCommitments
func (t *RateCardUsageBasedPrice) FromUnitPriceWithCommitments(v UnitPriceWithCommitments) error {
	v.Type = "unit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnitPriceWithCommitments performs a merge with any union data inside the RateCardUsageBasedPrice, using the provided UnitPriceWithCommitments
func (t *RateCardUsageBasedPrice) MergeUnitPriceWithCommitments(v UnitPriceWithCommitments) error {
	v.Type = "unit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTieredPriceWithCommitments returns the union data inside the RateCardUsageBasedPrice as a TieredPriceWithCommitments
func (t RateCardUsageBasedPrice) AsTieredPriceWithCommitments() (TieredPriceWithCommitments, error) {
	var body TieredPriceWithCommitments
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTieredPriceWithCommitments overwrites any union data inside the RateCardUsageBasedPrice as the provided TieredPriceWithCommitments
func (t *RateCardUsageBasedPrice) FromTieredPriceWithCommitments(v TieredPriceWithCommitments) error {
	v.Type = "tiered"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTieredPriceWithCommitments performs a merge with any union data inside the RateCardUsageBasedPrice, using the provided TieredPriceWithCommitments
func (t *RateCardUsageBasedPrice) MergeTieredPriceWithCommitments(v TieredPriceWithCommitments) error {
	v.Type = "tiered"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RateCardUsageBasedPrice) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RateCardUsageBasedPrice) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "flat":
		return t.AsFlatPriceWithPaymentTerm()
	case "tiered":
		return t.AsTieredPriceWithCommitments()
	case "unit":
		return t.AsUnitPriceWithCommitments()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RateCardUsageBasedPrice) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RateCardUsageBasedPrice) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSubscriptionItemPrice0 returns the union data inside the SubscriptionItem_Price as a SubscriptionItemPrice0
func (t SubscriptionItem_Price) AsSubscriptionItemPrice0() (SubscriptionItemPrice0, error) {
	var body SubscriptionItemPrice0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubscriptionItemPrice0 overwrites any union data inside the SubscriptionItem_Price as the provided SubscriptionItemPrice0
func (t *SubscriptionItem_Price) FromSubscriptionItemPrice0(v SubscriptionItemPrice0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubscriptionItemPrice0 performs a merge with any union data inside the SubscriptionItem_Price, using the provided SubscriptionItemPrice0
func (t *SubscriptionItem_Price) MergeSubscriptionItemPrice0(v SubscriptionItemPrice0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubscriptionItemPrice1 returns the union data inside the SubscriptionItem_Price as a SubscriptionItemPrice1
func (t SubscriptionItem_Price) AsSubscriptionItemPrice1() (SubscriptionItemPrice1, error) {
	var body SubscriptionItemPrice1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubscriptionItemPrice1 overwrites any union data inside the SubscriptionItem_Price as the provided SubscriptionItemPrice1
func (t *SubscriptionItem_Price) FromSubscriptionItemPrice1(v SubscriptionItemPrice1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubscriptionItemPrice1 performs a merge with any union data inside the SubscriptionItem_Price, using the provided SubscriptionItemPrice1
func (t *SubscriptionItem_Price) MergeSubscriptionItemPrice1(v SubscriptionItemPrice1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubscriptionItemPrice2 returns the union data inside the SubscriptionItem_Price as a SubscriptionItemPrice2
func (t SubscriptionItem_Price) AsSubscriptionItemPrice2() (SubscriptionItemPrice2, error) {
	var body SubscriptionItemPrice2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubscriptionItemPrice2 overwrites any union data inside the SubscriptionItem_Price as the provided SubscriptionItemPrice2
func (t *SubscriptionItem_Price) FromSubscriptionItemPrice2(v SubscriptionItemPrice2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubscriptionItemPrice2 performs a merge with any union data inside the SubscriptionItem_Price, using the provided SubscriptionItemPrice2
func (t *SubscriptionItem_Price) MergeSubscriptionItemPrice2(v SubscriptionItemPrice2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubscriptionItemPrice3 returns the union data inside the SubscriptionItem_Price as a SubscriptionItemPrice3
func (t SubscriptionItem_Price) AsSubscriptionItemPrice3() (SubscriptionItemPrice3, error) {
	var body SubscriptionItemPrice3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubscriptionItemPrice3 overwrites any union data inside the SubscriptionItem_Price as the provided SubscriptionItemPrice3
func (t *SubscriptionItem_Price) FromSubscriptionItemPrice3(v SubscriptionItemPrice3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubscriptionItemPrice3 performs a merge with any union data inside the SubscriptionItem_Price, using the provided SubscriptionItemPrice3
func (t *SubscriptionItem_Price) MergeSubscriptionItemPrice3(v SubscriptionItemPrice3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SubscriptionItem_Price) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SubscriptionItem_Price) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List apps
	// (GET /api/v1/apps)
	ListApps(w http.ResponseWriter, r *http.Request, params ListAppsParams)
	// Uninstall app
	// (DELETE /api/v1/apps/{id})
	UninstallApp(w http.ResponseWriter, r *http.Request, id string)
	// Get app
	// (GET /api/v1/apps/{id})
	GetApp(w http.ResponseWriter, r *http.Request, id string)
	// Stripe webhook
	// (POST /api/v1/apps/{id}/stripe/webhook)
	AppStripeWebhook(w http.ResponseWriter, r *http.Request, id string)
	// List customer overrides
	// (GET /api/v1/billing/customer)
	BillingListCustomerOverrides(w http.ResponseWriter, r *http.Request, params BillingListCustomerOverridesParams)
	// Delete a customer override
	// (DELETE /api/v1/billing/customer/{customerId})
	BillingDeleteCustomerOverride(w http.ResponseWriter, r *http.Request, customerId string)
	// Get a customer override
	// (GET /api/v1/billing/customer/{customerId})
	BillingGetCustomerOverrideById(w http.ResponseWriter, r *http.Request, customerId string)
	// Create/update a customer override
	// (POST /api/v1/billing/customer/{customerId})
	BillingUpsertCustomerOverride(w http.ResponseWriter, r *http.Request, customerId string)
	// List invoices
	// (GET /api/v1/billing/invoices)
	BillingListInvoices(w http.ResponseWriter, r *http.Request, params BillingListInvoicesParams)
	// List invoices
	// (GET /api/v1/billing/invoices/{customerId})
	BillingListInvoicesByCustomer(w http.ResponseWriter, r *http.Request, customerId string, params BillingListInvoicesByCustomerParams)
	// Create an invoice
	// (POST /api/v1/billing/invoices/{customerId})
	BillingCreateInvoice(w http.ResponseWriter, r *http.Request, customerId string)
	// Delete an invoice
	// (DELETE /api/v1/billing/invoices/{customerId}/invoices/{invoiceId})
	BillingDeleteInvoiceByCustomerInvoiceId(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string)
	// Get an invoice
	// (GET /api/v1/billing/invoices/{customerId}/invoices/{invoiceId})
	BillingGetInvoiceByCustomerInvoiceId(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string, params BillingGetInvoiceByCustomerInvoiceIdParams)
	// Advance the invoice's state to the next status
	// (POST /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/advance)
	BillingInvoiceAdvance(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string)
	// Send the invoice to the customer
	// (POST /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/approve)
	BillingApproveInvoice(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string)
	// Delete an invoice line
	// (DELETE /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/lines/{lineId})
	BillingDeleteInvoiceLine(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string, lineId string)
	// Update an invoice line
	// (PUT /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/lines/{lineId})
	BillingUpdateInvoiceLine(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string, lineId string)
	// Retry advancing the invoice after a failed attempt.
	// (POST /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/retry)
	BillingInvoiceRetry(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string)
	// Recalculate an invoice's tax amounts
	// (POST /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/tax/recalculate)
	BillingRecalculateInvoiceTax(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string)
	// Void an invoice
	// (POST /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/void)
	BillingVoidInvoice(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string)
	// Create line items
	// (POST /api/v1/billing/invoices/{customerId}/lines)
	BillingCreateLineByCustomer(w http.ResponseWriter, r *http.Request, customerId string)
	// List billing profiles
	// (GET /api/v1/billing/profile)
	BillingListProfiles(w http.ResponseWriter, r *http.Request, params BillingListProfilesParams)
	// Create a new billing profile
	// (POST /api/v1/billing/profile)
	BillingCreateProfile(w http.ResponseWriter, r *http.Request)
	// Archive a billing profile
	// (DELETE /api/v1/billing/profile/{id})
	BillingArchiveProfile(w http.ResponseWriter, r *http.Request, id string)
	// Get a billing profile by ID
	// (GET /api/v1/billing/profile/{id})
	BillingGetProfile(w http.ResponseWriter, r *http.Request, id string, params BillingGetProfileParams)
	// Update a billing profile
	// (PUT /api/v1/billing/profile/{id})
	BillingUpdateProfile(w http.ResponseWriter, r *http.Request, id string)
	// List customers
	// (GET /api/v1/customers)
	ListCustomers(w http.ResponseWriter, r *http.Request, params ListCustomersParams)
	// Create customer
	// (POST /api/v1/customers)
	CreateCustomer(w http.ResponseWriter, r *http.Request)
	// Delete customer
	// (DELETE /api/v1/customers/{id})
	DeleteCustomer(w http.ResponseWriter, r *http.Request, id string)
	// Get customer
	// (GET /api/v1/customers/{id})
	GetCustomer(w http.ResponseWriter, r *http.Request, id string)
	// Update customer
	// (PUT /api/v1/customers/{id})
	UpdateCustomer(w http.ResponseWriter, r *http.Request, id string)
	// Get event metrics
	// (GET /api/v1/debug/metrics)
	GetDebugMetrics(w http.ResponseWriter, r *http.Request)
	// List all entitlements
	// (GET /api/v1/entitlements)
	ListEntitlements(w http.ResponseWriter, r *http.Request, params ListEntitlementsParams)
	// Get entitlement by id
	// (GET /api/v1/entitlements/{entitlementId})
	GetEntitlementById(w http.ResponseWriter, r *http.Request, entitlementId string)
	// List ingested events
	// (GET /api/v1/events)
	ListEvents(w http.ResponseWriter, r *http.Request, params ListEventsParams)
	// Ingest events
	// (POST /api/v1/events)
	IngestEvents(w http.ResponseWriter, r *http.Request)
	// List features
	// (GET /api/v1/features)
	ListFeatures(w http.ResponseWriter, r *http.Request, params ListFeaturesParams)
	// Create feature
	// (POST /api/v1/features)
	CreateFeature(w http.ResponseWriter, r *http.Request)
	// Delete feature
	// (DELETE /api/v1/features/{featureId})
	DeleteFeature(w http.ResponseWriter, r *http.Request, featureId string)
	// Get feature
	// (GET /api/v1/features/{featureId})
	GetFeature(w http.ResponseWriter, r *http.Request, featureId string)
	// List grants
	// (GET /api/v1/grants)
	ListGrants(w http.ResponseWriter, r *http.Request, params ListGrantsParams)
	// Void grant
	// (DELETE /api/v1/grants/{grantId})
	VoidGrant(w http.ResponseWriter, r *http.Request, grantId string)
	// Create checkout session
	// (POST /api/v1/integration/stripe/checkout/sessions)
	CreateStripeCheckoutSession(w http.ResponseWriter, r *http.Request)
	// List available apps
	// (GET /api/v1/marketplace/listings)
	ListMarketplaceListings(w http.ResponseWriter, r *http.Request, params ListMarketplaceListingsParams)
	// Get app details by type
	// (GET /api/v1/marketplace/listings/{type})
	GetMarketplaceListing(w http.ResponseWriter, r *http.Request, pType AppType)
	// Install app via API key
	// (POST /api/v1/marketplace/listings/{type}/install/apikey)
	MarketplaceAppAPIKeyInstall(w http.ResponseWriter, r *http.Request, pType MarketplaceApiKeyInstallRequestType)
	// Get OAuth2 install URL
	// (GET /api/v1/marketplace/listings/{type}/install/oauth2)
	MarketplaceOAuth2InstallGetURL(w http.ResponseWriter, r *http.Request, pType AppType)
	// Install app via OAuth2
	// (GET /api/v1/marketplace/listings/{type}/install/oauth2/authorize)
	MarketplaceOAuth2InstallAuthorize(w http.ResponseWriter, r *http.Request, pType MarketplaceOAuth2InstallAuthorizeRequestType, params MarketplaceOAuth2InstallAuthorizeParams)
	// List meters
	// (GET /api/v1/meters)
	ListMeters(w http.ResponseWriter, r *http.Request)
	// Get meter
	// (GET /api/v1/meters/{meterIdOrSlug})
	GetMeter(w http.ResponseWriter, r *http.Request, meterIdOrSlug string)
	// Query meter Query meter
	// (GET /api/v1/meters/{meterIdOrSlug}/query)
	QueryMeter(w http.ResponseWriter, r *http.Request, meterIdOrSlug string, params QueryMeterParams)
	// List meter subjects
	// (GET /api/v1/meters/{meterIdOrSlug}/subjects)
	ListMeterSubjects(w http.ResponseWriter, r *http.Request, meterIdOrSlug string)
	// List notification channels
	// (GET /api/v1/notification/channels)
	ListNotificationChannels(w http.ResponseWriter, r *http.Request, params ListNotificationChannelsParams)
	// Create a notification channel
	// (POST /api/v1/notification/channels)
	CreateNotificationChannel(w http.ResponseWriter, r *http.Request)
	// Delete a notification channel
	// (DELETE /api/v1/notification/channels/{channelId})
	DeleteNotificationChannel(w http.ResponseWriter, r *http.Request, channelId string)
	// Get notification channel
	// (GET /api/v1/notification/channels/{channelId})
	GetNotificationChannel(w http.ResponseWriter, r *http.Request, channelId string)
	// Update a notification channel
	// (PUT /api/v1/notification/channels/{channelId})
	UpdateNotificationChannel(w http.ResponseWriter, r *http.Request, channelId string)
	// List notification events
	// (GET /api/v1/notification/events)
	ListNotificationEvents(w http.ResponseWriter, r *http.Request, params ListNotificationEventsParams)
	// Get notification event
	// (GET /api/v1/notification/events/{eventId})
	GetNotificationEvent(w http.ResponseWriter, r *http.Request, eventId string)
	// List notification rules
	// (GET /api/v1/notification/rules)
	ListNotificationRules(w http.ResponseWriter, r *http.Request, params ListNotificationRulesParams)
	// Create a notification rule
	// (POST /api/v1/notification/rules)
	CreateNotificationRule(w http.ResponseWriter, r *http.Request)
	// Delete a notification rule
	// (DELETE /api/v1/notification/rules/{ruleId})
	DeleteNotificationRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Get notification rule
	// (GET /api/v1/notification/rules/{ruleId})
	GetNotificationRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Update a notification rule
	// (PUT /api/v1/notification/rules/{ruleId})
	UpdateNotificationRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Test notification rule
	// (POST /api/v1/notification/rules/{ruleId}/test)
	TestNotificationRule(w http.ResponseWriter, r *http.Request, ruleId string)
	// Receive Svix operational events
	// (POST /api/v1/notification/webhook/svix)
	ReceiveSvixOperationalEvent(w http.ResponseWriter, r *http.Request)
	// List plans
	// (GET /api/v1/plans)
	ListPlans(w http.ResponseWriter, r *http.Request, params ListPlansParams)
	// Create a plan
	// (POST /api/v1/plans)
	CreatePlan(w http.ResponseWriter, r *http.Request)
	// New draft plan
	// (POST /api/v1/plans/{planIdOrKey}/next)
	NextPlan(w http.ResponseWriter, r *http.Request, planIdOrKey string)
	// Delete plan
	// (DELETE /api/v1/plans/{planId})
	DeletePlan(w http.ResponseWriter, r *http.Request, planId string)
	// Get plan
	// (GET /api/v1/plans/{planId})
	GetPlan(w http.ResponseWriter, r *http.Request, planId string, params GetPlanParams)
	// Update a plan
	// (PUT /api/v1/plans/{planId})
	UpdatePlan(w http.ResponseWriter, r *http.Request, planId string)
	// Archive plan version
	// (POST /api/v1/plans/{planId}/archive)
	ArchivePlan(w http.ResponseWriter, r *http.Request, planId string)
	// List phases in plan
	// (GET /api/v1/plans/{planId}/phases)
	ListPlanPhases(w http.ResponseWriter, r *http.Request, planId string, params ListPlanPhasesParams)
	// Create new phase in plan
	// (POST /api/v1/plans/{planId}/phases)
	CreatePlanPhase(w http.ResponseWriter, r *http.Request, planId string)
	// Delete phase for plan
	// (DELETE /api/v1/plans/{planId}/phases/{planPhaseKey})
	DeletePlanPhase(w http.ResponseWriter, r *http.Request, planId string, planPhaseKey string)
	// Get phase for plan
	// (GET /api/v1/plans/{planId}/phases/{planPhaseKey})
	GetPlanPhase(w http.ResponseWriter, r *http.Request, planId string, planPhaseKey string)
	// Update phase in plan
	// (PUT /api/v1/plans/{planId}/phases/{planPhaseKey})
	UpdatePlanPhase(w http.ResponseWriter, r *http.Request, planId string, planPhaseKey string)
	// Publish plan
	// (POST /api/v1/plans/{planId}/publish)
	PublishPlan(w http.ResponseWriter, r *http.Request, planId string)
	// Query meter Query meter
	// (GET /api/v1/portal/meters/{meterSlug}/query)
	QueryPortalMeter(w http.ResponseWriter, r *http.Request, meterSlug string, params QueryPortalMeterParams)
	// List consumer portal tokens
	// (GET /api/v1/portal/tokens)
	ListPortalTokens(w http.ResponseWriter, r *http.Request, params ListPortalTokensParams)
	// Create consumer portal token
	// (POST /api/v1/portal/tokens)
	CreatePortalToken(w http.ResponseWriter, r *http.Request)
	// List entitlements
	// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements)
	ListSubjectEntitlements(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, params ListSubjectEntitlementsParams)
	// Create an entitlement
	// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements)
	CreateEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey string)
	// List entitlement grants
	// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants)
	ListEntitlementGrants(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementIdOrFeatureKey string, params ListEntitlementGrantsParams)
	// Create grant
	// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants)
	CreateGrant(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementIdOrFeatureKey string)
	// Override entitlement
	// (PUT /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override)
	OverrideEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementIdOrFeatureKey string)
	// Get entitlement value
	// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value)
	GetEntitlementValue(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementIdOrFeatureKey string, params GetEntitlementValueParams)
	// Delete entitlement
	// (DELETE /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId})
	DeleteEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementId string)
	// Get entitlement
	// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId})
	GetEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementId string)
	// Get entitlement history
	// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history)
	GetEntitlementHistory(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementId string, params GetEntitlementHistoryParams)
	// Reset entitlement
	// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset)
	ResetEntitlementUsage(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementId string)
	// Create subscription
	// (POST /api/v1/subscriptions)
	CreateSubscription(w http.ResponseWriter, r *http.Request)
	// Get subscription Get subscription
	// (GET /api/v1/subscriptions/{subscriptionId})
	GetSubscription(w http.ResponseWriter, r *http.Request, subscriptionId string, params GetSubscriptionParams)
	// Edit subscription
	// (PATCH /api/v1/subscriptions/{subscriptionId})
	EditSubscription(w http.ResponseWriter, r *http.Request, subscriptionId string)
	// Cancel subscription
	// (POST /api/v1/subscriptions/{subscriptionId}/cancel)
	CancelSubscription(w http.ResponseWriter, r *http.Request, subscriptionId string)
	// Migrate subscription
	// (POST /api/v1/subscriptions/{subscriptionId}/migrate)
	MigrateSubscription(w http.ResponseWriter, r *http.Request, subscriptionId string)
	// Unschedule cancelation
	// (POST /api/v1/subscriptions/{subscriptionId}/unschedule-cancelation)
	UnscheduleCancelation(w http.ResponseWriter, r *http.Request, subscriptionId string)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List apps
// (GET /api/v1/apps)
func (_ Unimplemented) ListApps(w http.ResponseWriter, r *http.Request, params ListAppsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Uninstall app
// (DELETE /api/v1/apps/{id})
func (_ Unimplemented) UninstallApp(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get app
// (GET /api/v1/apps/{id})
func (_ Unimplemented) GetApp(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Stripe webhook
// (POST /api/v1/apps/{id}/stripe/webhook)
func (_ Unimplemented) AppStripeWebhook(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List customer overrides
// (GET /api/v1/billing/customer)
func (_ Unimplemented) BillingListCustomerOverrides(w http.ResponseWriter, r *http.Request, params BillingListCustomerOverridesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a customer override
// (DELETE /api/v1/billing/customer/{customerId})
func (_ Unimplemented) BillingDeleteCustomerOverride(w http.ResponseWriter, r *http.Request, customerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a customer override
// (GET /api/v1/billing/customer/{customerId})
func (_ Unimplemented) BillingGetCustomerOverrideById(w http.ResponseWriter, r *http.Request, customerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create/update a customer override
// (POST /api/v1/billing/customer/{customerId})
func (_ Unimplemented) BillingUpsertCustomerOverride(w http.ResponseWriter, r *http.Request, customerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List invoices
// (GET /api/v1/billing/invoices)
func (_ Unimplemented) BillingListInvoices(w http.ResponseWriter, r *http.Request, params BillingListInvoicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List invoices
// (GET /api/v1/billing/invoices/{customerId})
func (_ Unimplemented) BillingListInvoicesByCustomer(w http.ResponseWriter, r *http.Request, customerId string, params BillingListInvoicesByCustomerParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create an invoice
// (POST /api/v1/billing/invoices/{customerId})
func (_ Unimplemented) BillingCreateInvoice(w http.ResponseWriter, r *http.Request, customerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete an invoice
// (DELETE /api/v1/billing/invoices/{customerId}/invoices/{invoiceId})
func (_ Unimplemented) BillingDeleteInvoiceByCustomerInvoiceId(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get an invoice
// (GET /api/v1/billing/invoices/{customerId}/invoices/{invoiceId})
func (_ Unimplemented) BillingGetInvoiceByCustomerInvoiceId(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string, params BillingGetInvoiceByCustomerInvoiceIdParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Advance the invoice's state to the next status
// (POST /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/advance)
func (_ Unimplemented) BillingInvoiceAdvance(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Send the invoice to the customer
// (POST /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/approve)
func (_ Unimplemented) BillingApproveInvoice(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete an invoice line
// (DELETE /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/lines/{lineId})
func (_ Unimplemented) BillingDeleteInvoiceLine(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string, lineId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update an invoice line
// (PUT /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/lines/{lineId})
func (_ Unimplemented) BillingUpdateInvoiceLine(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string, lineId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retry advancing the invoice after a failed attempt.
// (POST /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/retry)
func (_ Unimplemented) BillingInvoiceRetry(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Recalculate an invoice's tax amounts
// (POST /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/tax/recalculate)
func (_ Unimplemented) BillingRecalculateInvoiceTax(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Void an invoice
// (POST /api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/void)
func (_ Unimplemented) BillingVoidInvoice(w http.ResponseWriter, r *http.Request, customerId string, invoiceId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create line items
// (POST /api/v1/billing/invoices/{customerId}/lines)
func (_ Unimplemented) BillingCreateLineByCustomer(w http.ResponseWriter, r *http.Request, customerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List billing profiles
// (GET /api/v1/billing/profile)
func (_ Unimplemented) BillingListProfiles(w http.ResponseWriter, r *http.Request, params BillingListProfilesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new billing profile
// (POST /api/v1/billing/profile)
func (_ Unimplemented) BillingCreateProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Archive a billing profile
// (DELETE /api/v1/billing/profile/{id})
func (_ Unimplemented) BillingArchiveProfile(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a billing profile by ID
// (GET /api/v1/billing/profile/{id})
func (_ Unimplemented) BillingGetProfile(w http.ResponseWriter, r *http.Request, id string, params BillingGetProfileParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a billing profile
// (PUT /api/v1/billing/profile/{id})
func (_ Unimplemented) BillingUpdateProfile(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List customers
// (GET /api/v1/customers)
func (_ Unimplemented) ListCustomers(w http.ResponseWriter, r *http.Request, params ListCustomersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create customer
// (POST /api/v1/customers)
func (_ Unimplemented) CreateCustomer(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete customer
// (DELETE /api/v1/customers/{id})
func (_ Unimplemented) DeleteCustomer(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get customer
// (GET /api/v1/customers/{id})
func (_ Unimplemented) GetCustomer(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update customer
// (PUT /api/v1/customers/{id})
func (_ Unimplemented) UpdateCustomer(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get event metrics
// (GET /api/v1/debug/metrics)
func (_ Unimplemented) GetDebugMetrics(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all entitlements
// (GET /api/v1/entitlements)
func (_ Unimplemented) ListEntitlements(w http.ResponseWriter, r *http.Request, params ListEntitlementsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get entitlement by id
// (GET /api/v1/entitlements/{entitlementId})
func (_ Unimplemented) GetEntitlementById(w http.ResponseWriter, r *http.Request, entitlementId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List ingested events
// (GET /api/v1/events)
func (_ Unimplemented) ListEvents(w http.ResponseWriter, r *http.Request, params ListEventsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Ingest events
// (POST /api/v1/events)
func (_ Unimplemented) IngestEvents(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List features
// (GET /api/v1/features)
func (_ Unimplemented) ListFeatures(w http.ResponseWriter, r *http.Request, params ListFeaturesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create feature
// (POST /api/v1/features)
func (_ Unimplemented) CreateFeature(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete feature
// (DELETE /api/v1/features/{featureId})
func (_ Unimplemented) DeleteFeature(w http.ResponseWriter, r *http.Request, featureId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get feature
// (GET /api/v1/features/{featureId})
func (_ Unimplemented) GetFeature(w http.ResponseWriter, r *http.Request, featureId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List grants
// (GET /api/v1/grants)
func (_ Unimplemented) ListGrants(w http.ResponseWriter, r *http.Request, params ListGrantsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Void grant
// (DELETE /api/v1/grants/{grantId})
func (_ Unimplemented) VoidGrant(w http.ResponseWriter, r *http.Request, grantId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create checkout session
// (POST /api/v1/integration/stripe/checkout/sessions)
func (_ Unimplemented) CreateStripeCheckoutSession(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List available apps
// (GET /api/v1/marketplace/listings)
func (_ Unimplemented) ListMarketplaceListings(w http.ResponseWriter, r *http.Request, params ListMarketplaceListingsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get app details by type
// (GET /api/v1/marketplace/listings/{type})
func (_ Unimplemented) GetMarketplaceListing(w http.ResponseWriter, r *http.Request, pType AppType) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Install app via API key
// (POST /api/v1/marketplace/listings/{type}/install/apikey)
func (_ Unimplemented) MarketplaceAppAPIKeyInstall(w http.ResponseWriter, r *http.Request, pType MarketplaceApiKeyInstallRequestType) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get OAuth2 install URL
// (GET /api/v1/marketplace/listings/{type}/install/oauth2)
func (_ Unimplemented) MarketplaceOAuth2InstallGetURL(w http.ResponseWriter, r *http.Request, pType AppType) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Install app via OAuth2
// (GET /api/v1/marketplace/listings/{type}/install/oauth2/authorize)
func (_ Unimplemented) MarketplaceOAuth2InstallAuthorize(w http.ResponseWriter, r *http.Request, pType MarketplaceOAuth2InstallAuthorizeRequestType, params MarketplaceOAuth2InstallAuthorizeParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List meters
// (GET /api/v1/meters)
func (_ Unimplemented) ListMeters(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get meter
// (GET /api/v1/meters/{meterIdOrSlug})
func (_ Unimplemented) GetMeter(w http.ResponseWriter, r *http.Request, meterIdOrSlug string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Query meter Query meter
// (GET /api/v1/meters/{meterIdOrSlug}/query)
func (_ Unimplemented) QueryMeter(w http.ResponseWriter, r *http.Request, meterIdOrSlug string, params QueryMeterParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List meter subjects
// (GET /api/v1/meters/{meterIdOrSlug}/subjects)
func (_ Unimplemented) ListMeterSubjects(w http.ResponseWriter, r *http.Request, meterIdOrSlug string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List notification channels
// (GET /api/v1/notification/channels)
func (_ Unimplemented) ListNotificationChannels(w http.ResponseWriter, r *http.Request, params ListNotificationChannelsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a notification channel
// (POST /api/v1/notification/channels)
func (_ Unimplemented) CreateNotificationChannel(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a notification channel
// (DELETE /api/v1/notification/channels/{channelId})
func (_ Unimplemented) DeleteNotificationChannel(w http.ResponseWriter, r *http.Request, channelId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get notification channel
// (GET /api/v1/notification/channels/{channelId})
func (_ Unimplemented) GetNotificationChannel(w http.ResponseWriter, r *http.Request, channelId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a notification channel
// (PUT /api/v1/notification/channels/{channelId})
func (_ Unimplemented) UpdateNotificationChannel(w http.ResponseWriter, r *http.Request, channelId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List notification events
// (GET /api/v1/notification/events)
func (_ Unimplemented) ListNotificationEvents(w http.ResponseWriter, r *http.Request, params ListNotificationEventsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get notification event
// (GET /api/v1/notification/events/{eventId})
func (_ Unimplemented) GetNotificationEvent(w http.ResponseWriter, r *http.Request, eventId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List notification rules
// (GET /api/v1/notification/rules)
func (_ Unimplemented) ListNotificationRules(w http.ResponseWriter, r *http.Request, params ListNotificationRulesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a notification rule
// (POST /api/v1/notification/rules)
func (_ Unimplemented) CreateNotificationRule(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a notification rule
// (DELETE /api/v1/notification/rules/{ruleId})
func (_ Unimplemented) DeleteNotificationRule(w http.ResponseWriter, r *http.Request, ruleId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get notification rule
// (GET /api/v1/notification/rules/{ruleId})
func (_ Unimplemented) GetNotificationRule(w http.ResponseWriter, r *http.Request, ruleId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a notification rule
// (PUT /api/v1/notification/rules/{ruleId})
func (_ Unimplemented) UpdateNotificationRule(w http.ResponseWriter, r *http.Request, ruleId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Test notification rule
// (POST /api/v1/notification/rules/{ruleId}/test)
func (_ Unimplemented) TestNotificationRule(w http.ResponseWriter, r *http.Request, ruleId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Receive Svix operational events
// (POST /api/v1/notification/webhook/svix)
func (_ Unimplemented) ReceiveSvixOperationalEvent(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List plans
// (GET /api/v1/plans)
func (_ Unimplemented) ListPlans(w http.ResponseWriter, r *http.Request, params ListPlansParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a plan
// (POST /api/v1/plans)
func (_ Unimplemented) CreatePlan(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// New draft plan
// (POST /api/v1/plans/{planIdOrKey}/next)
func (_ Unimplemented) NextPlan(w http.ResponseWriter, r *http.Request, planIdOrKey string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete plan
// (DELETE /api/v1/plans/{planId})
func (_ Unimplemented) DeletePlan(w http.ResponseWriter, r *http.Request, planId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get plan
// (GET /api/v1/plans/{planId})
func (_ Unimplemented) GetPlan(w http.ResponseWriter, r *http.Request, planId string, params GetPlanParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a plan
// (PUT /api/v1/plans/{planId})
func (_ Unimplemented) UpdatePlan(w http.ResponseWriter, r *http.Request, planId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Archive plan version
// (POST /api/v1/plans/{planId}/archive)
func (_ Unimplemented) ArchivePlan(w http.ResponseWriter, r *http.Request, planId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List phases in plan
// (GET /api/v1/plans/{planId}/phases)
func (_ Unimplemented) ListPlanPhases(w http.ResponseWriter, r *http.Request, planId string, params ListPlanPhasesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create new phase in plan
// (POST /api/v1/plans/{planId}/phases)
func (_ Unimplemented) CreatePlanPhase(w http.ResponseWriter, r *http.Request, planId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete phase for plan
// (DELETE /api/v1/plans/{planId}/phases/{planPhaseKey})
func (_ Unimplemented) DeletePlanPhase(w http.ResponseWriter, r *http.Request, planId string, planPhaseKey string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get phase for plan
// (GET /api/v1/plans/{planId}/phases/{planPhaseKey})
func (_ Unimplemented) GetPlanPhase(w http.ResponseWriter, r *http.Request, planId string, planPhaseKey string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update phase in plan
// (PUT /api/v1/plans/{planId}/phases/{planPhaseKey})
func (_ Unimplemented) UpdatePlanPhase(w http.ResponseWriter, r *http.Request, planId string, planPhaseKey string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Publish plan
// (POST /api/v1/plans/{planId}/publish)
func (_ Unimplemented) PublishPlan(w http.ResponseWriter, r *http.Request, planId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Query meter Query meter
// (GET /api/v1/portal/meters/{meterSlug}/query)
func (_ Unimplemented) QueryPortalMeter(w http.ResponseWriter, r *http.Request, meterSlug string, params QueryPortalMeterParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List consumer portal tokens
// (GET /api/v1/portal/tokens)
func (_ Unimplemented) ListPortalTokens(w http.ResponseWriter, r *http.Request, params ListPortalTokensParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create consumer portal token
// (POST /api/v1/portal/tokens)
func (_ Unimplemented) CreatePortalToken(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List entitlements
// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements)
func (_ Unimplemented) ListSubjectEntitlements(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, params ListSubjectEntitlementsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create an entitlement
// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements)
func (_ Unimplemented) CreateEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List entitlement grants
// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants)
func (_ Unimplemented) ListEntitlementGrants(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementIdOrFeatureKey string, params ListEntitlementGrantsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create grant
// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants)
func (_ Unimplemented) CreateGrant(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementIdOrFeatureKey string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Override entitlement
// (PUT /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override)
func (_ Unimplemented) OverrideEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementIdOrFeatureKey string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get entitlement value
// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value)
func (_ Unimplemented) GetEntitlementValue(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementIdOrFeatureKey string, params GetEntitlementValueParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete entitlement
// (DELETE /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId})
func (_ Unimplemented) DeleteEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get entitlement
// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId})
func (_ Unimplemented) GetEntitlement(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get entitlement history
// (GET /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history)
func (_ Unimplemented) GetEntitlementHistory(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementId string, params GetEntitlementHistoryParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Reset entitlement
// (POST /api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset)
func (_ Unimplemented) ResetEntitlementUsage(w http.ResponseWriter, r *http.Request, subjectIdOrKey string, entitlementId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create subscription
// (POST /api/v1/subscriptions)
func (_ Unimplemented) CreateSubscription(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get subscription Get subscription
// (GET /api/v1/subscriptions/{subscriptionId})
func (_ Unimplemented) GetSubscription(w http.ResponseWriter, r *http.Request, subscriptionId string, params GetSubscriptionParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Edit subscription
// (PATCH /api/v1/subscriptions/{subscriptionId})
func (_ Unimplemented) EditSubscription(w http.ResponseWriter, r *http.Request, subscriptionId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Cancel subscription
// (POST /api/v1/subscriptions/{subscriptionId}/cancel)
func (_ Unimplemented) CancelSubscription(w http.ResponseWriter, r *http.Request, subscriptionId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Migrate subscription
// (POST /api/v1/subscriptions/{subscriptionId}/migrate)
func (_ Unimplemented) MigrateSubscription(w http.ResponseWriter, r *http.Request, subscriptionId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unschedule cancelation
// (POST /api/v1/subscriptions/{subscriptionId}/unschedule-cancelation)
func (_ Unimplemented) UnscheduleCancelation(w http.ResponseWriter, r *http.Request, subscriptionId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListApps operation middleware
func (siw *ServerInterfaceWrapper) ListApps(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAppsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListApps(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UninstallApp operation middleware
func (siw *ServerInterfaceWrapper) UninstallApp(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UninstallApp(w, r, id)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetApp operation middleware
func (siw *ServerInterfaceWrapper) GetApp(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetApp(w, r, id)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AppStripeWebhook operation middleware
func (siw *ServerInterfaceWrapper) AppStripeWebhook(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AppStripeWebhook(w, r, id)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingListCustomerOverrides operation middleware
func (siw *ServerInterfaceWrapper) BillingListCustomerOverrides(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params BillingListCustomerOverridesParams

	// ------------- Optional query parameter "billingProfile" -------------

	err = runtime.BindQueryParameter("form", false, false, "billingProfile", r.URL.Query(), &params.BillingProfile)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "billingProfile", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", false, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingListCustomerOverrides(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingDeleteCustomerOverride operation middleware
func (siw *ServerInterfaceWrapper) BillingDeleteCustomerOverride(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingDeleteCustomerOverride(w, r, customerId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingGetCustomerOverrideById operation middleware
func (siw *ServerInterfaceWrapper) BillingGetCustomerOverrideById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingGetCustomerOverrideById(w, r, customerId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingUpsertCustomerOverride operation middleware
func (siw *ServerInterfaceWrapper) BillingUpsertCustomerOverride(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingUpsertCustomerOverride(w, r, customerId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingListInvoices operation middleware
func (siw *ServerInterfaceWrapper) BillingListInvoices(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params BillingListInvoicesParams

	// ------------- Optional query parameter "customers" -------------

	err = runtime.BindQueryParameter("form", false, false, "customers", r.URL.Query(), &params.Customers)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customers", Err: err})
		return
	}

	// ------------- Optional query parameter "statuses" -------------

	err = runtime.BindQueryParameter("form", false, false, "statuses", r.URL.Query(), &params.Statuses)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "statuses", Err: err})
		return
	}

	// ------------- Optional query parameter "extendedStatuses" -------------

	err = runtime.BindQueryParameter("form", false, false, "extendedStatuses", r.URL.Query(), &params.ExtendedStatuses)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "extendedStatuses", Err: err})
		return
	}

	// ------------- Optional query parameter "issuedAfter" -------------

	err = runtime.BindQueryParameter("form", false, false, "issuedAfter", r.URL.Query(), &params.IssuedAfter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "issuedAfter", Err: err})
		return
	}

	// ------------- Optional query parameter "issuedBefore" -------------

	err = runtime.BindQueryParameter("form", false, false, "issuedBefore", r.URL.Query(), &params.IssuedBefore)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "issuedBefore", Err: err})
		return
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", r.URL.Query(), &params.Expand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expand", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", false, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingListInvoices(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingListInvoicesByCustomer operation middleware
func (siw *ServerInterfaceWrapper) BillingListInvoicesByCustomer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params BillingListInvoicesByCustomerParams

	// ------------- Optional query parameter "statuses" -------------

	err = runtime.BindQueryParameter("form", false, false, "statuses", r.URL.Query(), &params.Statuses)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "statuses", Err: err})
		return
	}

	// ------------- Optional query parameter "extendedStatuses" -------------

	err = runtime.BindQueryParameter("form", false, false, "extendedStatuses", r.URL.Query(), &params.ExtendedStatuses)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "extendedStatuses", Err: err})
		return
	}

	// ------------- Optional query parameter "issuedAfter" -------------

	err = runtime.BindQueryParameter("form", false, false, "issuedAfter", r.URL.Query(), &params.IssuedAfter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "issuedAfter", Err: err})
		return
	}

	// ------------- Optional query parameter "issuedBefore" -------------

	err = runtime.BindQueryParameter("form", false, false, "issuedBefore", r.URL.Query(), &params.IssuedBefore)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "issuedBefore", Err: err})
		return
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", r.URL.Query(), &params.Expand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expand", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", false, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingListInvoicesByCustomer(w, r, customerId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingCreateInvoice operation middleware
func (siw *ServerInterfaceWrapper) BillingCreateInvoice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingCreateInvoice(w, r, customerId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingDeleteInvoiceByCustomerInvoiceId operation middleware
func (siw *ServerInterfaceWrapper) BillingDeleteInvoiceByCustomerInvoiceId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	// ------------- Path parameter "invoiceId" -------------
	var invoiceId string

	err = runtime.BindStyledParameterWithOptions("simple", "invoiceId", chi.URLParam(r, "invoiceId"), &invoiceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "invoiceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingDeleteInvoiceByCustomerInvoiceId(w, r, customerId, invoiceId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingGetInvoiceByCustomerInvoiceId operation middleware
func (siw *ServerInterfaceWrapper) BillingGetInvoiceByCustomerInvoiceId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	// ------------- Path parameter "invoiceId" -------------
	var invoiceId string

	err = runtime.BindStyledParameterWithOptions("simple", "invoiceId", chi.URLParam(r, "invoiceId"), &invoiceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "invoiceId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params BillingGetInvoiceByCustomerInvoiceIdParams

	// ------------- Required query parameter "expand" -------------

	if paramValue := r.URL.Query().Get("expand"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "expand"})
		return
	}

	err = runtime.BindQueryParameter("form", false, true, "expand", r.URL.Query(), &params.Expand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expand", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingGetInvoiceByCustomerInvoiceId(w, r, customerId, invoiceId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingInvoiceAdvance operation middleware
func (siw *ServerInterfaceWrapper) BillingInvoiceAdvance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	// ------------- Path parameter "invoiceId" -------------
	var invoiceId string

	err = runtime.BindStyledParameterWithOptions("simple", "invoiceId", chi.URLParam(r, "invoiceId"), &invoiceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "invoiceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingInvoiceAdvance(w, r, customerId, invoiceId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingApproveInvoice operation middleware
func (siw *ServerInterfaceWrapper) BillingApproveInvoice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	// ------------- Path parameter "invoiceId" -------------
	var invoiceId string

	err = runtime.BindStyledParameterWithOptions("simple", "invoiceId", chi.URLParam(r, "invoiceId"), &invoiceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "invoiceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingApproveInvoice(w, r, customerId, invoiceId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingDeleteInvoiceLine operation middleware
func (siw *ServerInterfaceWrapper) BillingDeleteInvoiceLine(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	// ------------- Path parameter "invoiceId" -------------
	var invoiceId string

	err = runtime.BindStyledParameterWithOptions("simple", "invoiceId", chi.URLParam(r, "invoiceId"), &invoiceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "invoiceId", Err: err})
		return
	}

	// ------------- Path parameter "lineId" -------------
	var lineId string

	err = runtime.BindStyledParameterWithOptions("simple", "lineId", chi.URLParam(r, "lineId"), &lineId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lineId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingDeleteInvoiceLine(w, r, customerId, invoiceId, lineId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingUpdateInvoiceLine operation middleware
func (siw *ServerInterfaceWrapper) BillingUpdateInvoiceLine(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	// ------------- Path parameter "invoiceId" -------------
	var invoiceId string

	err = runtime.BindStyledParameterWithOptions("simple", "invoiceId", chi.URLParam(r, "invoiceId"), &invoiceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "invoiceId", Err: err})
		return
	}

	// ------------- Path parameter "lineId" -------------
	var lineId string

	err = runtime.BindStyledParameterWithOptions("simple", "lineId", chi.URLParam(r, "lineId"), &lineId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lineId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingUpdateInvoiceLine(w, r, customerId, invoiceId, lineId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingInvoiceRetry operation middleware
func (siw *ServerInterfaceWrapper) BillingInvoiceRetry(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	// ------------- Path parameter "invoiceId" -------------
	var invoiceId string

	err = runtime.BindStyledParameterWithOptions("simple", "invoiceId", chi.URLParam(r, "invoiceId"), &invoiceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "invoiceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingInvoiceRetry(w, r, customerId, invoiceId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingRecalculateInvoiceTax operation middleware
func (siw *ServerInterfaceWrapper) BillingRecalculateInvoiceTax(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	// ------------- Path parameter "invoiceId" -------------
	var invoiceId string

	err = runtime.BindStyledParameterWithOptions("simple", "invoiceId", chi.URLParam(r, "invoiceId"), &invoiceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "invoiceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingRecalculateInvoiceTax(w, r, customerId, invoiceId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingVoidInvoice operation middleware
func (siw *ServerInterfaceWrapper) BillingVoidInvoice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	// ------------- Path parameter "invoiceId" -------------
	var invoiceId string

	err = runtime.BindStyledParameterWithOptions("simple", "invoiceId", chi.URLParam(r, "invoiceId"), &invoiceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "invoiceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingVoidInvoice(w, r, customerId, invoiceId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingCreateLineByCustomer operation middleware
func (siw *ServerInterfaceWrapper) BillingCreateLineByCustomer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "customerId" -------------
	var customerId string

	err = runtime.BindStyledParameterWithOptions("simple", "customerId", chi.URLParam(r, "customerId"), &customerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "customerId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingCreateLineByCustomer(w, r, customerId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingListProfiles operation middleware
func (siw *ServerInterfaceWrapper) BillingListProfiles(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params BillingListProfilesParams

	// ------------- Optional query parameter "includeArchived" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeArchived", r.URL.Query(), &params.IncludeArchived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeArchived", Err: err})
		return
	}

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", r.URL.Query(), &params.Expand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expand", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", false, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingListProfiles(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingCreateProfile operation middleware
func (siw *ServerInterfaceWrapper) BillingCreateProfile(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingCreateProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingArchiveProfile operation middleware
func (siw *ServerInterfaceWrapper) BillingArchiveProfile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingArchiveProfile(w, r, id)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingGetProfile operation middleware
func (siw *ServerInterfaceWrapper) BillingGetProfile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params BillingGetProfileParams

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", r.URL.Query(), &params.Expand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expand", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingGetProfile(w, r, id, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// BillingUpdateProfile operation middleware
func (siw *ServerInterfaceWrapper) BillingUpdateProfile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BillingUpdateProfile(w, r, id)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListCustomers operation middleware
func (siw *ServerInterfaceWrapper) ListCustomers(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCustomersParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", false, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "primaryEmail" -------------

	err = runtime.BindQueryParameter("form", false, false, "primaryEmail", r.URL.Query(), &params.PrimaryEmail)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "primaryEmail", Err: err})
		return
	}

	// ------------- Optional query parameter "subject" -------------

	err = runtime.BindQueryParameter("form", false, false, "subject", r.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subject", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListCustomers(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateCustomer operation middleware
func (siw *ServerInterfaceWrapper) CreateCustomer(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCustomer(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteCustomer operation middleware
func (siw *ServerInterfaceWrapper) DeleteCustomer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCustomer(w, r, id)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCustomer operation middleware
func (siw *ServerInterfaceWrapper) GetCustomer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCustomer(w, r, id)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateCustomer operation middleware
func (siw *ServerInterfaceWrapper) UpdateCustomer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateCustomer(w, r, id)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDebugMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetDebugMetrics(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDebugMetrics(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListEntitlements operation middleware
func (siw *ServerInterfaceWrapper) ListEntitlements(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEntitlementsParams

	// ------------- Optional query parameter "feature" -------------

	err = runtime.BindQueryParameter("form", true, false, "feature", r.URL.Query(), &params.Feature)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "feature", Err: err})
		return
	}

	// ------------- Optional query parameter "subject" -------------

	err = runtime.BindQueryParameter("form", true, false, "subject", r.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subject", Err: err})
		return
	}

	// ------------- Optional query parameter "entitlementType" -------------

	err = runtime.BindQueryParameter("form", true, false, "entitlementType", r.URL.Query(), &params.EntitlementType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementType", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", false, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListEntitlements(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetEntitlementById operation middleware
func (siw *ServerInterfaceWrapper) GetEntitlementById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "entitlementId" -------------
	var entitlementId string

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementId", chi.URLParam(r, "entitlementId"), &entitlementId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntitlementById(w, r, entitlementId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListEvents operation middleware
func (siw *ServerInterfaceWrapper) ListEvents(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEventsParams

	// ------------- Optional query parameter "ingestedAtFrom" -------------

	err = runtime.BindQueryParameter("form", true, false, "ingestedAtFrom", r.URL.Query(), &params.IngestedAtFrom)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ingestedAtFrom", Err: err})
		return
	}

	// ------------- Optional query parameter "ingestedAtTo" -------------

	err = runtime.BindQueryParameter("form", true, false, "ingestedAtTo", r.URL.Query(), &params.IngestedAtTo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ingestedAtTo", Err: err})
		return
	}

	// ------------- Optional query parameter "hasError" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasError", r.URL.Query(), &params.HasError)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "hasError", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "subject" -------------

	err = runtime.BindQueryParameter("form", true, false, "subject", r.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subject", Err: err})
		return
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListEvents(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// IngestEvents operation middleware
func (siw *ServerInterfaceWrapper) IngestEvents(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.IngestEvents(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListFeatures operation middleware
func (siw *ServerInterfaceWrapper) ListFeatures(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFeaturesParams

	// ------------- Optional query parameter "meterSlug" -------------

	err = runtime.BindQueryParameter("form", true, false, "meterSlug", r.URL.Query(), &params.MeterSlug)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "meterSlug", Err: err})
		return
	}

	// ------------- Optional query parameter "includeArchived" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeArchived", r.URL.Query(), &params.IncludeArchived)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeArchived", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", false, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFeatures(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateFeature operation middleware
func (siw *ServerInterfaceWrapper) CreateFeature(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateFeature(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteFeature operation middleware
func (siw *ServerInterfaceWrapper) DeleteFeature(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "featureId" -------------
	var featureId string

	err = runtime.BindStyledParameterWithOptions("simple", "featureId", chi.URLParam(r, "featureId"), &featureId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "featureId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFeature(w, r, featureId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFeature operation middleware
func (siw *ServerInterfaceWrapper) GetFeature(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "featureId" -------------
	var featureId string

	err = runtime.BindStyledParameterWithOptions("simple", "featureId", chi.URLParam(r, "featureId"), &featureId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "featureId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFeature(w, r, featureId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGrants operation middleware
func (siw *ServerInterfaceWrapper) ListGrants(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGrantsParams

	// ------------- Optional query parameter "feature" -------------

	err = runtime.BindQueryParameter("form", true, false, "feature", r.URL.Query(), &params.Feature)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "feature", Err: err})
		return
	}

	// ------------- Optional query parameter "subject" -------------

	err = runtime.BindQueryParameter("form", true, false, "subject", r.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subject", Err: err})
		return
	}

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", false, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGrants(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// VoidGrant operation middleware
func (siw *ServerInterfaceWrapper) VoidGrant(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "grantId" -------------
	var grantId string

	err = runtime.BindStyledParameterWithOptions("simple", "grantId", chi.URLParam(r, "grantId"), &grantId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "grantId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VoidGrant(w, r, grantId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateStripeCheckoutSession operation middleware
func (siw *ServerInterfaceWrapper) CreateStripeCheckoutSession(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateStripeCheckoutSession(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListMarketplaceListings operation middleware
func (siw *ServerInterfaceWrapper) ListMarketplaceListings(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMarketplaceListingsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMarketplaceListings(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMarketplaceListing operation middleware
func (siw *ServerInterfaceWrapper) GetMarketplaceListing(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "type" -------------
	var pType AppType

	err = runtime.BindStyledParameterWithOptions("simple", "type", chi.URLParam(r, "type"), &pType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMarketplaceListing(w, r, pType)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// MarketplaceAppAPIKeyInstall operation middleware
func (siw *ServerInterfaceWrapper) MarketplaceAppAPIKeyInstall(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "type" -------------
	var pType MarketplaceApiKeyInstallRequestType

	err = runtime.BindStyledParameterWithOptions("simple", "type", chi.URLParam(r, "type"), &pType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MarketplaceAppAPIKeyInstall(w, r, pType)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// MarketplaceOAuth2InstallGetURL operation middleware
func (siw *ServerInterfaceWrapper) MarketplaceOAuth2InstallGetURL(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "type" -------------
	var pType AppType

	err = runtime.BindStyledParameterWithOptions("simple", "type", chi.URLParam(r, "type"), &pType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MarketplaceOAuth2InstallGetURL(w, r, pType)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// MarketplaceOAuth2InstallAuthorize operation middleware
func (siw *ServerInterfaceWrapper) MarketplaceOAuth2InstallAuthorize(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "type" -------------
	var pType MarketplaceOAuth2InstallAuthorizeRequestType

	err = runtime.BindStyledParameterWithOptions("simple", "type", chi.URLParam(r, "type"), &pType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params MarketplaceOAuth2InstallAuthorizeParams

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", false, false, "code", r.URL.Query(), &params.Code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Optional query parameter "error" -------------

	err = runtime.BindQueryParameter("form", false, false, "error", r.URL.Query(), &params.Error)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "error", Err: err})
		return
	}

	// ------------- Optional query parameter "error_description" -------------

	err = runtime.BindQueryParameter("form", false, false, "error_description", r.URL.Query(), &params.ErrorDescription)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "error_description", Err: err})
		return
	}

	// ------------- Optional query parameter "error_uri" -------------

	err = runtime.BindQueryParameter("form", false, false, "error_uri", r.URL.Query(), &params.ErrorUri)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "error_uri", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MarketplaceOAuth2InstallAuthorize(w, r, pType, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListMeters operation middleware
func (siw *ServerInterfaceWrapper) ListMeters(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMeters(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMeter operation middleware
func (siw *ServerInterfaceWrapper) GetMeter(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "meterIdOrSlug" -------------
	var meterIdOrSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "meterIdOrSlug", chi.URLParam(r, "meterIdOrSlug"), &meterIdOrSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "meterIdOrSlug", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMeter(w, r, meterIdOrSlug)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// QueryMeter operation middleware
func (siw *ServerInterfaceWrapper) QueryMeter(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "meterIdOrSlug" -------------
	var meterIdOrSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "meterIdOrSlug", chi.URLParam(r, "meterIdOrSlug"), &meterIdOrSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "meterIdOrSlug", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryMeterParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "windowSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "windowSize", r.URL.Query(), &params.WindowSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowSize", Err: err})
		return
	}

	// ------------- Optional query parameter "windowTimeZone" -------------

	err = runtime.BindQueryParameter("form", true, false, "windowTimeZone", r.URL.Query(), &params.WindowTimeZone)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowTimeZone", Err: err})
		return
	}

	// ------------- Optional query parameter "subject" -------------

	err = runtime.BindQueryParameter("form", true, false, "subject", r.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subject", Err: err})
		return
	}

	// ------------- Optional query parameter "filterGroupBy" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "filterGroupBy", r.URL.Query(), &params.FilterGroupBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filterGroupBy", Err: err})
		return
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", r.URL.Query(), &params.GroupBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QueryMeter(w, r, meterIdOrSlug, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListMeterSubjects operation middleware
func (siw *ServerInterfaceWrapper) ListMeterSubjects(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "meterIdOrSlug" -------------
	var meterIdOrSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "meterIdOrSlug", chi.URLParam(r, "meterIdOrSlug"), &meterIdOrSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "meterIdOrSlug", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListMeterSubjects(w, r, meterIdOrSlug)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNotificationChannels operation middleware
func (siw *ServerInterfaceWrapper) ListNotificationChannels(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNotificationChannelsParams

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	// ------------- Optional query parameter "includeDisabled" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeDisabled", r.URL.Query(), &params.IncludeDisabled)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDisabled", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNotificationChannels(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateNotificationChannel operation middleware
func (siw *ServerInterfaceWrapper) CreateNotificationChannel(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateNotificationChannel(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteNotificationChannel operation middleware
func (siw *ServerInterfaceWrapper) DeleteNotificationChannel(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "channelId" -------------
	var channelId string

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", chi.URLParam(r, "channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "channelId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteNotificationChannel(w, r, channelId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNotificationChannel operation middleware
func (siw *ServerInterfaceWrapper) GetNotificationChannel(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "channelId" -------------
	var channelId string

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", chi.URLParam(r, "channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "channelId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNotificationChannel(w, r, channelId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateNotificationChannel operation middleware
func (siw *ServerInterfaceWrapper) UpdateNotificationChannel(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "channelId" -------------
	var channelId string

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", chi.URLParam(r, "channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "channelId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateNotificationChannel(w, r, channelId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNotificationEvents operation middleware
func (siw *ServerInterfaceWrapper) ListNotificationEvents(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNotificationEventsParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "feature" -------------

	err = runtime.BindQueryParameter("form", true, false, "feature", r.URL.Query(), &params.Feature)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "feature", Err: err})
		return
	}

	// ------------- Optional query parameter "subject" -------------

	err = runtime.BindQueryParameter("form", true, false, "subject", r.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subject", Err: err})
		return
	}

	// ------------- Optional query parameter "rule" -------------

	err = runtime.BindQueryParameter("form", true, false, "rule", r.URL.Query(), &params.Rule)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rule", Err: err})
		return
	}

	// ------------- Optional query parameter "channel" -------------

	err = runtime.BindQueryParameter("form", true, false, "channel", r.URL.Query(), &params.Channel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "channel", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNotificationEvents(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNotificationEvent operation middleware
func (siw *ServerInterfaceWrapper) GetNotificationEvent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "eventId" -------------
	var eventId string

	err = runtime.BindStyledParameterWithOptions("simple", "eventId", chi.URLParam(r, "eventId"), &eventId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "eventId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNotificationEvent(w, r, eventId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNotificationRules operation middleware
func (siw *ServerInterfaceWrapper) ListNotificationRules(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNotificationRulesParams

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	// ------------- Optional query parameter "includeDisabled" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeDisabled", r.URL.Query(), &params.IncludeDisabled)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDisabled", Err: err})
		return
	}

	// ------------- Optional query parameter "feature" -------------

	err = runtime.BindQueryParameter("form", true, false, "feature", r.URL.Query(), &params.Feature)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "feature", Err: err})
		return
	}

	// ------------- Optional query parameter "channel" -------------

	err = runtime.BindQueryParameter("form", true, false, "channel", r.URL.Query(), &params.Channel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "channel", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNotificationRules(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateNotificationRule operation middleware
func (siw *ServerInterfaceWrapper) CreateNotificationRule(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateNotificationRule(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteNotificationRule operation middleware
func (siw *ServerInterfaceWrapper) DeleteNotificationRule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", chi.URLParam(r, "ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteNotificationRule(w, r, ruleId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNotificationRule operation middleware
func (siw *ServerInterfaceWrapper) GetNotificationRule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", chi.URLParam(r, "ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNotificationRule(w, r, ruleId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateNotificationRule operation middleware
func (siw *ServerInterfaceWrapper) UpdateNotificationRule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", chi.URLParam(r, "ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateNotificationRule(w, r, ruleId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// TestNotificationRule operation middleware
func (siw *ServerInterfaceWrapper) TestNotificationRule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "ruleId" -------------
	var ruleId string

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", chi.URLParam(r, "ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ruleId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TestNotificationRule(w, r, ruleId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ReceiveSvixOperationalEvent operation middleware
func (siw *ServerInterfaceWrapper) ReceiveSvixOperationalEvent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReceiveSvixOperationalEvent(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPlans operation middleware
func (siw *ServerInterfaceWrapper) ListPlans(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPlansParams

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "key" -------------

	err = runtime.BindQueryParameter("form", true, false, "key", r.URL.Query(), &params.Key)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "key", Err: err})
		return
	}

	// ------------- Optional query parameter "keyVersion" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "keyVersion", r.URL.Query(), &params.KeyVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "keyVersion", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPlans(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePlan operation middleware
func (siw *ServerInterfaceWrapper) CreatePlan(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePlan(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// NextPlan operation middleware
func (siw *ServerInterfaceWrapper) NextPlan(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planIdOrKey" -------------
	var planIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "planIdOrKey", chi.URLParam(r, "planIdOrKey"), &planIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planIdOrKey", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.NextPlan(w, r, planIdOrKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePlan operation middleware
func (siw *ServerInterfaceWrapper) DeletePlan(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planId" -------------
	var planId string

	err = runtime.BindStyledParameterWithOptions("simple", "planId", chi.URLParam(r, "planId"), &planId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePlan(w, r, planId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPlan operation middleware
func (siw *ServerInterfaceWrapper) GetPlan(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planId" -------------
	var planId string

	err = runtime.BindStyledParameterWithOptions("simple", "planId", chi.URLParam(r, "planId"), &planId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPlanParams

	// ------------- Optional query parameter "includeLatest" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeLatest", r.URL.Query(), &params.IncludeLatest)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeLatest", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPlan(w, r, planId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdatePlan operation middleware
func (siw *ServerInterfaceWrapper) UpdatePlan(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planId" -------------
	var planId string

	err = runtime.BindStyledParameterWithOptions("simple", "planId", chi.URLParam(r, "planId"), &planId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePlan(w, r, planId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ArchivePlan operation middleware
func (siw *ServerInterfaceWrapper) ArchivePlan(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planId" -------------
	var planId string

	err = runtime.BindStyledParameterWithOptions("simple", "planId", chi.URLParam(r, "planId"), &planId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ArchivePlan(w, r, planId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPlanPhases operation middleware
func (siw *ServerInterfaceWrapper) ListPlanPhases(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planId" -------------
	var planId string

	err = runtime.BindStyledParameterWithOptions("simple", "planId", chi.URLParam(r, "planId"), &planId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPlanPhasesParams

	// ------------- Optional query parameter "key" -------------

	err = runtime.BindQueryParameter("form", true, false, "key", r.URL.Query(), &params.Key)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "key", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", false, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", false, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", false, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPlanPhases(w, r, planId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePlanPhase operation middleware
func (siw *ServerInterfaceWrapper) CreatePlanPhase(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planId" -------------
	var planId string

	err = runtime.BindStyledParameterWithOptions("simple", "planId", chi.URLParam(r, "planId"), &planId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePlanPhase(w, r, planId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePlanPhase operation middleware
func (siw *ServerInterfaceWrapper) DeletePlanPhase(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planId" -------------
	var planId string

	err = runtime.BindStyledParameterWithOptions("simple", "planId", chi.URLParam(r, "planId"), &planId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planId", Err: err})
		return
	}

	// ------------- Path parameter "planPhaseKey" -------------
	var planPhaseKey string

	err = runtime.BindStyledParameterWithOptions("simple", "planPhaseKey", chi.URLParam(r, "planPhaseKey"), &planPhaseKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planPhaseKey", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePlanPhase(w, r, planId, planPhaseKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPlanPhase operation middleware
func (siw *ServerInterfaceWrapper) GetPlanPhase(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planId" -------------
	var planId string

	err = runtime.BindStyledParameterWithOptions("simple", "planId", chi.URLParam(r, "planId"), &planId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planId", Err: err})
		return
	}

	// ------------- Path parameter "planPhaseKey" -------------
	var planPhaseKey string

	err = runtime.BindStyledParameterWithOptions("simple", "planPhaseKey", chi.URLParam(r, "planPhaseKey"), &planPhaseKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planPhaseKey", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPlanPhase(w, r, planId, planPhaseKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdatePlanPhase operation middleware
func (siw *ServerInterfaceWrapper) UpdatePlanPhase(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planId" -------------
	var planId string

	err = runtime.BindStyledParameterWithOptions("simple", "planId", chi.URLParam(r, "planId"), &planId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planId", Err: err})
		return
	}

	// ------------- Path parameter "planPhaseKey" -------------
	var planPhaseKey string

	err = runtime.BindStyledParameterWithOptions("simple", "planPhaseKey", chi.URLParam(r, "planPhaseKey"), &planPhaseKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planPhaseKey", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePlanPhase(w, r, planId, planPhaseKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PublishPlan operation middleware
func (siw *ServerInterfaceWrapper) PublishPlan(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "planId" -------------
	var planId string

	err = runtime.BindStyledParameterWithOptions("simple", "planId", chi.URLParam(r, "planId"), &planId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "planId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PublishPlan(w, r, planId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// QueryPortalMeter operation middleware
func (siw *ServerInterfaceWrapper) QueryPortalMeter(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "meterSlug" -------------
	var meterSlug string

	err = runtime.BindStyledParameterWithOptions("simple", "meterSlug", chi.URLParam(r, "meterSlug"), &meterSlug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "meterSlug", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PortalTokenAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryPortalMeterParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "windowSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "windowSize", r.URL.Query(), &params.WindowSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowSize", Err: err})
		return
	}

	// ------------- Optional query parameter "windowTimeZone" -------------

	err = runtime.BindQueryParameter("form", true, false, "windowTimeZone", r.URL.Query(), &params.WindowTimeZone)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowTimeZone", Err: err})
		return
	}

	// ------------- Optional query parameter "filterGroupBy" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "filterGroupBy", r.URL.Query(), &params.FilterGroupBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filterGroupBy", Err: err})
		return
	}

	// ------------- Optional query parameter "groupBy" -------------

	err = runtime.BindQueryParameter("form", true, false, "groupBy", r.URL.Query(), &params.GroupBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QueryPortalMeter(w, r, meterSlug, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPortalTokens operation middleware
func (siw *ServerInterfaceWrapper) ListPortalTokens(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPortalTokensParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", false, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPortalTokens(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePortalToken operation middleware
func (siw *ServerInterfaceWrapper) CreatePortalToken(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePortalToken(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListSubjectEntitlements operation middleware
func (siw *ServerInterfaceWrapper) ListSubjectEntitlements(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSubjectEntitlementsParams

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSubjectEntitlements(w, r, subjectIdOrKey, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateEntitlement operation middleware
func (siw *ServerInterfaceWrapper) CreateEntitlement(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateEntitlement(w, r, subjectIdOrKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListEntitlementGrants operation middleware
func (siw *ServerInterfaceWrapper) ListEntitlementGrants(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementIdOrFeatureKey" -------------
	var entitlementIdOrFeatureKey string

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementIdOrFeatureKey", chi.URLParam(r, "entitlementIdOrFeatureKey"), &entitlementIdOrFeatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementIdOrFeatureKey", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEntitlementGrantsParams

	// ------------- Optional query parameter "includeDeleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "includeDeleted", r.URL.Query(), &params.IncludeDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeDeleted", Err: err})
		return
	}

	// ------------- Optional query parameter "orderBy" -------------

	err = runtime.BindQueryParameter("form", false, false, "orderBy", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderBy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListEntitlementGrants(w, r, subjectIdOrKey, entitlementIdOrFeatureKey, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateGrant operation middleware
func (siw *ServerInterfaceWrapper) CreateGrant(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementIdOrFeatureKey" -------------
	var entitlementIdOrFeatureKey string

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementIdOrFeatureKey", chi.URLParam(r, "entitlementIdOrFeatureKey"), &entitlementIdOrFeatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementIdOrFeatureKey", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGrant(w, r, subjectIdOrKey, entitlementIdOrFeatureKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// OverrideEntitlement operation middleware
func (siw *ServerInterfaceWrapper) OverrideEntitlement(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementIdOrFeatureKey" -------------
	var entitlementIdOrFeatureKey string

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementIdOrFeatureKey", chi.URLParam(r, "entitlementIdOrFeatureKey"), &entitlementIdOrFeatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementIdOrFeatureKey", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OverrideEntitlement(w, r, subjectIdOrKey, entitlementIdOrFeatureKey)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetEntitlementValue operation middleware
func (siw *ServerInterfaceWrapper) GetEntitlementValue(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementIdOrFeatureKey" -------------
	var entitlementIdOrFeatureKey string

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementIdOrFeatureKey", chi.URLParam(r, "entitlementIdOrFeatureKey"), &entitlementIdOrFeatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementIdOrFeatureKey", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntitlementValueParams

	// ------------- Optional query parameter "time" -------------

	err = runtime.BindQueryParameter("form", true, false, "time", r.URL.Query(), &params.Time)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntitlementValue(w, r, subjectIdOrKey, entitlementIdOrFeatureKey, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteEntitlement operation middleware
func (siw *ServerInterfaceWrapper) DeleteEntitlement(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementId" -------------
	var entitlementId string

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementId", chi.URLParam(r, "entitlementId"), &entitlementId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteEntitlement(w, r, subjectIdOrKey, entitlementId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetEntitlement operation middleware
func (siw *ServerInterfaceWrapper) GetEntitlement(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementId" -------------
	var entitlementId string

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementId", chi.URLParam(r, "entitlementId"), &entitlementId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntitlement(w, r, subjectIdOrKey, entitlementId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetEntitlementHistory operation middleware
func (siw *ServerInterfaceWrapper) GetEntitlementHistory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementId" -------------
	var entitlementId string

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementId", chi.URLParam(r, "entitlementId"), &entitlementId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntitlementHistoryParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Required query parameter "windowSize" -------------

	if paramValue := r.URL.Query().Get("windowSize"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "windowSize"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "windowSize", r.URL.Query(), &params.WindowSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowSize", Err: err})
		return
	}

	// ------------- Optional query parameter "windowTimeZone" -------------

	err = runtime.BindQueryParameter("form", true, false, "windowTimeZone", r.URL.Query(), &params.WindowTimeZone)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "windowTimeZone", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEntitlementHistory(w, r, subjectIdOrKey, entitlementId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ResetEntitlementUsage operation middleware
func (siw *ServerInterfaceWrapper) ResetEntitlementUsage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subjectIdOrKey" -------------
	var subjectIdOrKey string

	err = runtime.BindStyledParameterWithOptions("simple", "subjectIdOrKey", chi.URLParam(r, "subjectIdOrKey"), &subjectIdOrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subjectIdOrKey", Err: err})
		return
	}

	// ------------- Path parameter "entitlementId" -------------
	var entitlementId string

	err = runtime.BindStyledParameterWithOptions("simple", "entitlementId", chi.URLParam(r, "entitlementId"), &entitlementId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "entitlementId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResetEntitlementUsage(w, r, subjectIdOrKey, entitlementId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateSubscription operation middleware
func (siw *ServerInterfaceWrapper) CreateSubscription(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSubscription(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSubscription operation middleware
func (siw *ServerInterfaceWrapper) GetSubscription(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", chi.URLParam(r, "subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subscriptionId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSubscriptionParams

	// ------------- Optional query parameter "expand" -------------

	err = runtime.BindQueryParameter("form", false, false, "expand", r.URL.Query(), &params.Expand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expand", Err: err})
		return
	}

	// ------------- Optional query parameter "at" -------------

	err = runtime.BindQueryParameter("form", false, false, "at", r.URL.Query(), &params.At)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "at", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSubscription(w, r, subscriptionId, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// EditSubscription operation middleware
func (siw *ServerInterfaceWrapper) EditSubscription(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", chi.URLParam(r, "subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subscriptionId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditSubscription(w, r, subscriptionId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CancelSubscription operation middleware
func (siw *ServerInterfaceWrapper) CancelSubscription(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", chi.URLParam(r, "subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subscriptionId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelSubscription(w, r, subscriptionId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// MigrateSubscription operation middleware
func (siw *ServerInterfaceWrapper) MigrateSubscription(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", chi.URLParam(r, "subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subscriptionId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MigrateSubscription(w, r, subscriptionId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UnscheduleCancelation operation middleware
func (siw *ServerInterfaceWrapper) UnscheduleCancelation(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "subscriptionId" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithOptions("simple", "subscriptionId", chi.URLParam(r, "subscriptionId"), &subscriptionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "subscriptionId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UnscheduleCancelation(w, r, subscriptionId)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/apps", wrapper.ListApps)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/apps/{id}", wrapper.UninstallApp)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/apps/{id}", wrapper.GetApp)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/apps/{id}/stripe/webhook", wrapper.AppStripeWebhook)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/billing/customer", wrapper.BillingListCustomerOverrides)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/billing/customer/{customerId}", wrapper.BillingDeleteCustomerOverride)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/billing/customer/{customerId}", wrapper.BillingGetCustomerOverrideById)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/billing/customer/{customerId}", wrapper.BillingUpsertCustomerOverride)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/billing/invoices", wrapper.BillingListInvoices)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/billing/invoices/{customerId}", wrapper.BillingListInvoicesByCustomer)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/billing/invoices/{customerId}", wrapper.BillingCreateInvoice)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}", wrapper.BillingDeleteInvoiceByCustomerInvoiceId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}", wrapper.BillingGetInvoiceByCustomerInvoiceId)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/advance", wrapper.BillingInvoiceAdvance)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/approve", wrapper.BillingApproveInvoice)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/lines/{lineId}", wrapper.BillingDeleteInvoiceLine)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/lines/{lineId}", wrapper.BillingUpdateInvoiceLine)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/retry", wrapper.BillingInvoiceRetry)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/tax/recalculate", wrapper.BillingRecalculateInvoiceTax)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/billing/invoices/{customerId}/invoices/{invoiceId}/void", wrapper.BillingVoidInvoice)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/billing/invoices/{customerId}/lines", wrapper.BillingCreateLineByCustomer)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/billing/profile", wrapper.BillingListProfiles)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/billing/profile", wrapper.BillingCreateProfile)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/billing/profile/{id}", wrapper.BillingArchiveProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/billing/profile/{id}", wrapper.BillingGetProfile)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/billing/profile/{id}", wrapper.BillingUpdateProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/customers", wrapper.ListCustomers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/customers", wrapper.CreateCustomer)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/customers/{id}", wrapper.DeleteCustomer)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/customers/{id}", wrapper.GetCustomer)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/customers/{id}", wrapper.UpdateCustomer)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/debug/metrics", wrapper.GetDebugMetrics)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/entitlements", wrapper.ListEntitlements)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/entitlements/{entitlementId}", wrapper.GetEntitlementById)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/events", wrapper.ListEvents)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/events", wrapper.IngestEvents)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/features", wrapper.ListFeatures)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/features", wrapper.CreateFeature)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/features/{featureId}", wrapper.DeleteFeature)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/features/{featureId}", wrapper.GetFeature)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/grants", wrapper.ListGrants)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/grants/{grantId}", wrapper.VoidGrant)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/integration/stripe/checkout/sessions", wrapper.CreateStripeCheckoutSession)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/marketplace/listings", wrapper.ListMarketplaceListings)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/marketplace/listings/{type}", wrapper.GetMarketplaceListing)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/marketplace/listings/{type}/install/apikey", wrapper.MarketplaceAppAPIKeyInstall)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/marketplace/listings/{type}/install/oauth2", wrapper.MarketplaceOAuth2InstallGetURL)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/marketplace/listings/{type}/install/oauth2/authorize", wrapper.MarketplaceOAuth2InstallAuthorize)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/meters", wrapper.ListMeters)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/meters/{meterIdOrSlug}", wrapper.GetMeter)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/meters/{meterIdOrSlug}/query", wrapper.QueryMeter)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/meters/{meterIdOrSlug}/subjects", wrapper.ListMeterSubjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/channels", wrapper.ListNotificationChannels)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/notification/channels", wrapper.CreateNotificationChannel)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/notification/channels/{channelId}", wrapper.DeleteNotificationChannel)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/channels/{channelId}", wrapper.GetNotificationChannel)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/notification/channels/{channelId}", wrapper.UpdateNotificationChannel)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/events", wrapper.ListNotificationEvents)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/events/{eventId}", wrapper.GetNotificationEvent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/rules", wrapper.ListNotificationRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/notification/rules", wrapper.CreateNotificationRule)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/notification/rules/{ruleId}", wrapper.DeleteNotificationRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/notification/rules/{ruleId}", wrapper.GetNotificationRule)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/notification/rules/{ruleId}", wrapper.UpdateNotificationRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/notification/rules/{ruleId}/test", wrapper.TestNotificationRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/notification/webhook/svix", wrapper.ReceiveSvixOperationalEvent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/plans", wrapper.ListPlans)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/plans", wrapper.CreatePlan)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/plans/{planIdOrKey}/next", wrapper.NextPlan)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/plans/{planId}", wrapper.DeletePlan)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/plans/{planId}", wrapper.GetPlan)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/plans/{planId}", wrapper.UpdatePlan)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/plans/{planId}/archive", wrapper.ArchivePlan)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/plans/{planId}/phases", wrapper.ListPlanPhases)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/plans/{planId}/phases", wrapper.CreatePlanPhase)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/plans/{planId}/phases/{planPhaseKey}", wrapper.DeletePlanPhase)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/plans/{planId}/phases/{planPhaseKey}", wrapper.GetPlanPhase)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/plans/{planId}/phases/{planPhaseKey}", wrapper.UpdatePlanPhase)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/plans/{planId}/publish", wrapper.PublishPlan)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/portal/meters/{meterSlug}/query", wrapper.QueryPortalMeter)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/portal/tokens", wrapper.ListPortalTokens)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/portal/tokens", wrapper.CreatePortalToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements", wrapper.ListSubjectEntitlements)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements", wrapper.CreateEntitlement)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants", wrapper.ListEntitlementGrants)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/grants", wrapper.CreateGrant)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/override", wrapper.OverrideEntitlement)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementIdOrFeatureKey}/value", wrapper.GetEntitlementValue)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}", wrapper.DeleteEntitlement)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}", wrapper.GetEntitlement)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/history", wrapper.GetEntitlementHistory)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subjects/{subjectIdOrKey}/entitlements/{entitlementId}/reset", wrapper.ResetEntitlementUsage)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subscriptions", wrapper.CreateSubscription)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/v1/subscriptions/{subscriptionId}", wrapper.GetSubscription)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/api/v1/subscriptions/{subscriptionId}", wrapper.EditSubscription)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subscriptions/{subscriptionId}/cancel", wrapper.CancelSubscription)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subscriptions/{subscriptionId}/migrate", wrapper.MigrateSubscription)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/v1/subscriptions/{subscriptionId}/unschedule-cancelation", wrapper.UnscheduleCancelation)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"1qcPn/5vAAAA//8iEw1y3tIGAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
